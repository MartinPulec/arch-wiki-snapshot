<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-0 vector-feature-client-preferences-disabled vector-feature-client-prefs-pinned-disabled vector-feature-night-mode-disabled skin-theme-clientpref-day vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>GRUB (Русский) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.42.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-GRUB_Русский rootpage-GRUB_Русский skin-vector-2022 action-view skin--responsive">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" role="navigation" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Предисловие" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B5%D0%B4%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">1</span>Предисловие</div>
		</a>
		
			<button aria-controls="toc-Предисловие-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Предисловие subsection</span>
			</button>
		
		<ul id="toc-Предисловие-sublist" class="vector-toc-list">
			<li id="toc-Замечание_для_текущих_и_бывших_пользователей_GRUB_Legacy" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B4%D0%BB%D1%8F_%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B8%D1%85_%D0%B8_%D0%B1%D1%8B%D0%B2%D1%88%D0%B8%D1%85_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9_GRUB_Legacy">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">1.1</span>Замечание для текущих и бывших пользователей GRUB Legacy</div>
			</a>
			
			<ul id="toc-Замечание_для_текущих_и_бывших_пользователей_GRUB_Legacy-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Требования_к_диску" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA_%D0%B4%D0%B8%D1%81%D0%BA%D1%83">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">2</span>Требования к диску</div>
		</a>
		
			<button aria-controls="toc-Требования_к_диску-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Требования к диску subsection</span>
			</button>
		
		<ul id="toc-Требования_к_диску-sublist" class="vector-toc-list">
			<li id="toc-Загрузчик_в_BIOS" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA_%D0%B2_BIOS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.1</span>Загрузчик в BIOS</div>
			</a>
			
			<ul id="toc-Загрузчик_в_BIOS-sublist" class="vector-toc-list">
				<li id="toc-Требования_GRUB2-BIOS_к_MBR" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_GRUB2-BIOS_%D0%BA_MBR">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.1.1</span>Требования GRUB2-BIOS к MBR</div>
			</a>
			
			<ul id="toc-Требования_GRUB2-BIOS_к_MBR-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Требования_GRUB2-BIOS_к_GPT" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_GRUB2-BIOS_%D0%BA_GPT">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.1.2</span>Требования GRUB2-BIOS к GPT</div>
			</a>
			
			<ul id="toc-Требования_GRUB2-BIOS_к_GPT-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Загрузчик_в_UEFI" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA_%D0%B2_UEFI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.2</span>Загрузчик в UEFI</div>
			</a>
			
			<ul id="toc-Загрузчик_в_UEFI-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Рекомендации_по_установке_загрузчика" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%A0%D0%B5%D0%BA%D0%BE%D0%BC%D0%B5%D0%BD%D0%B4%D0%B0%D1%86%D0%B8%D0%B8_%D0%BF%D0%BE_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B5_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">3</span>Рекомендации по установке загрузчика</div>
		</a>
		
			<button aria-controls="toc-Рекомендации_по_установке_загрузчика-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Рекомендации по установке загрузчика subsection</span>
			</button>
		
		<ul id="toc-Рекомендации_по_установке_загрузчика-sublist" class="vector-toc-list">
			<li id="toc-Выбор_раздела" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%92%D1%8B%D0%B1%D0%BE%D1%80_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1</span>Выбор раздела</div>
			</a>
			
			<ul id="toc-Выбор_раздела-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Выбор_таблицы_разделов" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%92%D1%8B%D0%B1%D0%BE%D1%80_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.2</span>Выбор таблицы разделов</div>
			</a>
			
			<ul id="toc-Выбор_таблицы_разделов-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Установка" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">4</span>Установка</div>
		</a>
		
			<button aria-controls="toc-Установка-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Установка subsection</span>
			</button>
		
		<ul id="toc-Установка-sublist" class="vector-toc-list">
			<li id="toc-Установка_GRUB2_в_процессе_установки_Arch_Linux" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_GRUB2_%D0%B2_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B5_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_Arch_Linux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.1</span>Установка GRUB2 в процессе установки Arch Linux</div>
			</a>
			
			<ul id="toc-Установка_GRUB2_в_процессе_установки_Arch_Linux-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Установка_пакета" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.2</span>Установка пакета</div>
			</a>
			
			<ul id="toc-Установка_пакета-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Установка_загрузчика" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3</span>Установка загрузчика</div>
			</a>
			
			<ul id="toc-Установка_загрузчика-sublist" class="vector-toc-list">
				<li id="toc-Установка_BIOS-версии_загрузчика" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_BIOS-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.1</span>Установка BIOS-версии загрузчика</div>
			</a>
			
			<ul id="toc-Установка_BIOS-версии_загрузчика-sublist" class="vector-toc-list">
				<li id="toc-Полноценная_установка_для_BIOS" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%9F%D0%BE%D0%BB%D0%BD%D0%BE%D1%86%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B4%D0%BB%D1%8F_BIOS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.1.1</span>Полноценная установка для BIOS</div>
			</a>
			
			<ul id="toc-Полноценная_установка_для_BIOS-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Генерация_загрузочного_образа_для_BIOS_без_установки" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B0_%D0%B4%D0%BB%D1%8F_BIOS_%D0%B1%D0%B5%D0%B7_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.1.2</span>Генерация загрузочного образа для BIOS без установки</div>
			</a>
			
			<ul id="toc-Генерация_загрузочного_образа_для_BIOS_без_установки-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Установка_UEFI-версии_загрузчика" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_UEFI-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.2</span>Установка UEFI-версии загрузчика</div>
			</a>
			
			<ul id="toc-Установка_UEFI-версии_загрузчика-sublist" class="vector-toc-list">
				<li id="toc-В_режиме_UEFI" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%92_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5_UEFI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.2.1</span>В режиме UEFI</div>
			</a>
			
			<ul id="toc-В_режиме_UEFI-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Без_доступа_к_UEFI" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%91%D0%B5%D0%B7_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0_%D0%BA_UEFI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.2.2</span>Без доступа к UEFI</div>
			</a>
			
			<ul id="toc-Без_доступа_к_UEFI-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Из_32-битного_Arch" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%98%D0%B7_32-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_Arch">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.2.3</span>Из 32-битного Arch</div>
			</a>
			
			<ul id="toc-Из_32-битного_Arch-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Установка_в_LVM" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2_LVM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.3</span>Установка в LVM</div>
			</a>
			
			<ul id="toc-Установка_в_LVM-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Установка_на_образ_диска" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BD%D0%B0_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3.4</span>Установка на образ диска</div>
			</a>
			
			<ul id="toc-Установка_на_образ_диска-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Переустановка_загрузчика" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9F%D0%B5%D1%80%D0%B5%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.4</span>Переустановка загрузчика</div>
			</a>
			
			<ul id="toc-Переустановка_загрузчика-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Перенос_загрузчика" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.5</span>Перенос загрузчика</div>
			</a>
			
			<ul id="toc-Перенос_загрузчика-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-После_установки" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9F%D0%BE%D1%81%D0%BB%D0%B5_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.6</span>После установки</div>
			</a>
			
			<ul id="toc-После_установки-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Настройка" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">5</span>Настройка</div>
		</a>
		
			<button aria-controls="toc-Настройка-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Настройка subsection</span>
			</button>
		
		<ul id="toc-Настройка-sublist" class="vector-toc-list">
			<li id="toc-Главный_файл_конфигурации_загрузчика" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.1</span>Главный файл конфигурации загрузчика</div>
			</a>
			
			<ul id="toc-Главный_файл_конфигурации_загрузчика-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Автоматическая_конфигурация_(grub-mkconfig)" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_(grub-mkconfig)">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.2</span>Автоматическая конфигурация (grub-mkconfig)</div>
			</a>
			
			<ul id="toc-Автоматическая_конфигурация_(grub-mkconfig)-sublist" class="vector-toc-list">
				<li id="toc-Генерация_конфига" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.2.1</span>Генерация конфига</div>
			</a>
			
			<ul id="toc-Генерация_конфига-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Параметры_конфигуратора" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.2.2</span>Параметры конфигуратора</div>
			</a>
			
			<ul id="toc-Параметры_конфигуратора-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Прямая_конфигурация" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.3</span>Прямая конфигурация</div>
			</a>
			
			<ul id="toc-Прямая_конфигурация-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Защита_конфигурации" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4</span>Защита конфигурации</div>
			</a>
			
			<ul id="toc-Защита_конфигурации-sublist" class="vector-toc-list">
				<li id="toc-Вынос_конфигурации_в_другой_файл" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%92%D1%8B%D0%BD%D0%BE%D1%81_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8_%D0%B2_%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4.1</span>Вынос конфигурации в другой файл</div>
			</a>
			
			<ul id="toc-Вынос_конфигурации_в_другой_файл-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Прямая_блокировка_grub.cfg" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_grub.cfg">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4.2</span>Прямая блокировка grub.cfg</div>
			</a>
			
			<ul id="toc-Прямая_блокировка_grub.cfg-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Перенос_каталога_grub" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81_%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B0_grub">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4.3</span>Перенос каталога grub</div>
			</a>
			
			<ul id="toc-Перенос_каталога_grub-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Синтаксис_файла_конфигурации_GRUB" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8_GRUB">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5</span>Синтаксис файла конфигурации GRUB</div>
			</a>
			
			<ul id="toc-Синтаксис_файла_конфигурации_GRUB-sublist" class="vector-toc-list">
				<li id="toc-Пример_минимальной_работающей_конфигурации" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5.1</span>Пример минимальной работающей конфигурации</div>
			</a>
			
			<ul id="toc-Пример_минимальной_работающей_конфигурации-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Основные_команды_и_переменные" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B_%D0%B8_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5.2</span>Основные команды и переменные</div>
			</a>
			
			<ul id="toc-Основные_команды_и_переменные-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Стандартный_пример_конфигурации" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5.3</span>Стандартный пример конфигурации</div>
			</a>
			
			<ul id="toc-Стандартный_пример_конфигурации-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Вторичные_конфиги,_вложенные_меню_и_смена_контекста" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%92%D1%82%D0%BE%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B8,_%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BC%D0%B5%D0%BD%D1%8E_%D0%B8_%D1%81%D0%BC%D0%B5%D0%BD%D0%B0_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5.4</span>Вторичные конфиги, вложенные меню и смена контекста</div>
			</a>
			
			<ul id="toc-Вторичные_конфиги,_вложенные_меню_и_смена_контекста-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Постоянное_именование_устройств" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%BE%D0%B5_%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6</span>Постоянное именование устройств</div>
			</a>
			
			<ul id="toc-Постоянное_именование_устройств-sublist" class="vector-toc-list">
				<li id="toc-UUID" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#UUID">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1</span>UUID</div>
			</a>
			
			<ul id="toc-UUID-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Метки" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9C%D0%B5%D1%82%D0%BA%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.2</span>Метки</div>
			</a>
			
			<ul id="toc-Метки-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Особые_типы_устройств" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9E%D1%81%D0%BE%D0%B1%D1%8B%D0%B5_%D1%82%D0%B8%D0%BF%D1%8B_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7</span>Особые типы устройств</div>
			</a>
			
			<ul id="toc-Особые_типы_устройств-sublist" class="vector-toc-list">
				<li id="toc-LVM" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#LVM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.1</span>LVM</div>
			</a>
			
			<ul id="toc-LVM-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Загрузка_других_операционных_систем" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D1%85_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D1%85_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8</span>Загрузка других операционных систем</div>
			</a>
			
			<ul id="toc-Загрузка_других_операционных_систем-sublist" class="vector-toc-list">
				<li id="toc-GNU/Linux" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#GNU/Linux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.1</span>GNU/Linux</div>
			</a>
			
			<ul id="toc-GNU/Linux-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Windows" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.2</span>Windows</div>
			</a>
			
			<ul id="toc-Windows-sublist" class="vector-toc-list">
				<li id="toc-Windows_в_режиме_BIOS" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Windows_%D0%B2_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5_BIOS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.2.1</span>Windows в режиме BIOS</div>
			</a>
			
			<ul id="toc-Windows_в_режиме_BIOS-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Windows_в_режиме_UEFI" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Windows_%D0%B2_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5_UEFI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.2.2</span>Windows в режиме UEFI</div>
			</a>
			
			<ul id="toc-Windows_в_режиме_UEFI-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Запуск_FreeDOS" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA_FreeDOS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.3</span>Запуск FreeDOS</div>
			</a>
			
			<ul id="toc-Запуск_FreeDOS-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Запуск_программ,_работающих_без_ОС" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC,_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B8%D1%85_%D0%B1%D0%B5%D0%B7_%D0%9E%D0%A1">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.4</span>Запуск программ, работающих без ОС</div>
			</a>
			
			<ul id="toc-Запуск_программ,_работающих_без_ОС-sublist" class="vector-toc-list">
				<li id="toc-Memtest86+" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Memtest86+">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.4.1</span>Memtest86+</div>
			</a>
			
			<ul id="toc-Memtest86+-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-EFI-приложения" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#EFI-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.4.2</span>EFI-приложения</div>
			</a>
			
			<ul id="toc-EFI-приложения-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Debian,_Ubuntu_и_другие_дистрибутивы_с_версионным_обновлением_ядра" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Debian,_Ubuntu_%D0%B8_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5_%D0%B4%D0%B8%D1%81%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B8%D0%B2%D1%8B_%D1%81_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%BC_%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D1%8F%D0%B4%D1%80%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.5</span>Debian, Ubuntu и другие дистрибутивы с версионным обновлением ядра</div>
			</a>
			
			<ul id="toc-Debian,_Ubuntu_и_другие_дистрибутивы_с_версионным_обновлением_ядра-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Прямая_загрузка_из_образа_диска" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%B8%D0%B7_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.6</span>Прямая загрузка из образа диска</div>
			</a>
			
			<ul id="toc-Прямая_загрузка_из_образа_диска-sublist" class="vector-toc-list">
				<li id="toc-Arch_Linux_ISO" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Arch_Linux_ISO">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.6.1</span>Arch Linux ISO</div>
			</a>
			
			<ul id="toc-Arch_Linux_ISO-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Ubuntu_desktop_ISO" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Ubuntu_desktop_ISO">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.6.2</span>Ubuntu desktop ISO</div>
			</a>
			
			<ul id="toc-Ubuntu_desktop_ISO-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Загрузка_образов_с_отдельного_раздела_встроенного_диска" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2_%D1%81_%D0%BE%D1%82%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B0_%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.6.3</span>Загрузка образов с отдельного раздела встроенного диска</div>
			</a>
			
			<ul id="toc-Загрузка_образов_с_отдельного_раздела_встроенного_диска-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Управление_ходом_загрузки" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%85%D0%BE%D0%B4%D0%BE%D0%BC_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.9</span>Управление ходом загрузки</div>
			</a>
			
			<ul id="toc-Управление_ходом_загрузки-sublist" class="vector-toc-list">
				<li id="toc-Переход_в_интерфейс_настроек_UEFI" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4_%D0%B2_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BA_UEFI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.9.1</span>Переход в интерфейс настроек UEFI</div>
			</a>
			
			<ul id="toc-Переход_в_интерфейс_настроек_UEFI-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Защита_загрузчика_паролем" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0_%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D0%B5%D0%BC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.10</span>Защита загрузчика паролем</div>
			</a>
			
			<ul id="toc-Защита_загрузчика_паролем-sublist" class="vector-toc-list">
				<li id="toc-О_защите_загрузчика" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9E_%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B5_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.10.1</span>О защите загрузчика</div>
			</a>
			
			<ul id="toc-О_защите_загрузчика-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Реализация_паролей_в_GRUB2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D0%B5%D0%B9_%D0%B2_GRUB2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.10.2</span>Реализация паролей в GRUB2</div>
			</a>
			
			<ul id="toc-Реализация_паролей_в_GRUB2-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Внедрение_паролей_в_генерируемый_конфиг" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D0%B5%D0%B9_%D0%B2_%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.10.3</span>Внедрение паролей в генерируемый конфиг</div>
			</a>
			
			<ul id="toc-Внедрение_паролей_в_генерируемый_конфиг-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Пример_конфига_с_паролями" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B0_%D1%81_%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8F%D0%BC%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.10.4</span>Пример конфига с паролями</div>
			</a>
			
			<ul id="toc-Пример_конфига_с_паролями-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Визуальная_настройка" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%92%D0%B8%D0%B7%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11</span>Визуальная настройка</div>
			</a>
			
			<ul id="toc-Визуальная_настройка-sublist" class="vector-toc-list">
				<li id="toc-Цвета_меню" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A6%D0%B2%D0%B5%D1%82%D0%B0_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.1</span>Цвета меню</div>
			</a>
			
			<ul id="toc-Цвета_меню-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Скрытое_меню" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%A1%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B5_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.2</span>Скрытое меню</div>
			</a>
			
			<ul id="toc-Скрытое_меню-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Настройка_параметров_режима_экрана" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B0_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.3</span>Настройка параметров режима экрана</div>
			</a>
			
			<ul id="toc-Настройка_параметров_режима_экрана-sublist" class="vector-toc-list">
				<li id="toc-Проверка_доступных_режимов_экрана" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%8B%D1%85_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%BE%D0%B2_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.3.1</span>Проверка доступных режимов экрана</div>
			</a>
			
			<ul id="toc-Проверка_доступных_режимов_экрана-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Текстовый_режим" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.3.2</span>Текстовый режим</div>
			</a>
			
			<ul id="toc-Текстовый_режим-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Графические_режимы" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%93%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D1%8B">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.3.3</span>Графические режимы</div>
			</a>
			
			<ul id="toc-Графические_режимы-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Графический_режим,_шрифт_и_обои" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%93%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC,_%D1%88%D1%80%D0%B8%D1%84%D1%82_%D0%B8_%D0%BE%D0%B1%D0%BE%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.4</span>Графический режим, шрифт и обои</div>
			</a>
			
			<ul id="toc-Графический_режим,_шрифт_и_обои-sublist" class="vector-toc-list">
				<li id="toc-Установка_шрифта_на_примере_Terminus" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D1%88%D1%80%D0%B8%D1%84%D1%82%D0%B0_%D0%BD%D0%B0_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5_Terminus">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.4.1</span>Установка шрифта на примере Terminus</div>
			</a>
			
			<ul id="toc-Установка_шрифта_на_примере_Terminus-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Проверка_загрузки_шрифтов" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8_%D1%88%D1%80%D0%B8%D1%84%D1%82%D0%BE%D0%B2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.4.2</span>Проверка загрузки шрифтов</div>
			</a>
			
			<ul id="toc-Проверка_загрузки_шрифтов-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Графическая_тема_оформления" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%93%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B5%D0%BC%D0%B0_%D0%BE%D1%84%D0%BE%D1%80%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.11.5</span>Графическая тема оформления</div>
			</a>
			
			<ul id="toc-Графическая_тема_оформления-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Автоматизация_в_меню" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%B2_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.12</span>Автоматизация в меню</div>
			</a>
			
			<ul id="toc-Автоматизация_в_меню-sublist" class="vector-toc-list">
				<li id="toc-Запоминание_выбранного_пункта_меню" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%83%D0%BD%D0%BA%D1%82%D0%B0_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.12.1</span>Запоминание выбранного пункта меню</div>
			</a>
			
			<ul id="toc-Запоминание_выбранного_пункта_меню-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Однократная_загрузка_заданного_без_смены_дефолта" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9E%D0%B4%D0%BD%D0%BE%D0%BA%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B1%D0%B5%D0%B7_%D1%81%D0%BC%D0%B5%D0%BD%D1%8B_%D0%B4%D0%B5%D1%84%D0%BE%D0%BB%D1%82%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.12.2</span>Однократная загрузка заданного без смены дефолта</div>
			</a>
			
			<ul id="toc-Однократная_загрузка_заданного_без_смены_дефолта-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Пример_конфига_GRUB_с_реализацией_запоминания" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B0_GRUB_%D1%81_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D0%B8%D1%8F">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.12.3</span>Пример конфига GRUB с реализацией запоминания</div>
			</a>
			
			<ul id="toc-Пример_конфига_GRUB_с_реализацией_запоминания-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Динамическое_меню" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.13</span>Динамическое меню</div>
			</a>
			
			<ul id="toc-Динамическое_меню-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Консоль_GRUB2" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">6</span>Консоль GRUB2</div>
		</a>
		
			<button aria-controls="toc-Консоль_GRUB2-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Консоль GRUB2 subsection</span>
			</button>
		
		<ul id="toc-Консоль_GRUB2-sublist" class="vector-toc-list">
			<li id="toc-Нормальная_консоль" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1</span>Нормальная консоль</div>
			</a>
			
			<ul id="toc-Нормальная_консоль-sublist" class="vector-toc-list">
				<li id="toc-Запуск_консоли" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1.1</span>Запуск консоли</div>
			</a>
			
			<ul id="toc-Запуск_консоли-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Команды,_полезные_в_консоли_GRUB2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B,_%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D0%B5_%D0%B2_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8_GRUB2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1.2</span>Команды, полезные в консоли GRUB2</div>
			</a>
			
			<ul id="toc-Команды,_полезные_в_консоли_GRUB2-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Пример_загрузки_Arch_Linux_из_консоли_загрузчика" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8_Arch_Linux_%D0%B8%D0%B7_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1.3</span>Пример загрузки Arch Linux из консоли загрузчика</div>
			</a>
			
			<ul id="toc-Пример_загрузки_Arch_Linux_из_консоли_загрузчика-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Пример_загрузки_с_внешнего_диска_из_консоли" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8_%D1%81_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B5%D0%B3%D0%BE_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0_%D0%B8%D0%B7_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1.4</span>Пример загрузки с внешнего диска из консоли</div>
			</a>
			
			<ul id="toc-Пример_загрузки_с_внешнего_диска_из_консоли-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Пример_конфига_с_загрузкой_без_меню" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B0_%D1%81_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%BE%D0%B9_%D0%B1%D0%B5%D0%B7_%D0%BC%D0%B5%D0%BD%D1%8E">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1.5</span>Пример конфига с загрузкой без меню</div>
			</a>
			
			<ul id="toc-Пример_конфига_с_загрузкой_без_меню-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Аварийная_консоль" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%90%D0%B2%D0%B0%D1%80%D0%B8%D0%B9%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.2</span>Аварийная консоль</div>
			</a>
			
			<ul id="toc-Аварийная_консоль-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Запуск_GRUB2_из_других_загрузчиков" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA_GRUB2_%D0%B8%D0%B7_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D1%85_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%BE%D0%B2">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">7</span>Запуск GRUB2 из других загрузчиков</div>
		</a>
		
			<button aria-controls="toc-Запуск_GRUB2_из_других_загрузчиков-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Запуск GRUB2 из других загрузчиков subsection</span>
			</button>
		
		<ul id="toc-Запуск_GRUB2_из_других_загрузчиков-sublist" class="vector-toc-list">
			<li id="toc-Загрузка_из_старых_версий_GRUB" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%B8%D0%B7_%D1%81%D1%82%D0%B0%D1%80%D1%8B%D1%85_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9_GRUB">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.1</span>Загрузка из старых версий GRUB</div>
			</a>
			
			<ul id="toc-Загрузка_из_старых_версий_GRUB-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Загрузка_из_syslinux" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%B8%D0%B7_syslinux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.2</span>Загрузка из syslinux</div>
			</a>
			
			<ul id="toc-Загрузка_из_syslinux-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Примеры_исправления_проблем" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B_%D0%B8%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">8</span>Примеры исправления проблем</div>
		</a>
		
			<button aria-controls="toc-Примеры_исправления_проблем-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Примеры исправления проблем subsection</span>
			</button>
		
		<ul id="toc-Примеры_исправления_проблем-sublist" class="vector-toc-list">
			<li id="toc-Сообщение_о_невозможности_встраивания_в_MBR" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE_%D0%BD%D0%B5%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B2_MBR">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.1</span>Сообщение о невозможности встраивания в MBR</div>
			</a>
			
			<ul id="toc-Сообщение_о_невозможности_встраивания_в_MBR-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Смотрите_также" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#%D0%A1%D0%BC%D0%BE%D1%82%D1%80%D0%B8%D1%82%D0%B5_%D1%82%D0%B0%D0%BA%D0%B6%D0%B5">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">9</span>Смотрите также</div>
		</a>
		
		<ul id="toc-Смотрите_также-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body" role="main" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar">
					<nav role="navigation" aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">GRUB (Русский)</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang">
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 7 languages">
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-7" aria-hidden="true"><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">7 languages</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-de mw-list-item"><a href="https://wiki.archlinux.de/title/GRUB" title="GRUB – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li>
<li class="interlanguage-link interwiki-en mw-list-item"><a href="../en/GRUB.html" title="GRUB – English" lang="en" hreflang="en" class="interlanguage-link-target"><span>English</span></a></li>
<li class="interlanguage-link interwiki-es mw-list-item"><a href="../es/GRUB.html" title="GRUB – español" lang="es" hreflang="es" class="interlanguage-link-target"><span>Español</span></a></li>
<li class="interlanguage-link interwiki-ja mw-list-item"><a href="https://wiki.archlinux.jp/index.php/GRUB" title="GRUB – 日本語" lang="ja" hreflang="ja" class="interlanguage-link-target"><span>日本語</span></a></li>
<li class="interlanguage-link interwiki-pl mw-list-item"><a href="../pl/GRUB.html" title="GRUB – polski" lang="pl" hreflang="pl" class="interlanguage-link-target"><span>Polski</span></a></li>
<li class="interlanguage-link interwiki-pt mw-list-item"><a href="../pt/GRUB.html" title="GRUB – português" lang="pt" hreflang="pt" class="interlanguage-link-target"><span>Português</span></a></li>
<li class="interlanguage-link interwiki-zh-hans mw-list-item"><a href="https://wiki.archlinuxcn.org/wiki/GRUB" title="GRUB – 中文（简体）" lang="zh-Hans" hreflang="zh-Hans" class="interlanguage-link-target"><span>中文（简体）</span></a></li>
			</ul>
			
		</div>

	</div>
</div>
</header>
				<div class="vector-column-end">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-client-prefs-landmark" aria-label="Appearance">
						</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content">
<div class="mw-content-ltr mw-parser-output" lang="ru" dir="ltr">
<div class="archwiki-template-meta-related-articles">
<p>Ссылки по теме</p>
<ul>
<li><a href="../ru/Arch_boot_process.html" class="mw-redirect" title="Процесс загрузки Arch">Процесс загрузки Arch</a></li>
<li><a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="Главная загрузочная запись">Главная загрузочная запись</a></li>
<li><a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="Таблица разделов GUID">Таблица разделов GUID</a></li>
<li><a href="../ru/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (Русский)">Unified Extensible Firmware Interface (Русский)</a></li>
<li><a href="../en/GRUB_Legacy.html" class="mw-redirect" title="GRUB Legacy (Русский)">GRUB Legacy (Русский)</a></li>
<li><a href="../en/GRUB/EFI_examples.html" title="GRUB/EFI examples">GRUB/EFI examples</a></li>
</ul>
</div>
<p><a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/">GRUB</a> (GRand Unified Bootloader) — <a href="https://en.wikipedia.org/wiki/ru:Multiboot_Specification" class="extiw" title="wikipedia:ru:Multiboot Specification">мультисистемный</a> модульный <a href="#%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F">программируемый</a> кроссплатформенный <a href="../ru/Arch_boot_process.html#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA" class="mw-redirect" title="Загрузчик">загрузчик</a> с поддержкой сети, множества файловых систем, таблиц разделов, логических томов, образов и архивов.
</p>
<p>Текущая версия GRUB — <b>GRUB 2</b> — не использует код старой ветки GRUB 0.9x (<a href="../en/GRUB_Legacy.html" class="mw-redirect" title="GRUB Legacy (Русский)">GRUB Legacy</a>) и создана на основе проекта <a rel="nofollow" class="external text" href="https://www.nongnu.org/pupa/">PUPA</a>.
</p>
<meta property="mw:PageProp/toc">
<h2>
<span id=".D0.9F.D1.80.D0.B5.D0.B4.D0.B8.D1.81.D0.BB.D0.BE.D0.B2.D0.B8.D0.B5"></span><span class="mw-headline" id="Предисловие">Предисловие</span>
</h2>
<p>Релиз GRUB-2.00 уже вышел, но разработка продолжается. В репозиториях Arch Linux появляюся самые свежие, в том числе и бета-версии GRUB, поэтому переустанавливать загрузчик (командой grub-install) и особенно обновлять файл конфигурации (командой grub-mkconfig) следует с осторожностью.
</p>
<p>Если вы хотите стабильности - не переустанавливайте без необходимости загрузчик и не запускайте генератор конфига. Пакет <b>grub</b> сам по себе содержит лишь утилиты и файлы, необходимые для установки и настройки загрузчика, и обновления пакета не затрагивают загрузчик. Однако, существует некоторый риск в отношении файла grub.cfg, см. <a href="#%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">Защита конфигурации</a>.
</p>
<p>Если вы не хотите использовать GRUB2, можно установить <a href="../en/GRUB_Legacy.html" class="mw-redirect" title="GRUB Legacy (Русский)">GRUB Legacy</a> из AUR.
</p>
<h3>
<span id=".D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B4.D0.BB.D1.8F_.D1.82.D0.B5.D0.BA.D1.83.D1.89.D0.B8.D1.85_.D0.B8_.D0.B1.D1.8B.D0.B2.D1.88.D0.B8.D1.85_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D0.B5.D0.B9_GRUB_Legacy"></span><span class="mw-headline" id="Замечание_для_текущих_и_бывших_пользователей_GRUB_Legacy">Замечание для текущих и бывших пользователей GRUB Legacy</span>
</h3>
<ul>
<li>Для пользователей, непривычных к шелл-коду, в GRUB2 существует утилита <a href="#%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_(grub-mkconfig)">grub-mkconfig</a> уровня ОС, для автоматического создания файла конфигурации загрузчика с типовым меню.</li>
<li>Однако и без автоматического конфигуратора <a href="#%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F">настройка GRUB2</a> не сложнее, чем GRUB Legacy.</li>
</ul>
<ul><li>Обозначения устройств в GRUB2 отличаются от таковых в GRUB Legacy. Разделы теперь <a href="#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B_%D0%B8_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5">нумеруются с 1</a> (как в Linux), а диски по-прежнему с 0. Например, первый раздел первого диска в GRUB2 обозначается как <code>hd0,1</code>.</li></ul>
<ul><li>Существуют различия между командами GRUB Legacy и GRUB2. Подробнее о командах можно прочесть в этой статье и в <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/">официальном руководстве по GRUB2</a>.</li></ul>
<ul><li>GRUB2 теперь <i>модульный</i>, и не имеет постоянных образов stage1_5 и stage2. Роль stage1_5 в GRUB2 играет образ core.img/core.efi, при каждой <a href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">установке загручика</a> собираемый из ядра GRUB2 и модулей, необходимых для доступа к файловой системе. Остальные модули загружаются из ФС по мере надобности, расширяя функциональность загрузчика.</li></ul>
<h2>
<span id=".D0.A2.D1.80.D0.B5.D0.B1.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D0.BA_.D0.B4.D0.B8.D1.81.D0.BA.D1.83"></span><span class="mw-headline" id="Требования_к_диску">Требования к диску</span>
</h2>
<h3>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA_.D0.B2_BIOS"></span><span class="mw-headline" id="Загрузчик_в_BIOS">Загрузчик в BIOS</span>
</h3>
<p>Сама по себе BIOS, <i>как правило</i>, не требует наличия на диске каких-либо таблиц разделов.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Некоторые реализации BIOS могут проверять содержимое MBR, чтобы определить тип носителя <i>(особенно это относится к USB-дискам и флешкам)</i>. Носитель без MBR, или носитель с очень маленьким первым <i>(по номеру)</i> разделом типа FAT, может быть ошибочно принят некоторыми версиями BIOS за USB-флоппи-дисковод, что может сделать невозможной нормальную загрузку с него.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Некоторые реализации BIOS могут отказаться запускать код загрузчика, если ни один из разделов MBR не отмечен флагом "bootable". Несмотря на это, BIOS может запустить код загрузчика только из бут-сектора диска <i>(сектор MBR)</i>, но не раздела, а после запуска кода GRUB уже не важно, на какой из разделов установлен флаг.</div>
<p>Участие BIOS в процессе загрузки сводится к считыванию с диска его начального сектора размером в 512 байт, проверке наличия в конце сектора сигнатуры <code>55AA</code>, и запуску содержимого как исполняемого кода. Так как в 512 байт невозможно уместить сколь-нибудь сложную программу, единственное, что может сделать код начального сектора – загружать с диска другие сектора, на чтение файлов он не способен.
</p>
<p>Поэтому, для успешной загрузки в режиме BIOS, используемый способ разметки диска должен предусматривать:<br>
1) встраивание кода загрузчика в начальный сектор;<br>
2) выделение на диске специальной, не занятой файловыми системами области (группы секторов), из которой будет загружаться стартовый образ загрузчика, умеющий читать хотя бы одну файловую систему.
</p>
<p>Программа установки GRUB2 умеет встраивать код BIOS-версии загрузчика на диски с таблицами разделов <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a> и <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a>, которые удовлетворяют обоим требованиям.
</p>
<p>В обоих случаях, для встраивания используются два образа:
</p>
<ul>
<li>
<b>boot.img</b>, код которого встраивается в начальный сектор диска,</li>
<li>
<b>core.img</b>, собираемый программой установки из ядра GRUB и модулей доступа к используемой на диске таблице разделов и файловой системе.</li>
</ul>
<h4>
<span id=".D0.A2.D1.80.D0.B5.D0.B1.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_GRUB2-BIOS_.D0.BA_MBR"></span><span class="mw-headline" id="Требования_GRUB2-BIOS_к_MBR">Требования GRUB2-BIOS к MBR</span>
</h4>
<p>Сама по себе таблица разделов на диске с разметкой <a href="https://en.wikipedia.org/wiki/ru:MBR" class="extiw" title="wikipedia:ru:MBR">MBR</a> занимает 68 байт в конце начального сектора диска, последние два байта занимает "загрузочная" сигнатура <code>55AA</code>. Оставшиеся 442 байта с начала сектора – и есть то место, в которое встраивается код загрузчика из образа <code>boot.img</code>.
</p>
<p>Для встраивания образа загрузчика <code>core.img</code> на диск с MBR, используется промежуток между начальным сектором с MBR и самым первым  <i>(по расположению)</i> разделом. Если ближайший к началу диска раздел начинается с сектора 63 или больше,
</p>
<pre># fdisk -l /dev/sda
...
Device    Boot     Start       End    Blocks  Id System
/dev/sda1             63   2120579   1060258+ 82 Linux swap / Solaris
...
</pre>
<p>то в большинстве случаев этого места (31КБ) вполне достаточно для встраивания GRUB2. Размер образа <code>core.img</code> зависит от размера модулей для чтения используемых таблицы разделов и ФС. В частности, для комбинации MBR+ext4 он составляет всего 25КБ.
</p>
<p>Однако, в некоторых более сложных случаях, размер образа может оказаться больше 31КБ, и тогда отступа в 63 сектора уже не хватит. Поэтому современные версии fdisk по-умолчанию предлагают создавать первый раздел с гораздо большим отступом (1МБ), начиная с 2048 сектора.
</p>
<h4>
<span id=".D0.A2.D1.80.D0.B5.D0.B1.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_GRUB2-BIOS_.D0.BA_GPT"></span><span class="mw-headline" id="Требования_GRUB2-BIOS_к_GPT">Требования GRUB2-BIOS к GPT</span>
</h4>
<p>Начальный сектор диска с разметкой <a href="https://en.wikipedia.org/wiki/ru:%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="extiw" title="wikipedia:ru:Таблица разделов GUID">GPT</a> зарезервирован, как ни странно, для MBR, которая обычно используется для совместимости, но точно так же оставляет в секторе те же 442 байта, достаточные для встраивания кода загрузчика из <code>boot.img</code>. Сама GPT располагается на следующих секторах.
</p>
<p>В отличии от MBR, GPT предусматривает возможность создания на диске специального раздела для встраивания BIOS-загрузчика. Раздел <a href="https://en.wikipedia.org/wiki/BIOS_Boot_partition" class="extiw" title="wikipedia:BIOS Boot partition">BIOS boot partition</a> имеет <code>GUID=21686148-6449-6e6f-744e656564454649</code>, и может быть создан в <b>fdisk</b> как раздел типа <b>4</b>, или в <a rel="nofollow" class="external text" href="https://archlinux.org/packages/?q=gptfdisk">gdisk</a> как раздел типа <b>EF02</b>. Этот раздел <b>не должен содержать никакой файловой системы</b>, иначе она будет затёрта при установке загрузчика. Номер раздела может быть любым, расположение также практически любым. На больших дисках рекомендуется располагать BIOS boot partition в пределах первых 2ТБ, поскольку средства BIOS, скорей всего, не позволят прочесть более дальние сектора.
</p>
<p>Если такой раздел на диске с GPT создан, программа установки GRUB2 автоматически найдёт его и использует для встраивания стартового образа BIOS-версии загрузчика. Минимальные требования к размеру раздела те же, что и для просвета перед первым разделом в случае MBR – на это место должен поместиться образ <code>core.img</code>. Так как расположение BIOS boot partition <b>не привязано к началу диска</b>, создать его с размером порядка 1МБ будет несложно, и более чем достаточно в любом случае.
</p>
<h3>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA_.D0.B2_UEFI"></span><span class="mw-headline" id="Загрузчик_в_UEFI">Загрузчик в UEFI</span>
</h3>
<p>В отличии от BIOS, <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> загружает образ загрузчика из файла, и поэтому предъявляет определённые требования к таблице разделов, разделу, файловой системе, и к содержимому загружаемого файла.
</p>
<dl>
<dt>Таблица разделов</dt>
<dd>Большинство реализаций UEFI поддерживает таблицы разделов <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a> и <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a>. Некоторые, однако, могут <b>не</b> поддерживать MBR, а некоторые могут поддерживать другие таблицы разделов, специфичные для производителя.</dd>
</dl>
<dl>
<dt>Загрузочный раздел</dt>
<dd>Загрузочный раздел UEFI называется "<a href="../ru/EFI_system_partition.html" title="EFI system partition (Русский)">EFI system partition</a>", он же ESP, он же EFISYS. На каждом диске может быть не более одного такого раздела.
<ul>
<li>В GPT он должен иметь тип <b>EF00</b> (<code>GUID=C12A7328-F81F-11D2-BA4B-00A0C93EC93B</code>), и может располагаться в любом месте диска под любым номером.</li>
<li>К загрузочному разделу в MBR требования более жесткие: он должен одновременно иметь тип <b>EF</b>, флаг "<b>bootable</b>", и быть <b>первым</b>.</li>
</ul>
</dd>
</dl>
<dl>
<dt>Файловая система</dt>
<dd>Большинство реализаций UEFI работают с загрузочным разделом с файловой системой FAT любой разрядности – FAT12, FAT16 и FAT32. Некоторые реализации могут требовать только FAT32, некоторые могут поддерживать другие ФС, специфичные для производителя.</dd>
</dl>
<dl>
<dt>Загрузочный образ</dt>
<dd>Загружаемый файл должен быть оформлен как EFI-приложение, а значит иметь унаследованный от DOS и Windows бинарный формат MZ/PE (Portable Executable) и <b>соответствовать архитектуре UEFI</b>. Все реализации UEFI для платформы PC имеют архитектуру <b>x86_64</b>, а значит и сборка загрузчика обязательно должна быть <b>под эту архитектуру</b>. Сборка загрузчика под i386 может быть полезна только на некоторых специфических машинах, в основном это старые компьютеры фирмы Apple, а также некоторые миниатюрные устройства на мобильных SoC производства Intel.</dd>
</dl>
<dl>
<dt>Имя файла по-умолчанию</dt>
<dd>UEFI архитектуры x86_64 автоматически находит на загрузочном разделе и запускает файл <code>\EFI\BOOT\BOOTX64.EFI</code>, который может быть стартовым образом загрузчика.</dd>
</dl>
<dl>
<dt>Загрузочные записи</dt>
<dd>На загрузочный раздел можно записать больше одного EFI-приложения, каждое под своим именем и в свой каталог. Чтобы можно было запускать их при старте, UEFI обычно предоставляет через специальный программный интерфейс доступ к загрузочным записям – особым переменным (<a href="../ru/Unified_Extensible_Firmware_Interface.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_UEFI" title="Unified Extensible Firmware Interface (Русский)">UEFI Variables</a>), хрянящимся в энергонезависимой памяти материнской платы (NVRAM). Каждая загрузочная запись содержит:
<ul>
<li>видимый в пользовательском интерфейсе UEFI заголовок,</li>
<li>тип таблицы разделов,</li>
<li>ID таблицы разделов,</li>
<li>расположение и размер загрузочного раздела,</li>
<li>путь к исполняемому файлу EFI-приложения.</li>
</ul>
</dd>
<dd>Кроме самих загрузочных записей, в NVRAM задаётся порядок их проверки при загрузке, который может быть изменён пользователем.</dd>
<dd>Программа установки GRUB2 будет пытаться создать загрузочную запись с помощью пакета <b>efibootmgr</b>, сохранив в ней параметры для запуска созданного ей образа загрузчика.</dd>
</dl>
<h2>
<span id=".D0.A0.D0.B5.D0.BA.D0.BE.D0.BC.D0.B5.D0.BD.D0.B4.D0.B0.D1.86.D0.B8.D0.B8_.D0.BF.D0.BE_.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B5_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Рекомендации_по_установке_загрузчика">Рекомендации по установке загрузчика</span>
</h2>
<h3>
<span id=".D0.92.D1.8B.D0.B1.D0.BE.D1.80_.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B0"></span><span class="mw-headline" id="Выбор_раздела">Выбор раздела</span>
</h3>
<p>Проще всего установить GRUB2 в корневой раздел. По-умолчанию для этого используется каталог с загрузочными образами ядра <code>/boot</code>, но можно установить каталог <code>grub/</code> в корень <code>/</code>, или в другое место в пределах раздела. GRUB2 обладает средствами для чтения нескольких типов таблиц разделов, логических томов, образов дисков, множества файловых систем и архивов. В большинстве случаев он может читать свои файлы и загружать ОС практически с любого раздела и диска.
</p>
<ul>
<li>Только в тех случаях, когда Arch Linux установлен на диск, недоступный для чтения средствами BIOS или <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a>, которыми пользуется загрузчик, либо если для корневого раздела использована слишком новая, экзотическая, или зашифрованная файловая система, не читаемая GRUB2, может потребоваться вынос каталога <code>/boot</code> на отдельный диск либо раздел, и установка загрузчика на него.</li>
<li>Если загрузчик в состоянии прочесть корневой раздел, создание отдельного раздела для <code>/boot</code> не нужно и <b>не рекомендуется</b>.</li>
</ul>
<p>Если на компьютере установлено несколько операционных систем или диструбутивов, может оказаться удобным сделать один системонезависимый загрузчик, и установить его на отдельный диск или раздел. В этом случае стоит учесть следующее:
</p>
<ul>
<li>Не требуется монтировать этот раздел в <code>/boot</code> или переносить в него образы ядра – GRUB2 и так может загрузить их практически из любого раздела.</li>
<li>Не следует переустанавливать загрузчик без особой необходимости – от него зависит загрузка всех ОС на машине.</li>
<li>Не рекомендуется использовать для общесистемного загрузчика генератор конфигурации – даже если забыть о его "сырости" и ненадёжности, скорей всего, конфигуратор будет работать только в одной системе, а в остальных всё равно придётся редактировать конфиг загрузчика. Вносить правки гораздо легче в простой и понятный конфиг, чем в громоздкий продукт деятельности конфгуратора.</li>
</ul>
<h3>
<span id=".D0.92.D1.8B.D0.B1.D0.BE.D1.80_.D1.82.D0.B0.D0.B1.D0.BB.D0.B8.D1.86.D1.8B_.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.BE.D0.B2"></span><span class="mw-headline" id="Выбор_таблицы_разделов">Выбор таблицы разделов</span>
</h3>
<ul><li>Если на диске уже есть таблица разделов, и её возможностей для ваших целей достаточно, то нет никакого смысла её менять.</li></ul>
<ul><li>Если вы устанавливаете систему на чистый диск, и выбираете таблицу разделов, то с точки зрения установки GRUB2 предпочтительнее GPT, которая позволяет выделить для встраивания загрузчика раздел в любом месте диска. Это общая рекомендация, она действительна как для BIOS, так и для UEFI.</li></ul>
<ul><li>Если на этот диск планируется установка ОС, не поддерживающих GPT, но поддерживающих MBR, вам придётся выбрать MBR, или в крайнем случае, гибридную разметку диска MBR+GPT.</li></ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> Ни одна из версий Windows в режиме BIOS <b>не поддерживает</b> загрузку с GPT.<br>Версии Windows, поддерживающие UEFI, имеют по два варианта загрузки (и загрузчиков): только с MBR в режиме BIOS, и только с GPT в режиме UEFI. См. <a href="#Windows">Windows</a>.</div>
<ul><li>Если на диске уже имеется MBR, но в ней недостаточно места перед первым разделом для встраивания GRUB2, и освобождение этого места проблематично, одним из выходов может стать преобразование MBR в GPT, например, с помощью программы <b>gdisk</b>. После этого на диске можно в любом доступном месте создать <a href="#%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_GRUB2-BIOS_%D0%BA_GPT">BIOS boot partition</a>, и использовать её для встраивания загрузчика.</li></ul>
<ul><li>Если UEFI вашей машины поддерживает загрузку только с GPT, выбор очевиден.</li></ul>
<ul><li>Если вы устанавливаете Arch Linux на переносной носитель (флешку или USB-диск), то для универсальности вы можете использовать на ней GPT, и установить в неё сразу две сборки GRUB2 – i386-pc и x86_64-efi. В этом случае на носителе понадобится создать два загрузочных раздела – <b>EFISYS</b> для UEFI, и <b>BIOS boot partition</b> для BIOS. Файлы со сборками для каждой из архитектур установятся в отдельные каталоги внутри <code>grub/</code>, и не помешают друг другу. Файл конфигурации тоже можно использовать общий, но тогда для некоторых специфических настроек и действий понадобятся дополнительные проверки, описанные ниже.</li></ul>
<ul><li>Если требуется сохранить возможность использования переносного носителя в Windows, включая XP, после создания на нём GPT и установки UEFI-загрузчика, можно использовать для этого гибридную разметку GPT+MBR, с описанием в последней только FAT-раздела с данными, и обязательно под номером 1. Остальное место на носителе в MBR должно быть покрыто "защитными" разделами с кодом 0xEE. Сделать всё это можно программой <b>gdisk</b>. GRUB2 в этом случае будет устанавливаться всегда только на GPT.</li></ul>
<h2>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0"></span><span class="mw-headline" id="Установка">Установка</span>
</h2>
<h3>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_GRUB2_.D0.B2_.D0.BF.D1.80.D0.BE.D1.86.D0.B5.D1.81.D1.81.D0.B5_.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B8_Arch_Linux"></span><span class="mw-headline" id="Установка_GRUB2_в_процессе_установки_Arch_Linux">Установка GRUB2 в процессе установки Arch Linux</span>
</h3>
<p>Чтобы установить GRUB2 в процессе установки, предварительно требуется смонтировать корневой раздел устанавливаемого Arch, <i>(а в него boot-раздел, если требуется)</i>, и выполнить команду <a href="../ru/Chroot.html" class="mw-redirect" title="Change root (Русский)">arch-chroot</a>.
</p>
<h3>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.BF.D0.B0.D0.BA.D0.B5.D1.82.D0.B0"></span><span class="mw-headline" id="Установка_пакета">Установка пакета</span>
</h3>
<p>Файлы и утилиты для установки GRUB2 содержатся в пакете <b>grub</b>, и устанавливаются командой
</p>
<pre>pacman -S grub
</pre>
<h3>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Установка_загрузчика">Установка загрузчика</span>
</h3>
<h4>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_BIOS-.D0.B2.D0.B5.D1.80.D1.81.D0.B8.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Установка_BIOS-версии_загрузчика">Установка BIOS-версии загрузчика</span>
</h4>
<h5>
<span id=".D0.9F.D0.BE.D0.BB.D0.BD.D0.BE.D1.86.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.B4.D0.BB.D1.8F_BIOS"></span><span class="mw-headline" id="Полноценная_установка_для_BIOS">Полноценная установка для BIOS</span>
</h5>
<ul><li>Для установки GRUB2 нужно выполнить команду от root:</li></ul>
<pre>grub-install /dev/sda
</pre>
<p>где <code>/dev/sda</code> это устройство <i>(не раздел!)</i> для установки загрузочных образов GRUB. Файлы загрузчика будут установлены в каталог <code>/boot</code>. Код GRUB (<code>boot.img</code>) будет встроен в начальный сектор, а загрузочный образ <code>core.img</code> – в просвет перед первым разделом <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a>, или BIOS boot partition для <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a>.
</p>
<ul><li>Если при выполнении команды происходит ошибка, попробуйте добавить <b>--recheck</b> в аргументы как показано ниже:</li></ul>
<pre>grub-install --recheck /dev/sda
</pre>
<ul><li>Если требуется установить файлы загрузчика в другой каталог, его можно указать в опции <b>--boot-directory</b> . С этой опцией можно легко установить GRUB2 на диск с другой системой <i>(устанавливаемой или исправляемой)</i> <b>без чрута</b>, достаточно правильно указать текущий путь к смонтированному каталогу для установки и текущее имя устройства, примерно так:</li></ul>
<pre>grub-install --boot-directory=/mnt/boot /dev/sdb
</pre>
<ul><li>Если нужно установить BIOS-версию загрузчика из-под системы, загруженной в режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a>, требуется принудительно задать программе установки нужную сборку GRUB:</li></ul>
<pre>grub-install --target=i386-pc /dev/sda
</pre>
<h5>
<span id=".D0.93.D0.B5.D0.BD.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D1.8F_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BE.D1.87.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.B0_.D0.B4.D0.BB.D1.8F_BIOS_.D0.B1.D0.B5.D0.B7_.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B8"></span><span class="mw-headline" id="Генерация_загрузочного_образа_для_BIOS_без_установки">Генерация загрузочного образа для BIOS без установки</span>
</h5>
<p>Новые версии GRUB2 генерируют загрузочный образ <code>core.img</code>, который может быть загружен не только кодом бут-сектора, но и <a href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA_GRUB2_%D0%B8%D0%B7_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D1%85_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%BE%D0%B2">другими загрузчиками</a> <i>(GRUB2, GRUB Legacy, <a href="../ru/Syslinux.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D1%83_(chainloading)" title="Syslinux (Русский)">syslinux</a>)</i>, в качестве ядра, совместимого со стандартом Multiboot. Например, другой экземпляр GRUB2 может запустить его командой <code>multiboot</code>, а GRUB Legacy командой <code>kernel</code>.
</p>
<p>Чтобы заставить программу установки GRUB2 сгенерировать готовый образ <code>grub/i386-pc/core.img</code>, но не устанавливать его в таблицу разделов, можно применить вот такой хак:
</p>
<pre>grub-install --grub-setup=/bin/true /dev/sda
</pre>
<p>Обычно программа установки вызывает сначала <code>grub-mkimage</code> (передавая ему множество параметров, что неудобно делать вручную), чтобы сгенерировать образ, а потом запускает <code>grub-bios-setup</code>, чтобы установить boot.img и core.img в таблицу разделов. С помощью ключа <b>--grub-setup</b> можно подсунуть программе установки вместо grub-bios-setup заглушку (команду <b>true</b>), которая всегда возвращает код успешного завершения.
</p>
<h4>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_UEFI-.D0.B2.D0.B5.D1.80.D1.81.D0.B8.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Установка_UEFI-версии_загрузчика">Установка UEFI-версии загрузчика</span>
</h4>
<h5>
<span id=".D0.92_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D0.B5_UEFI"></span><span class="mw-headline" id="В_режиме_UEFI">В режиме UEFI</span>
</h5>
<p>Если Arch x86_64 уже загружен в режиме UEFI, <a href="../ru/EFI_system_partition.html" title="EFI system partition (Русский)">системный загрузочный раздел EFI</a> уже создан и смонтирован в <code>/boot/efi</code>, а <a href="../ru/Unified_Extensible_Firmware_Interface.html#efibootmgr" class="mw-redirect" title="UEFI (Русский)">efibootmgr</a> уже установлен и работает, для установки загрузчика остаётся выполнить команду
</p>
<pre>grub-install
</pre>
<p>Программа установки сгенерирует стартовый образ GRUB2, оформленный в виде EFI-приложения, скопирует его в файл <code>/boot/efi/EFI/arch/grubx64.efi</code>, файлы загрузчика будут записаны в каталог <code>/boot/grub/</code>, в том числе модули в <code>/boot/grub/x86_64-efi/</code>, после чего будет сделана попытка с помощью <code>efibootmgr</code> создать в переменных UEFI загрузочную запись "arch" со ссылкой на файл <code>\EFI\arch\grubx64.efi</code>, которую можно будет выбрать при следующей загрузке и установить её по-умолчанию.
</p>
<ul><li>Опция <b>--boot-directory</b> задаёт путь, по которому будет установлен каталог <code>grub/</code>, и где <code>grub-install</code> будет искать каталог <code>efi/</code> с загрузочным разделом EFI. По-умолчанию этот путь равен <code>/boot</code>. Если вы хотите установить каталог с файлами загрузчика в другое место, например в корень, используйте команду вида</li></ul>
<pre>grub-install --boot-directory=/
</pre>
<dl><dd>В этом случае файлы загрузчика установятся в каталог <code>/grub</code>, а загрузочный раздел раздел должен быть предварительно смонтирован в <code>/efi</code>.</dd></dl>
<ul><li>Опция <b>--efi-directory</b> принудительно задаёт каталог, в который смонтирован загрузочный раздел EFI. С её помощью можно указать точку монтирования этого раздела, не привязанную жестко к расположению каталога <code>grub/</code>.</li></ul>
<ul><li>Опция <b>--bootloader-id</b> задаёт "ID загрузчика" – имя, под которым будет создаваться загрузочная запись GRUB, видимая при выборе варианта загрузки в интерфейсе UEFI. Под этим же именем в загрузочном разделе будет создан каталог с образом GRUB2. По-умолчанию это имя <b>arch</b> .</li></ul>
<p>Используя эти опции вместе, при желании можно <b>установить файлы загрузчика непосредственно в загрузочный раздел EFI</b>, например так:
</p>
<pre>grub-install --efi-directory=/boot/efi --boot-directory=/boot/efi/EFI --bootloader-id=grub
</pre>
<p>В этом примере загрузочный раздел EFI с каталогом <code>EFI/</code> заранее смонтирован в <code>/boot/efi</code>, а ID загрузчика полностью совпадает с именем каталога "grub". Поэтому и образ, и файлы загрузчика будут установлены в один и тот же каталог <code>EFI/grub/</code> на загрузочном разделе. Соответственно, в этом случае стартовый образ будет установлен в <code>/boot/efi/EFI/grub/grubx64.efi</code>, конфиг загрузчика должен быть в <code>/boot/efi/EFI/grub/grub.cfg</code>, а модули в каталоге <code>/boot/efi/EFI/grub/x86_64-efi/</code>.
</p>
<h5>
<span id=".D0.91.D0.B5.D0.B7_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.B0_.D0.BA_UEFI"></span><span class="mw-headline" id="Без_доступа_к_UEFI">Без доступа к UEFI</span>
</h5>
<ul>
<li>Если нужно установить EFI-версию GRUB2, действуя из системы, загруженной в режиме BIOS, либо в режиме UEFI для другой архитектуры, либо на сменный носитель <i>(флешку или переносной диск)</i>, требуется принудительно задать программе установки нужную сборку загрузчика с помощью опции <b>--target</b> .</li>
<li>Кроме того, в этом случае не будет работать <code>efibootmgr</code>, и создать загрузочную запись со ссылкой на стартовый образ загрузчика из этой системы не удастся. В такой ситуации можно использовать дефолтный загрузочный путь <code>\EFI\BOOT\BOOTX64.EFI</code>, по которому UEFI самостоятельно найдёт стартовый образ, с помощью опции <b>--removable</b> :</li>
</ul>
<pre>grub-install --target=x86_64-efi --removable
</pre>
<dl><dd>Опции <b>--boot-directory</b> и <b>--efi-directory</b> можно добавлять при надобности, как описано выше, их действие не изменится.</dd></dl>
<ul><li>Аналогично можно установить GRUB2 на флешку для загрузки в режиме UEFI:</li></ul>
<pre>grub-install --boot-directory=/mnt/sdb2/boot --efi-directory=/mnt/sdb1 --target=x86_64-efi --removable
</pre>
<dl><dd>В случае переносного носителя создание загрузочной записи в UEFI бессмысленно, поскольку загрузка будет происходить на другой машине, и использование дефолтного пути к загрузочному образу остаётся единственным вариантом.</dd></dl>
<ul><li>Если вы не хотите или не можете использовать для GRUB дефолтный путь на загрузочном разделе, можно использовать опцию <b>--no-nvram</b> , чтобы программа установки поместила загрузочный образ в отдельный <i>(не дефолтный)</i> каталог, но не пыталась вызывать efibootmgr:</li></ul>
<pre>grub-install --target=x86_64-efi --no-nvram
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> В этом случае вам придётся самостоятельно создать в переменных UEFI загрузочную запись с актуальным путём к загрузочному образу GRUB, с помощью <a href="../ru/Unified_Extensible_Firmware_Interface.html#UEFI_Shell" class="mw-redirect" title="UEFI (Русский)">UEFI Shell</a> или иных средств, либо запускать этот образ из другого загрузчика.</div>
<h5>
<span id=".D0.98.D0.B7_32-.D0.B1.D0.B8.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_Arch"></span><span class="mw-headline" id="Из_32-битного_Arch">Из 32-битного Arch</span>
</h5>
<p>Если на машине есть UEFI, но установленный Arch Linux имеет архитектуру i686, установить UEFI-версию GRUB можно, но есть дополнительное затруднение – сборка загрузчика <b>x86_64-efi</b> отсутствует в пакете "grub" для архитектуры i686. В пакете же для архитектуры x86_64 присутствуют все три сборки:
</p>
<ul>
<li>
<b>i386-pc</b> для BIOS,</li>
<li>
<b>i386-efi</b> для 32-битных прошивок UEFI <i>(встречается редко, в основном это старые машины фирмы Apple, некоторые HDMI-стики)</i>,</li>
<li>
<b>x86_64-efi</b> для 64-битных UEFI.</li>
</ul>
<p>Перед тем, как устанавливать  UEFI-версию GRUB из системы i686, придётся сначала <a rel="nofollow" class="external text" href="https://archlinux.org/packages/core/x86_64/grub/download/">скачать пакет grub для x86_64</a>, и распаковать из него <i>(под рутом)</i> недостающую сборку загрузчика:
</p>
<pre>tar xvf /путь/grub-версия-x86_64.pkg.tar.xz -C / usr/lib/grub/x86_64-efi
</pre>
<p>После этого можно устанавливать загрузчик, как описано в предыдущей главе "<a href="#%D0%91%D0%B5%D0%B7_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0_%D0%BA_UEFI">Без доступа к UEFI</a>".
</p>
<h4>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.B2_LVM"></span><span class="mw-headline" id="Установка_в_LVM">Установка в LVM</span>
</h4>
<p>Установка GRUB2 на диск с <a href="../en/LVM.html" class="mw-redirect" title="LVM (Русский)">LVM</a> происходит в целом так же, как и на диск без LVM.
</p>
<p>GRUB2 читает файловые системы из логических томов LVM, как и из обычных разделов, поэтому никакого отдельного раздела /boot <b>вне LVM</b> для файлов GRUB2 и загружаемых им образов ядра не требуется. Однако, для встраивания стартовых образов GRUB2 по-прежнему нужна таблица разделов.
</p>
<p>Для загрузки в режиме BIOS, в <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a> никаких дополнительных разделов создавать не нужно, достаточно единственного раздела на весь диск, полностью отданного под LVM, и оставленного свободного места перед разделом для встраивания загрузчика.
</p>
<p>Для загрузки в режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a>, или загрузки с <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a> в любом режиме, требуется как минимум один загрузочный раздел вне LVM для стартового образа GRUB2, но не для файлов загрузчика, и не для образов ядра <i>(не /boot )</i>.
</p>
<p>Подробнее см. <a href="#%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA_%D0%B4%D0%B8%D1%81%D0%BA%D1%83">Требования к диску</a>.
</p>
<h4>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.BD.D0.B0_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7_.D0.B4.D0.B8.D1.81.D0.BA.D0.B0"></span><span class="mw-headline" id="Установка_на_образ_диска">Установка на образ диска</span>
</h4>
<p>В некоторых случаях может понадобиться установить GRUB2 на образ диска, например, для загрузки в виртуальной машине.
К сожалению, в нынешних версиях <i>(на конец 2015г)</i> программа установки загрузчика <b>grub-install</b> по-умолчанию считает loop-устройство, через которое подключается образ, не имеющим разделов, а потому не ищет на нём таблицу разделов, и не включает в начальную загрузку модуль чтения таблицы разделов.
</p>
<p>Возможно, в будущем это будет исправлено, а пока для обхода проблемы требуется явно потребовать добавить соответствующий модуль: опцией <code>--modules=part_msdos</code> для MBR, или <code>--modules=part_gpt</code> для GPT.
</p>
<p>Пример установки GRUB2 на образ диска с MBR, и размещением файлов загрузчика в каталоге <code>/grub</code> на первом разделе:
</p>
<pre>[root@host ~]# losetup --show -P -f /home/user/VM/disk.img
/dev/loop0
[root@host ~]# ls -1 /dev/loop0*
/dev/loop0
/dev/loop0p1
/dev/loop0p2
[root@host ~]# mkdir -p /mnt/part1
[root@host ~]# mount /dev/loop0p1 /mnt/part1
[root@host ~]# grub-install --modules=part_msdos --boot-directory=/mnt/part1 /dev/loop0
</pre>
<h3>
<span id=".D0.9F.D0.B5.D1.80.D0.B5.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Переустановка_загрузчика">Переустановка загрузчика</span>
</h3>
<p>Переустановка пакета <b>не</b> переустанавливает загрузчик.
</p>
<p>Переустановка GRUB2 выполняется командой <b>grub-install</b>, и ничем не отличается от установки.
</p>
<p>Переустановка GRUB2 может потребоваться в следующих случаях:
</p>
<ul>
<li>Если установка другой ОС или другого дистрибутива затёрла стартовый код GRUB2.</li>
<li>После преобразования таблицы разделов.</li>
<li>После изменения нумерации раздела, на котором установлены файлы загрузчика.</li>
<li>После переноса загрузчика на другой раздел или в другую файловую систему.</li>
<li>Если вас не устраивает текущая версия загрузчика, и вы хотите её обновить.</li>
</ul>
<p>Переустановка GRUB2 <b>не</b> требуется:
</p>
<ul>
<li>При изменении файла конфигурации загрузчика.</li>
<li>При обновлении ядра, установке другого ядра, или пересборке initramfs.</li>
<li>При смене архитектуры установленного Arch с i686 на x86_64 без смены раздела и без форматирования корневой ФС.</li>
<li>При обновлении пакета "grub".</li>
</ul>
<h3>
<span id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BD.D0.BE.D1.81_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Перенос_загрузчика">Перенос загрузчика</span>
</h3>
<p>Загрузчик GRUB состоит из двух частей: <i>(внефайлового)</i> загрузочного кода в таблице разделов и файлов в каталоге /grub <i>(/boot/grub)</i>.
</p>
<p>Вне зависимости от того, какие из этих частей переносятся, при переносе обязательно нужно <a href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">переустановить загрузчик</a> с помощью <b>grub-install</b> .
</p>
<p>Если загрузчик переносится на другой диск, также может потребоваться изменение настроек BIOS/UEFI, чтобы загрузка начиналась с этого диска.
</p>
<p>Загрузчик GRUB <b>не читает</b> fstab и <b>игнорирует</b> флаг bootable в MBR, поэтому любые манипуляции с ними не имеют никакого отношения к установке, переустановке или переносу GRUB.
</p>
<h3>
<span id=".D0.9F.D0.BE.D1.81.D0.BB.D0.B5_.D1.83.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B8"></span><span class="mw-headline" id="После_установки">После установки</span>
</h3>
<p>В настоящее время GRUB2, сразу после установки, готов к работе <b>только</b> в режиме консоли. <i>(Это будет продолжаться до тех пор, пока мейнтейнеры пакета "grub" не заменят бессмысленный дефолтный файл конфигурации загрузчика на рабочую статическую или автоматически генерируемую версию.)</i>
</p>
<p>Чтобы получить при загрузке действующее меню GRUB2, требуется заменить файл <b>grub.cfg</b> самостоятельно. Речь об этом идёт в следующей части "Настройка".
</p>
<h2>
<span id=".D0.9D.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0"></span><span class="mw-headline" id="Настройка">Настройка</span>
</h2>
<h3>
<span id=".D0.93.D0.BB.D0.B0.D0.B2.D0.BD.D1.8B.D0.B9_.D1.84.D0.B0.D0.B9.D0.BB_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Главный_файл_конфигурации_загрузчика">Главный файл конфигурации загрузчика</span>
</h3>
<p>Главный файл конфигурации по-умолчанию находится в <code>/boot/grub/grub.cfg</code>.
</p>
<ul>
<li>Если вы пользуетесь автоматическим генератором конфигурации <code>grub-mkconfig</code>, <b>не редактируйте главный файл конфигурации вручную</b> – сгенерированный код пригоден для загрузки, но громоздок и неудобен для редактирования, а все изменения будут стёрты при запуске конфигуратора.</li>
<li>Соответственно, если вы собираетесь редактировать конфиг загрузчика сами – создайте его либо полностью заново, либо на основе примеров, и <b>не пытайтесь запустить grub-mkconfig</b> или использовать сгенерированный им код.</li>
</ul>
<h3>
<span id=".D0.90.D0.B2.D1.82.D0.BE.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F_.28grub-mkconfig.29"></span><span class="mw-headline" id="Автоматическая_конфигурация_(grub-mkconfig)">Автоматическая конфигурация (grub-mkconfig)</span>
</h3>
<h4>
<span id=".D0.93.D0.B5.D0.BD.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D1.8F_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D0.B0"></span><span class="mw-headline" id="Генерация_конфига">Генерация конфига</span>
</h4>
<p>Команда <b>grub-mkconfig</b> может быть использована для генерации файла <code>grub.cfg</code>.
</p>
<p>Для автоматического обнаружения ОС отличных от Linux установите пакет <code>os-prober</code>. Если после установки пакета <code>os-prober</code> автоматическое обнаружение не работает должным образом, то может потребоваться установка пакета <code>hwinfo</code>.
</p>
<p>Для отключения автоматического обнаружения других операционных систем следует добавить в файл <code>/etc/default/grub</code> строку <code>GRUB_DISABLE_OS_PROBER="true"</code>.
</p>
<p>Для настройки конфигуратора используйте файл <code>/etc/default/grub</code> и файлы в каталоге <code>/etc/grub.d/</code>.
</p>
<p>Если Вы хотите добавить свои пункты в меню GRUB, настроить их можно в файле <code>/etc/grub.d/40_custom</code>, либо в <code>/boot/grub/custom.cfg</code>.
</p>
<p>Чтобы применить изменения, запустите команду:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<p>Она не только создаст файл <code>/boot/grub/grub.cfg</code>, но и проверит конфигурацию на наличие ошибок.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> Если вы запускаете конфигуратор при установке Arch Linux, убедитесь, что вы делаете это внутри <a href="../ru/Chroot.html" class="mw-redirect" title="Change root (Русский)">arch-chroot</a>, иначе программа будет читать и записывать файлы конфигурации текущей, а <b>не</b> устанавливаемой системы.</div>
<h4>
<span id=".D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D1.8B_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.82.D0.BE.D1.80.D0.B0"></span><span class="mw-headline" id="Параметры_конфигуратора">Параметры конфигуратора</span>
</h4>
<p>Дефолтный файл <code>/etc/default/grub</code> содержит параметры конфигуратора с настройками по-умолчанию, снабженные комментариями на английском языке. Ниже перечислены некоторые наиболее общие из них:
</p>
<ul>
<li>
<code>GRUB_DEFAULT</code> Номер или заголовок пункта меню, выбранного по-умолчанию</li>
<li>
<code>GRUB_TIMEOUT</code> Время, после которого будет автоматически загружаться пункт по-умолчанию</li>
<li>
<code>GRUB_CMDLINE_LINUX</code> Параметры ядра Linux, добавляемые во все пункты меню.</li>
<li>
<code>GRUB_CMDLINE_LINUX_DEFAULT</code> Параметры ядра Linux, добавляемые только в пункты меню, сгенерированные без "recovery". В Arch Linux настройки автоконфигуратора по-умолчанию содержат <code>GRUB_DISABLE_RECOVERY=true</code>, поэтому фактически в каждый пункт меню добавляются параметры из обех упомянутых строк.</li>
</ul>
<p>Другие параметры конфигуратора вы можете найти ниже, в соответсвующих тематических главах.
</p>
<h3>
<span id=".D0.9F.D1.80.D1.8F.D0.BC.D0.B0.D1.8F_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F"></span><span class="mw-headline" id="Прямая_конфигурация">Прямая конфигурация</span>
</h3>
<p>GRUB2 – программируемый загрузчик, и файл его конфигурации – это не файл настроек, а программа, выполняемая загрузчиком, скрипт. Как всякий скрипт, он может быть как очень простым, не сложнее menu.lst в GRUB Legacy, так и очень сложным, поскольку сложность скриптов практически ничем не ограничена.
</p>
<p>Код скрипта конфигурации, генерируемый <code>grub-mkconfig</code>, обычно пригоден для загрузки в типовых случаях, но слишком громоздок, избыточен, непригоден для изучения, ограничен в возможностях, и создаёт ложное впечатление о "сложном конфиге GRUB2".
</p>
<p>Ещё одно распространённое заблуждение происходит от надписи "DO NOT EDIT ..." в начале кода, генерируемого конфигуратором. Надпись правильная, но её смысл состоит лишь в том, что именно <b>этот</b>, автоматически сгенерированный код, действительно нет смысла редактировать. Надпись стандартна для автоматических конфигураторов, и относится не к grub.cfg вообще, а только к продукту деятельности конфигуратора, безотносительно имени файла, в который его сохранили.
</p>
<p>При запуске автоматического конфигуратора, выполняется набор скриптов, работающих на уровне ОС, которые генерируют скрипт конфигурации загрузчика. Уже этот, сгенерированный скрипт, выполняется на уровне загрузчика, и в свою очередь, генерирует меню GRUB. Такая схема предполагает некоторое упрощение типовой настройки GRUB, но ценой загромождения кода, снижения надёжности и гибкости.
</p>
<p>Прямое написание скрипта даёт непосредственный доступ ко всем возможностям GRUB2, значительно большую гибкость, надёжность и стабильность, просто за счёт упрощения кода и устранения лишних звеньев в цепочке.
</p>
<p>Язык конфигурации GRUB2 – сильно упрощённый UNIX-шелл, из которого убраны возможности перенаправления ввода-вывода, и добавлены команды, специфичные для загрузчика.
</p>
<p>Автоматический генератор конфигурации изначально создавался для дистрибутивов Debian и Ubuntu, в которых используются версионные имена образов ядра, что заставило разработчиков этих дистрибутовов создавать автоматические генераторы конфигов вообще для всех используемых там загрузчиков.
</p>
<p>В Arch Linux не используется версионное обновление ядер – имена образов ядра и initramfs для каждого пакета с ядром не меняются при обновлении, и файл конфигурации загрузчика не обновляется при обновлении ядра.
</p>
<p>Более того, возможности скриптов GRUB2 позволяют средствами самого загрузчика, прямо перед загрузкой ОС, <a href="#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BC%D0%B5%D0%BD%D1%8E">генерировать меню</a> с переменным количеством строк, для поиска и загрузки всех установленных ядер Arch Linux, без изменения каких-либо файлов конфигурации. То же самое возможно и <a href="#Debian,_Ubuntu_%D0%B8_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5_%D0%B4%D0%B8%D1%81%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B8%D0%B2%D1%8B_%D1%81_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%BC_%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D1%8F%D0%B4%D1%80%D0%B0">для версионных ядер Debian и Ubuntu</a>.
</p>
<p>Примеры кода конфигурации даны ниже, <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/">подробный справочник</a> имеется на сайте GRUB.
</p>
<p>Прежде чем приступать к написанию конфига, <b>крайне желательно защитить его</b> от возможной перезаписи при обновлении/переустановке пакета grub.
</p>
<h3>
<span id=".D0.97.D0.B0.D1.89.D0.B8.D1.82.D0.B0_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Защита_конфигурации">Защита конфигурации</span>
</h3>
<p>К сожалению, мейнтейнеры пакета <b>grub</b> <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/38812">отказываются</a> убирать из него бессмысленный, по определению неработающий и никому не нужный "дефолтный" вариант файла grub.cfg, создающий небольшую, но постоянную угрозу перезаписи настоящего рабочего конфига GRUB, особенно в случае ошибок со стороны мейнтейнеров. Эта опасность не зависит от используемого метода конфигурации GRUB – и ручной, и автогенерированный конфиг может быть однажды случайно перезаписан или переименован при очередном обновлении пакета, и выяснится это с большой вероятностью только после перезагрузки.
</p>
<h4>
<span id=".D0.92.D1.8B.D0.BD.D0.BE.D1.81_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D0.B2_.D0.B4.D1.80.D1.83.D0.B3.D0.BE.D0.B9_.D1.84.D0.B0.D0.B9.D0.BB"></span><span class="mw-headline" id="Вынос_конфигурации_в_другой_файл">Вынос конфигурации в другой файл</span>
</h4>
<p>Так как GRUB поддерживает модульность конфигурации, можно оставить в файле <code>grub.cfg</code> только одну строку со ссылкой на другой файл, например <code>menu.cfg</code>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">. $prefix/menu.cfg
</pre>
<p>и в дальнейшем вместо <code>grub.cfg</code> править только <code>menu.cfg</code>
</p>
<p>Для автоконфигурации в этом случае можно использовать команду
</p>
<pre>grub-mkconfig -o /boot/grub/menu.cfg
</pre>
<h4>
<span id=".D0.9F.D1.80.D1.8F.D0.BC.D0.B0.D1.8F_.D0.B1.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0_grub.cfg"></span><span class="mw-headline" id="Прямая_блокировка_grub.cfg">Прямая блокировка grub.cfg</span>
</h4>
<p>Чтобы защитить файл от любых изменений, присвойте ему атрибут immutable
</p>
<pre>chattr +i /boot/grub/grub.cfg
</pre>
<p>Блокировка снимается командой
</p>
<pre>chattr -i /boot/grub/grub.cfg
</pre>
<p>Если основная конфигурация уже вынесена в другой файл, блокировку grub.cfg достаточно установить однажды и больше не снимать.
</p>
<p>Блокировка защитит файл от перезаписи скриптами установки пакетов. Чтобы избежать конфликта с файлом из пакета, добавьте его имя в строку <code>NoUpgrade</code> в <code>/etc/pacman.conf</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/pacman.conf
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">NoUpgrade = boot/grub/grub.cfg
</pre>
<h4>
<span id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BD.D0.BE.D1.81_.D0.BA.D0.B0.D1.82.D0.B0.D0.BB.D0.BE.D0.B3.D0.B0_grub"></span><span class="mw-headline" id="Перенос_каталога_grub">Перенос каталога grub</span>
</h4>
<p>Если каталог <code>grub/</code> со всеми файлами загрузчика расположен в корневом разделе, для защиты конфигурации можно переместить его из <code>/boot</code> в другое место в пределах раздела, проще всего прямо в корень :
</p>
<pre>mv /boot/grub /
grub-install --boot-directory=/ /dev/sda
</pre>
<p>Вместо <b>/dev/sda</b> используйте текущее имя диска для установки <i>(при установке для <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> указывать его не нужно)</i>. Все файлы загрузчика после этого будут находиться в каталоге <code>/grub</code> , в том числе файл конфигурации <code>/grub/grub.cfg</code> . Образы ядра и initramfs останутся по-прежнему в <code>/boot</code> , и будут загружаться как обычно, правки путей не потребуется.
</p>
<p>В модульных и многофайловых <i>(шрифты, темы)</i> конфигурациях вместо <code>/boot/grub</code> можно использовать в путях к файлам переменную <code>$prefix</code>, в этом случае конфиги будут работать правильно вне зависимости от текущего расположения файлов загрузчика.
</p>
<p><br>Если вы используете автоконфигуратор, не забудьте после переноса заменить возможные упоминания <code>/boot/grub</code> на <code>/grub</code> в файлах <code>/etc/default/grub</code> и <code>/etc/grub.d/*</code>
</p>
<p>Для генерации конфига после переноса можно пользоваться командой
</p>
<pre>grub-mkconfig -o /grub/grub.cfg
</pre>
<h3>
<span id=".D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8_GRUB"></span><span class="mw-headline" id="Синтаксис_файла_конфигурации_GRUB">Синтаксис файла конфигурации GRUB</span>
</h3>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BC.D0.B8.D0.BD.D0.B8.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.B9_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D1.8E.D1.89.D0.B5.D0.B9_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Пример_минимальной_работающей_конфигурации">Пример минимальной работающей конфигурации</span>
</h4>
<p>Здесь только один пункт меню, загрузчик в корневом разделе, который передаётся ядру <a href="#%D0%9C%D0%B5%D1%82%D0%BA%D0%B8">меткой</a> Arch_root
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set timeout=5
menuentry "Arch Linux" {
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw
 initrd /boot/initramfs-linux.img
}
</pre>
<h4>
<span id=".D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D0.B8_.D0.BF.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5"></span><span class="mw-headline" id="Основные_команды_и_переменные">Основные команды и переменные</span>
</h4>
<p>Файл конфигурации состоит из команд, выполняемых по порядку, как в обычном шелл-скрипте.
</p>
<ul><li>Строки или продолжения строк, начинающиеся с символа <b>#</b> , считаются комментариями.</li></ul>
<ul>
<li>В GRUB2 используются обозначения дисков вида <b>hdX</b> и разделов вида <b>hdX,Y</b> , где <b>X</b> номер диска, <b>Y</b> номер раздела на нём. Нумерация разделов начинается с единицы <i>(как в ядре Linux)</i>, нумерация дисков – с нуля.  Если обозначение диска или раздела используется само по себе, например в переменной <b>root</b>, оно пишется <b>без</b> скобок.</li>
<li>Пути к файлам могут начинаться с обозначения диска или раздела в скобках, например <code>(hd0,1)/boot/vmlinuz</code> соответствует файлу <code>vmlinuz</code> в каталоге <code>/boot</code> на разделе <code>/dev/sda1</code>
</li>
</ul>
<ul><li>Если в пути к файлу не указан диск или раздел, подразумевается текущий диск или раздел из переменной <b>root</b> . При запуске GRUB2 эта переменная уже указывает на раздел, где хранятся все файлы загрузчика, и как правило, образы ядра и initramfs. Задавать переменную root в конфиге имеет смысл ТОЛЬКО для загрузки с ДРУГОГО раздела. Пример:</li></ul>
<pre>set root=hd0,1 # задаём раздел с другой ОС или другим загрузчиком
chainloader +1 # загружаем его бут-сектор
</pre>
<ul><li>Кроме файлов, GRUB2 позволяет обращаться напрямую к <b>цепочкам секторов</b> на диске или разделе, в формате <b>X+Y</b> , где <b>X</b> номер начального сектора цепочки, а <b>Y</b> количество секторов. Если цепочка начинается с первого (номер 0) сектора, её обозначение сокращается до <code>+Y</code>. Наиболее употребительная цепочка в конфигах GRUB – бут-сектор раздела или диска, обозначается как <b>+1</b>
</li></ul>
<ul><li>В обозначении раздела перед его номером может стоять слово, обозначающее его принадлежность к <b>таблице разделов</b> определённого типа, например <code>hd0,msdos3</code> означает третий раздел в <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a> на нулевом диске, а <code>hd1,gpt2</code> означает второй раздел в <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a> на следующем диске. GRUB2 всегда добавляет тип таблицы при выводе разделов командой <code>ls</code> и при записи <code>$prefix</code> в процессе установки, однако писать тип таблицы вручную не требуется – он определяется автоматически. Исключение может составлять только особо тяжелый случай двух разных таблиц разделов с разной нумерацией на одном диске, причём гибрид GPT+MBR таким случаем <b>не является</b> – GRUB2 игнорирует MBR, если на диске обнаружена GPT.</li></ul>
<ul><li>Команда <b>menuentry</b> генерирует один пункт меню. Она задаёт видимый заголовок и список команд, которые выполнятся после выбора этого пункта меню:</li></ul>
<pre>menuentry "Заголовок" {
# команды
}
</pre>
<ul><li>Переменная <b>default</b> задаёт номер или заголовок пункта меню, выбранного по-умолчанию. Например,  <code>set default=1</code> выбирает <i>второй</i> пункт. Пункты меню нумеруются с нуля.</li></ul>
<ul><li>Переменная <b>timeout</b> определяет время в секундах, по истечении которого будет загружен пункт меню по-умолчанию, например, <code>set timeout=5</code>.</li></ul>
<dl><dd><div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Если таймаут не задан, GRUB будет показывать меню неограниченно долго, и не начнёт загрузку ОС без вмешательства пользователя.</div></dd></dl>
<ul><li>Команда <b>linux</b> загружает образ ядра и параметры для него.</li></ul>
<ul><li>Команда <b>initrd</b> загружает образ начальной корневой ФС. Если образов указано несколько, они будут загружены по очереди. Например, образ для обновления микрокода процессоров Intel загружается перед основным образом:</li></ul>
<pre>initrd /boot/intel-ucode.img /boot/initramfs-linux.img
</pre>
<ul><li>Команда <b>chainloader</b> предназначена для загрузки "по цепочке" образа другого загрузчика. В режиме BIOS это, как правило, boot-сектор или его копия в файле, в режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> это может быть любое EFI-приложение, даже не обязательно находящееся в доступном для UEFI разделе – главное, чтобы файл мог быть прочитан средствами GRUB, а переменная <b>root</b> при вызове команды указывала на доступный UEFI раздел.</li></ul>
<h4>
<span id=".D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Стандартный_пример_конфигурации">Стандартный пример конфигурации</span>
</h4>
<p>В этом примере так или иначе фигурируют три раздела:
</p>
<ul><li>
<b>hd0,1</b> – раздел Windows, указан явно в последнем пункте меню.</li></ul>
<ul><li>
<b>hd0,2</b> – boot-раздел , монтируется в <code>/boot</code> , поэтому /boot отсутствует в путях к файлам. При старте раздел уже находится в переменной root, поэтому отдельно никак не задаётся, только подразумевается.</li></ul>
<ul><li>
<b>hd0,3</b> – корневой раздел Arch Linux , в Linux отображается как <code>/dev/sda3</code> , как и прописан в параметрах ядра.</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># по-умолчанию выбран пункт меню 0
set default=0

# при бездействии пользователя он загрузится через 5 секунд
set timeout=5

# пункт меню номер 0
menuentry "Arch Linux" {
 linux /vmlinuz-linux root=/dev/sda3 rw
 initrd /initramfs-linux.img
}

# пункт меню номер 1
menuentry "Windows XP" {
 chainloader (hd0,1)+1
}
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Если образы ядра и initramfs лежат не в отдельном разделе, а в каталоге <code>'/boot'</code>, он должен быть указан в путях к ним:</div>
<pre>menuentry "Arch Linux" {
 linux /boot/vmlinuz-linux root=/dev/sda3 rw
 initrd /boot/initramfs-linux.img
}
</pre>
<h4>
<span id=".D0.92.D1.82.D0.BE.D1.80.D0.B8.D1.87.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D0.B8.2C_.D0.B2.D0.BB.D0.BE.D0.B6.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D0.BD.D1.8E_.D0.B8_.D1.81.D0.BC.D0.B5.D0.BD.D0.B0_.D0.BA.D0.BE.D0.BD.D1.82.D0.B5.D0.BA.D1.81.D1.82.D0.B0"></span><span class="mw-headline" id="Вторичные_конфиги,_вложенные_меню_и_смена_контекста">Вторичные конфиги, вложенные меню и смена контекста</span>
</h4>
<p>Как и UNUX-шелл, GRUB2 поддерживает три вида переменных: обычные, позиционные параметры и переменные окружения.
</p>
<ul>
<li>
<b>Обычные переменные</b> доступны командам конфига, также внутри вызываемых из него функций и пунктов меню, но не наследуются при смене контекста.</li>
<li>
<b>Переменные окружения</b> недоступны непосредственно, но наследуются и автоматически импортируются в обычные при смене контекста.</li>
<li>
<b>Позиционные параметры</b>, они же "параметры командной строки". Передаются при вызове функции или пункта меню как аргументы команды, внутри функции или пункта меню обозначаются цифрами по порядку, начиная с <b>$1</b>
</li>
</ul>
<p>Обычные переменные создаются в момент первого присвоения, командой <code>set переменная=значение</code><br>
При этом само слово <b>set</b> можно не писать:
</p>
<pre>head="Arch linux"
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> В примерах конфигов в этой статье слово <b>set</b> использовано при присвоении встроенных переменных GRUB2, чтобы их было проще отличать от обычных, пользовательских переменных. На самом деле, использование <code>set</code> при присвоении не требуется ни для каких переменных.</div>
<p>Для уничтожения обычной переменной может быть использована команда <b>unset</b>
</p>
<pre>unset timeout
</pre>
<p>Обычные переменные могут быть экспортированы "в окружение" командой <b>export</b>
</p>
<pre>export a b c
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Некоторые встроенные переменные GRUB2, в частности <b>root</b> и <b>lang</b>, имеют свойство экспортироваться автоматически.</div>
<p>Так же как в шелл-скриптах, из одного конфига GRUB2 может вызван другой файл конфига.
</p>
<ul><li>Команда <b>source</b> <i>(часто обозначается просто точкой <code>.</code>)</i> выполняет другой конфиг без смены контекста, после чего продолжает выполняться текущий. Пример:</li></ul>
<pre>. $prefix/custom.cfg
</pre>
<ul><li>Команда <b>configfile</b> запускает новый конфиг в новом контексте:</li></ul>
<pre>configfile /boot/grub/new.cfg
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Переменная <b>prefix</b> при запуске GRUB содержит полный путь к каталогу, в который установлен загрузчик. Задавать её явно обычно не требуется, однако <code>$prefix</code> удобно использовать при обращении к другим конфигам, так как именно в этом каталоге находится grub.cfg, и как правило, дополнительные файлы конфигурации.</div>
<ul>
<li>Команда <b>submenu</b> создаёт новый пункт меню, так же как и <code>menuentry</code>, и может иметь точно такой же набор параметров. Единственное отличие <b>submenu</b> состоит в том, что команды внутри него выполняются <b>в новом контексте</b>, так же как при вызове конфига через <code>configfile</code>. Соответственно, все новые пункты меню, создаваемые в новом контексте, добавляются в <b>новое меню</b>, отсюда и название команды.</li>
<li>Возврат в старое меню <i>(и старый контекст, со старыми переменными)</i> из вложенного, может быть выполнен нажатием клавиши ESC.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Несмотря на название, можно использовать команду <b>submenu</b> и без создания нового меню, просто для смены контекста. В большинстве примеров этой статьи команда <code>submenu</code> использована только для того, чтобы локально менять текущий раздел в переменной <code>$root</code>, не затрагивая других пунктов меню в случае возврата.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> В принципе, ничто не мешает создавать пункты меню и внутри <code>menuentry</code>, однако в этом случае новые пункты будут будут добавляться не в новое, а прямо в текущее меню.</div>
<h3>
<span id=".D0.9F.D0.BE.D1.81.D1.82.D0.BE.D1.8F.D0.BD.D0.BD.D0.BE.D0.B5_.D0.B8.D0.BC.D0.B5.D0.BD.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.83.D1.81.D1.82.D1.80.D0.BE.D0.B9.D1.81.D1.82.D0.B2"></span><span class="mw-headline" id="Постоянное_именование_устройств">Постоянное именование устройств</span>
</h3>
<h4><span class="mw-headline" id="UUID">UUID</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Автоматический конфигуратор использует UUID по-умолчанию. Если вы хотите, чтобы он использовал классические имена устройств <i>(например, если у вас нет initramfs)</i>, вы можете запретить конфигуратору использовать UUID, раскомментировав в <code>/etc/default/grub</code> строку<br>
<code>GRUB_DISABLE_LINUX_UUID=true</code> </div>
<p>При загруженном Linux, узнать UUID имеющихся разделов можно с помощью команды <b>lsblk -f</b>
</p>
<p>Полученный UUID корневого раздела можно вручную вставить в параметры ядра, примерно так: <code>root=UUID=355ccb5c-99e1-400d-b612-451f9247e35e</code>, но делать это имеет смысл, <b>только</b> если у вас есть отдельный boot-раздел.
</p>
<p>Чаще всего и GRUB, и ядро находятся в одном том же корневом разделе, который уже и так находится в <code>$root</code>, остаётся получить его UUID в переменную для подстановки в параметры ядра:
</p>
<pre>probe --set=UUID --fs-uuid $root
</pre>
<p>Пример загрузки ядра с автоматической подстановкой UUID:
</p>
<pre>menuentry "Arch Linux" {
 probe -s UUID -u $root
 linux /boot/vmlinuz-linux root=UUID=$UUID rw
 initrd /boot/initramfs-linux.img
}
</pre>
<p>Параметры команды <b>probe</b> здесь те же самые, просто в сокращённой форме.
</p>
<p><br>И только если образ ядра находится <b>не</b> в том разделе, что GRUB, то есть <b>не</b> в корневом, и <b>не</b> в boot-разделе, требуется отдельно указать его загрузчику. Чтобы сделать это, используйте команду <b>search</b>. Так мы устанавливаем корневой раздел в переменную загрузчика <code>$root</code> через поиск по UUID, и этот же UUID подставляем в параметры ядра, если отдельного boot-раздела нет:
</p>
<pre>menuentry "Arch Linux" {
 UUID=355ccb5c-99e1-400d-b612-451f9247e35e
 search --fs-uuid $UUID --set root
 linux /boot/vmlinuz-linux root=UUID=$UUID rw
 initrd /boot/initramfs-linux.img
}
</pre>
<h4>
<span id=".D0.9C.D0.B5.D1.82.D0.BA.D0.B8"></span><span class="mw-headline" id="Метки">Метки</span>
</h4>
<p>Метки - легко читаемые заголовки, присваиваемые файловым системам и не только:
</p>
<pre>e2label /dev/sda3 Arch_root      # ставим метку на ext2/3/4
swaplabel -L Arch_swap /dev/sda2 # ставим метку свап-разделу
mkswap -L Arch_swap /dev/sda2    # если свап "старый", пересоздаём с меткой
ntfslabel /dev/sda1 WindowsXP    # ставим метку на NTFS
fatlabel /dev/sda5 OTHERDATA     # ставим метку на FAT
</pre>
<p>Метку можно подставить в параметры ядра. Пример:
</p>
<pre>menuentry "Arch Linux" {
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw
 initrd /boot/initramfs-linux.img
}
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Если вы используете метки для поиска разделов при загрузке, позаботьтесь об их уникальности. К примеру, метки Arch, root или my_disk уникальностью не отличаются.</div>
<p><br>Если загрузчик находится в отдельном от ядра и корня разделе, корневой раздел можно указать через метку и загрузчику:
</p>
<pre>menuentry "Arch Linux" {
 search --label Arch_root --set root
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw
 initrd /boot/initramfs-linux.img
}
</pre>
<h3>
<span id=".D0.9E.D1.81.D0.BE.D0.B1.D1.8B.D0.B5_.D1.82.D0.B8.D0.BF.D1.8B_.D1.83.D1.81.D1.82.D1.80.D0.BE.D0.B9.D1.81.D1.82.D0.B2"></span><span class="mw-headline" id="Особые_типы_устройств">Особые типы устройств</span>
</h3>
<h4><span class="mw-headline" id="LVM">LVM</span></h4>
<ul><li>При использовании GRUB2 на <a href="../en/LVM.html" class="mw-redirect" title="LVM (Русский)">LVM</a>, как правило, никаких дополнительных команд в конфиге GRUB не требуется, достаточно просто передать ядру в параметре <b>root=</b> обозначение группы и тома LVM, принятое в Linux, то есть <code>/dev/mapper/Group-Name</code>:</li></ul>
<pre>menuentry "Arch Linux" {
 linux /vmlinuz-linux root=/dev/mapper/Arch-Root rw
 initrd /initramfs-linux.img
}
</pre>
<p>или <code>/dev/Group/Name</code>:
</p>
<pre>menuentry "Arch Linux" {
 linux /vmlinuz-linux root=/dev/Arch/Root rw resume=/dev/Arch/Swap
 initrd /initramfs-linux.img
}
</pre>
<ul><li>Только если GRUB находится на разделе, отдельном от раздела с ядрами, то есть <b>не</b> на корневом, и <b>не</b> на boot-разделе, может потребоваться указать ему нужный раздел с образами ядра и imitramfs. Группа и том LVM в формате GRUB2 задаются так:</li></ul>
<pre>set root=lvm/Group-Name
</pre>
<ul><li>И только если GRUB2 установлен <b>не</b> на LVM, а образы ядра он должен прочесть с тома LVM, может также потребоваться предварительно загрузить его модуль командой <b>insmod</b> :</li></ul>
<pre>menuentry "Arch Linux" {
 insmod lvm
 set root=lvm/Arch-Root
 linux /vmlinuz-linux root=/dev/mapper/Arch-Root rw
 initrd /initramfs-linux.img
}
</pre>
<h3>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D1.85_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D1.8B.D1.85_.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC"></span><span class="mw-headline" id="Загрузка_других_операционных_систем">Загрузка других операционных систем</span>
</h3>
<p>GRUB можно использовать для загрузки и других установленных на той же машине дистрибутивов и операционных систем. Для добавления каждого нового пункта загрузочного меню GRUB, в его конфиг добавляется своя секция menuentry. Примеры конфигурации дополнительных пунктов для запуска Linux и Windows приведены ниже.
</p>
<p>Если вы используете автоконфигурацию GRUB, но хотите, чтобы в генерируемый конфиг добавлялись ваши пункты меню, написанные вручную, отредактируйте файл <code>/etc/grub.d/40_custom</code> и допишите их в конец этого файла. Всё его содержимое будет добавлено в конфиг загрузчика при запуске <b>grub-mkconfig</b>
</p>
<h4>
<span id="GNU.2FLinux"></span><span class="mw-headline" id="GNU/Linux">GNU/Linux</span>
</h4>
<p>В этом примере другой дистрибутив Linux загружается с раздела <code>sda2</code>:
</p>
<pre>submenu "Other Linux" {
 set root=hd0,2
 linux /boot/vmlinuz # добавьте сюда все нужные опции ядра
 initrd /boot/initrd.img # файл initrd, если он используется
}
</pre>
<h4><span class="mw-headline" id="Windows">Windows</span></h4>
<p>Операционные системы Windows не поддерживают протокол Multiboot, и GRUB не может загружать Windows непосредственно. Чтобы загрузить Windows, нужно запустить её собственный загрузчик, который, в свою очередь, загружает ядро Windows и набор необходимых для старта драйверов, по списку, который он читает из реестра Windows.
</p>
<p>Для BIOS и для <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> в одной и той же версии Windows используются две различных версии загрузчика, каждая со своими особенностями. Windows, установленная в режиме BIOS, не имеет UEFI-загрузчика и не стартует в режиме UEFI, и наоборот – будучи установленной в режиме UEFI, Windows не стартует режиме BIOS.
</p>
<h5>
<span id="Windows_.D0.B2_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D0.B5_BIOS"></span><span class="mw-headline" id="Windows_в_режиме_BIOS">Windows в режиме BIOS</span>
</h5>
<p>Загрузчик Windows для режима BIOS поддерживает только одну таблицу разделов – <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a>, и не поддерживает GPT, независимо от версии Windows. Кроме того, 32-битная версия Windows XP может быть запущена только в режиме BIOS.
</p>
<p>Загрузчик Windows может быть запущен через бут-сектор раздела, на который он установлен:
</p>
<pre>menuentry "Windows" {
 chainloader (hd0,2)+1
}
</pre>
<p>либо напрямую из его файла, специальной командой <b>ntldr</b>
</p>
<pre>submenu "Windows XP" {
 set root=hd0,2
 ntldr /ntldr
}
</pre>
<p>В Windows Vista и выше файл загрузчика называется иначе, но может быть загружен той же командой:
</p>
<pre>submenu "Windows 7" {
 set root=hd0,3
 ntldr /bootmgr
}
</pre>
<h5>
<span id="Windows_.D0.B2_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D0.B5_UEFI"></span><span class="mw-headline" id="Windows_в_режиме_UEFI">Windows в режиме UEFI</span>
</h5>
<p>Загрузчик Windows, установленной в режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a>, поддерживает только одну таблицу разделов – <a href="../ru/Partitioning.html#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%BE%D0%B2_GUID" class="mw-redirect" title="GPT (Русский)">GPT</a>, и не поддерживает MBR.
</p>
<p>Если GRUB2 установлен в режиме UEFI, его стартовый образ лежит в том же <a href="../ru/EFI_system_partition.html" title="EFI system partition (Русский)">ESP/EFISYS</a> разделе, что загрузчик Windows. Полный путь к стартовому образу GRUB2 режима UEFI указывает переменная <code>$cmdpath</code> с содержимым вида <code>(диск,раздел)/EFI/каталог/grubx64.efi</code>.
Чтобы из этого пути получить диск и раздел, можно регулярным выражением обрезать скобки и путь, и записать результат в переменную <code>$root</code>. После этого загрузчик Windows запускается командой <code>chainloader</code>, как обычное EFI-приложение:
</p>
<pre>submenu "Windows 8" {
 regexp -s root '\((.+)\)' "$cmdpath"
 chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}
</pre>
<h4>
<span id=".D0.97.D0.B0.D0.BF.D1.83.D1.81.D0.BA_FreeDOS"></span><span class="mw-headline" id="Запуск_FreeDOS">Запуск FreeDOS</span>
</h4>
<p>Аналогично командам <b>linux</b> и <b>ntldr</b>, в GRUB предусмотрена возможность прямой загрузки ядра FreeDOS, командой <b>freedos</b>, без использования оригинального загрузочного кода в MBR и бут-секторе:
</p>
<pre>menuentry "FreeDOS" {
 freedos /KERNEL.SYS
}
</pre>
<p>Это может быть удобно, когда требуется скопировать уже установленную, к примеру, на флешку, FreeDOS, используемую для запуска MHDD и подобных инструментов.
Такой способ загрузки позволяет под Linux копировать файлы и каталоги однажды установленной FreeDOS на другие носители, в том числе "мультизагрузочные".
<i>(Установка FreeDOS штатным способом, с записью её загрузочного кода в MBR и бут-сектор, требует каждый раз загружать саму FreeDOS, хотя бы в виртуальной машине.)</i>
</p>
<h4>
<span id=".D0.97.D0.B0.D0.BF.D1.83.D1.81.D0.BA_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.2C_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D1.8E.D1.89.D0.B8.D1.85_.D0.B1.D0.B5.D0.B7_.D0.9E.D0.A1"></span><span class="mw-headline" id="Запуск_программ,_работающих_без_ОС">Запуск программ, работающих без ОС</span>
</h4>
<h5>
<span id="Memtest86.2B"></span><span class="mw-headline" id="Memtest86+">Memtest86+</span>
</h5>
<p>Тест памяти <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=memtest86%2B">memtest86+</a></span> (версия для BIOS):
</p>
<pre>menuentry "Memtest86+" {
 linux16 /boot/memtest86+/memtest.bin
}
</pre>
<p>Он же, но для UEFI (пакет <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=memtest86%2B-efi">memtest86+-efi</a></span>):
</p>
<pre>menuentry "Memtest86+" {
 linux /boot/memtest86+/memtest.efi
}
</pre>
<p><br>
</p>
<h5>
<span id="EFI-.D0.BF.D1.80.D0.B8.D0.BB.D0.BE.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F"></span><span class="mw-headline" id="EFI-приложения">EFI-приложения</span>
</h5>
<p>EFI-приложения можно запускать не только из интерфейса UEFI, но и из других EFI-приложений, в том числе из UEFI-версии GRUB2, с помощью команды <b>chainloader</b>. На примере загрузчика Windows это уже показано <a href="#Windows_%D0%B2_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5_UEFI">выше</a>.
</p>
<p>Чтобы запустить EFI-приложение, вовсе не обязательно класть его на раздел EFISYS, особенно если приложение большое, а на спецразделе очень мало места. Достаточно, чтобы файл приложения читался средствами GRUB, а переменная <b>root</b> указывала на EFISYS. В этом примере <a href="../ru/Unified_Extensible_Firmware_Interface.html#UEFI_Shell" class="mw-redirect" title="UEFI (Русский)">UEFI Shell</a> запускается прямо из <code>/boot</code>:
</p>
<pre>submenu "UEFI Shell" {
 archroot=$root
 regexp -s root '\((.+)\)' "$cmdpath"
 chainloader ($archroot)/boot/Shell.efi
}
</pre>
<p>При выходе из UEFI Shell вы снова увидите меню GRUB.
</p>
<h4>
<span id="Debian.2C_Ubuntu_.D0.B8_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.B4.D0.B8.D1.81.D1.82.D1.80.D0.B8.D0.B1.D1.83.D1.82.D0.B8.D0.B2.D1.8B_.D1.81_.D0.B2.D0.B5.D1.80.D1.81.D0.B8.D0.BE.D0.BD.D0.BD.D1.8B.D0.BC_.D0.BE.D0.B1.D0.BD.D0.BE.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5.D0.BC_.D1.8F.D0.B4.D1.80.D0.B0"></span><span class="mw-headline" id="Debian,_Ubuntu_и_другие_дистрибутивы_с_версионным_обновлением_ядра">Debian, Ubuntu и другие дистрибутивы с версионным обновлением ядра</span>
</h4>
<p>В дистрибутивах с версионными ядрами, при каждом обновлении ядра автоматически вызывается генератор конфигурации загрузчика, поскольку имена загрузочных образов vmlinuz и initrd меняются при каждом обновлении. Это обстоятельство вынудило разработчиков Debian и Ubuntu сделать автоконфигуратор даже для первой версии GRUB, в которой обычно использовались только статические конфиги.
</p>
<p>Если другой дистрибутив установлен на отдельный диск <i>(в режиме BIOS)</i>, и имеет собственную установку GRUB2, для его загрузки достаточно запустить другой загрузчик:
</p>
<pre>menuentry "Ubuntu" {
 chainloader (hd1)+1
}
</pre>
<p>В режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> несколько загрузчиков могут быть установлены и на один диск, и запускаться один из другого как EFI-приложения:
</p>
<pre>submenu "Ubuntu" {
 regexp -s root '\((.+)\)' "$cmdpath"
 chainloader /EFI/ubuntu/grubx64.efi
}
</pre>
<p>В некоторых случаях <i>(не всегда)</i> другую установку GRUB2 можно запустить в режиме BIOS с помощью команды <b>multiboot</b>, минуя встраивание образа в таблицу разделов:
</p>
<pre>sunmenu "Other Linux" {
 set root=hd0,6
 multiboot /boot/grub/i386-pc/core.img
}
</pre>
<p>К сожалению, часто встречается ситуация, когда другой дистрибутив установлен в режиме BIOS на тот же самый диск, в таблицу разделов которого можно установить только один загрузчик, и запустить второй проблематично. В этом случае остаётся либо использовать GRUB из состава того дистрибутива, либо учить штатный загрузчик Arch Linux работать с версионными ядрами.
</p>
<p>Самый простой способ это сделать – подсунуть "своему" GRUB конфиг от чужого, в котором всё уже предусмотрено, не забыв перед этим сбросить некоторые переменные, которые могут вызвать проблемы:
</p>
<pre>submenu "Ubuntu" {
 unset lang
 unset gfxmode
 set root=hd0,2
 configfile /boot/grub/grub.cfg
}
</pre>
<p>Однако, есть возможность обойтись без чужих конфигов и загрузчиков, если использовать <a href="#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BC%D0%B5%D0%BD%D1%8E">динамическую генерацию меню загрузчиком</a>. В конфиг GRUB2 включается скрипт, генерирующий меню для Ubuntu:
</p>
<pre>. $prefix/ubuntu.cfg
</pre>
<p>Параметры для загрузки чужих ядер здесь вынесены в отдельный файл настроек:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">usettings.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">uroot=hd0,2
boot=/boot
opts="root=LABEL=Ubuntu_root ro resume=LABEL=SwapU"
hpref="Ubuntu"
</pre>
<p>Сам скрипт:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">ubuntu.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">function usave {
 if [ "$1" != "$usel" ] ; then
  usel="$1"
  save_env usel
 fi
}

function umenu {
 . $prefix/usettings.cfg

 kpref=$boot/vmlinuz-
 ipref=$boot/initrd.img-

 load_env
 default="$hpref $usel"
 if [ -n "$2" ] ; then default="$default $2" ; fi

 kernels=
 for kfile in "$uroot$kpref"* ; do
  k=
  regexp -s k "$kpref"'(.+)' "$kfile"
  kernels="$k $kernels"
 done

 for k in $kernels ; do
  ifile="$uroot$ipref$k"
  if [ -f "$ifile" ] ; then
   head="$hpref $k"
   if [ -n "$2" ] ; then head="$head $2" ; fi
   menuentry "$head" --source="usave $k
linux $uroot$kpref$k $opts $1
initrd $ifile"
  fi
 done
}

submenu "Ubuntu" --hotkey=u {
 insmod regexp

 submenu "Recovery mode" --hotkey=r {
  umenu "recovery nomodeset" "recovery mode"
 }

 umenu
}
</pre>
<p>Этот скрипт в конфиге GRUB динамически генерирует отдельное подменю со всеми имеющимися ядрами Ubuntu, и отдельно (для Ubuntu) запоминает последнее выбранное ядро.
</p>
<h4>
<span id=".D0.9F.D1.80.D1.8F.D0.BC.D0.B0.D1.8F_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.B8.D0.B7_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.B0_.D0.B4.D0.B8.D1.81.D0.BA.D0.B0"></span><span class="mw-headline" id="Прямая_загрузка_из_образа_диска">Прямая загрузка из образа диска</span>
</h4>
<p>GRUB2 может загружать образы ядер ОС в том числе из файлов-образов, отображаемых в псевдоустройство командой <b>loopback</b>. Однако следует иметь в виду, что псевдоустройство действует только в пределах загрузчика. В общем случае загрузка из образа выглядит примерно так:
</p>
<pre>loopback loop файл-образа
linux (loop)/путь/к/vmlinuz параметры
initrd (loop)/путь/к/initrd
</pre>
<p>После отображения образа в loop-устройство <i>(имя может быть любым, не только loop)</i>, можно средствами GRUB2 обращаться с ним так же, как и с физическими дисками – не только загружать файлы ядра и initrd, что происходит перед загрузкой, а к примеру, прочитать метку ФС образа (требуется для образа Arch):
</p>
<pre>probe -s isolabel -l loop
</pre>
<p>Так как средства загрузки с loopback-устройства в разных дистрибутивах различаются, <b>для каждого из них требуется передавать при загрузке параметры, специфичные для данного дистрибутива</b>.
</p>
<ul>
<li>Установочный образ Arch требует метку ФС образа в параметре ядра <code>archisolabel=</code>, и линуксовое устройство раздела, на котором он лежит, в параметре <code>img_dev=</code> <i>(универсальнее всего прочесть и передать его UUID, но можно использовать и метку, если она есть)</i>.</li>
<li>Образ Ubuntu довольствуется лишь путём к образу на диске, а остальное находит сам.</li>
</ul>
<p>В некоторых дистрибутивах средства загрузки из образа могут и вовсе отсутствовать, поэтому не все существующие загрузочные образы могут быть использованы подобным образом.
</p>
<p>Во всех приведённых ниже примерах предполагается, что <b>GRUB2 установлен на тот же раздел диска или флешки, где лежат образы</b> <i>(в противном случае см. <a href="#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2_%D1%81_%D0%BE%D1%82%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B0_%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0">ниже</a>)</i>.  Такой способ установки позволяет записать на одну флешку или внешний диск один или несколько образов, при этом сохранив возможность использования оставшегося места на носителе по прямому назначению, с сохранением предпочтительной файловой системы.
</p>
<h5><span class="mw-headline" id="Arch_Linux_ISO">Arch Linux ISO</span></h5>
<p>В этом примере GRUB2 загружает официальный установочный образ Arch Linux.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">dir=
arch=x86_64
insmod regexp               # для шаблонов * в именах файлов
probe -s root_uuid -u $root # получаем UUID для подстановки в img_dev=

for iso in $dir/archlinux-*-$arch.iso ; do      # ищем образ(ы) Arch по шаблону
 if [ ! -f "$iso" ] ; then continue; fi        # только если образ существует
 regexp -s build 'archlinux-(.+)-'$arch "$iso"  # получаем из имени образа дату сборки

  menuentry "Arch Linux ISO $build $arch" --source="\
loopback loop $iso
probe -s isolabel -l loop
linux (loop)/arch/boot/$arch/vmlinuz archisolabel=\$isolabel img_dev=/dev/disk/by-uuid/$root_uuid img_loop=$iso earlymodules=loop
initrd (loop)/arch/boot/$arch/archiso.img"

done
</pre>
<p>Файл образа с именем вида <code>archlinux-YYYY.MM.DD-x86_64.iso</code> должен лежать в корне раздела. В этом случае текст файла конфигурации можно использовать "как есть", без каких-либо правок – загрузчик сам определит конкретное имя образа (или образов), сам прочитает UUID раздела, метку образа, и при загрузке передаст всё это дистрибутиву через параметры ядра.
</p>
<p>Если же вы хотите использовать для образа (образов) особый каталог, впишите путь к нему (относительно корня раздела) в строку <code>dir=</code>, например
</p>
<pre>dir=/images
</pre>
<h5><span class="mw-headline" id="Ubuntu_desktop_ISO">Ubuntu desktop ISO</span></h5>
<p>В этом примере GRUB2 загружает любые ISO-образы Ubuntu, кроме серверных. В сгенерированном меню будут варианты загрузки для всех найденных образов Ubuntu.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">dir=
insmod regexp

for iso in $dir/*ubuntu-*.iso ; do         # ищем образ(ы) Ubuntu
 if [ ! -f "$iso" ] ; then continue; fi    # только если образ существует
 regexp -s name '.*/(.+)\.iso' "$iso"                # выделяем только имя
 if regexp server "$name" ; then continue ; fi              # Ubuntu Server не трогаем, там всё иначе
 if regexp amd64 "$name" ; then efi='.efi' ; else efi= ; fi # для x86_64 образ ядра vmlinuz.efi

  menuentry "$name" --source="\
loopback loop $iso
linux (loop)/casper/vmlinuz$efi boot=casper iso-scan/filename=$iso noeject --
initrd (loop)/casper/initrd.lz"

done
</pre>
<p>Как и в предыдущем примере, код не требует никаких правок, если файлы образов лежат в корне раздела, но можно вписать отдельный каталог для них в строку <code>dir=</code>
</p>
<h5>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2_.D1.81_.D0.BE.D1.82.D0.B4.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B0_.D0.B2.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B4.D0.B8.D1.81.D0.BA.D0.B0"></span><span class="mw-headline" id="Загрузка_образов_с_отдельного_раздела_встроенного_диска">Загрузка образов с отдельного раздела встроенного диска</span>
</h5>
<p>Если образы требуется загружать с некорневого раздела встроенного жесткого диска <i>(например,</i> <code>/home</code> <i>)</i>, можно использовать тот же код, создав для него подменю:
</p>
<pre>submenu "ISO boot" {
 dir=
 set root=hd0,5 # здесь нужно вписать настоящий номер раздела
 # или найти его по метке, например Arch_home:
 # search -s root -l Arch_home
 insmod regexp
 probe -s root_uuid -u $root
 arch=x86_64
 
 # вместо этой строки вставляем основной код, начиная с for
}
</pre>
<p>Если раздел требуется задать по UUID, можно сделать так:
</p>
<pre>submenu "ISO boot" {
 dir=
 root_uuid=ef6daeca-9278-40df-8c3b-55cf093ab215
 search -s root -u $root_uuid
 insmod regexp
 arch=x86_64
 
 # вместо этой строки вставляем основной код, начиная с for
}
</pre>
<p><br>
</p>
<h3>
<span id=".D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.85.D0.BE.D0.B4.D0.BE.D0.BC_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B8"></span><span class="mw-headline" id="Управление_ходом_загрузки">Управление ходом загрузки</span>
</h3>
<p>Так же, как и из Linux, из GRUB можно выполнить перезагрузку командой <code>reboot</code> и выключение командой <code>halt</code>
</p>
<p>Кроме того, в режиме UEFI есть некоторые специфические действия.
</p>
<h4>
<span id=".D0.9F.D0.B5.D1.80.D0.B5.D1.85.D0.BE.D0.B4_.D0.B2_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BA_UEFI"></span><span class="mw-headline" id="Переход_в_интерфейс_настроек_UEFI">Переход в интерфейс настроек UEFI</span>
</h4>
<p>Не секрет, что на некоторых прошивках UEFI, особенно это относится к ноутбукам, может быть очень сложно попасть в интерфейс настроек UEFI путём нажатия при включении F2 или других клавиш, особенно если режим совместимости с BIOS (Legacy mode) полностью отключён или вообще отсутствует, а UEFI "видит" доступный загрузчик. Конечно, перезагрузиться в настройки UEFI можно и после загрузки Linux, например, консольной командой
</p>
<pre>systemctl reboot --firmware-setup
</pre>
<p>Но есть более быстрый способ: перейти в интерфейс UEFI прямо из загрузчика, для этого в GRUB есть специальная команда <code>fwsetup</code>
</p>
<p>Другими словами, вы можете добавить в меню GRUB дополнительный пункт:
</p>
<pre>menuentry "UEFI Settings" {
 fwsetup
}
</pre>
<p>и выбрав его, сразу открыть настройки UEFI, без загрузки и перезагрузки ОС.
</p>
<h3>
<span id=".D0.97.D0.B0.D1.89.D0.B8.D1.82.D0.B0_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0_.D0.BF.D0.B0.D1.80.D0.BE.D0.BB.D0.B5.D0.BC"></span><span class="mw-headline" id="Защита_загрузчика_паролем">Защита загрузчика паролем</span>
</h3>
<h4>
<span id=".D0.9E_.D0.B7.D0.B0.D1.89.D0.B8.D1.82.D0.B5_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="О_защите_загрузчика">О защите загрузчика</span>
</h4>
<p>По-умолчанию GRUB2 предоставляет любому пользователю полный доступ ко всем своим возможностям, включающим в себя не только выполнение любых пунктов меню, но и изменение их кода перед выполнением, а также терминал, позволяющий вручную выполнить любые команды загрузчика.
</p>
<p>Всё это может помочь при настройке и восстановлении системы, однако те же самые инструменты существенно облегчают любому посетителю взлом системы. Изменение параметров ядра может быть использовано для получения полномочий root без ввода пароля, а загрузка с внешнего носителя – для получения полного доступа ко всем незашифрованным данным.
</p>
<p>GRUB2 включает в себя средства ограничения доступа к загрузчику. С их помощью, в сочетании с ограничением доступа к BIOS, и запретом в BIOS на загрузку с любых внешних носителей, можно сильно затруднить несанкционированный доступ к системе, кроме случая вскрытия корпуса для извлечения дисков или сброса настроек BIOS.
</p>
<h4>
<span id=".D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.B0.D1.80.D0.BE.D0.BB.D0.B5.D0.B9_.D0.B2_GRUB2"></span><span class="mw-headline" id="Реализация_паролей_в_GRUB2">Реализация паролей в GRUB2</span>
</h4>
<p>Пользователи в GRUB2 делятся на три категории:
</p>
<ul>
<li>
<b>Гости</b>, они же неавторизованные пользователи. Могут выполнять только не защищённые паролем пункты меню.</li>
<li>
<b>Авторизованные пользователи</b>. Могут выполнять разрешенные для них пункты меню.</li>
<li>
<b>Администраторы</b>. Имеют полный доступ – могут выполнять любые пункты меню, редактировать их перед выполнением, и открывать командный терминал.</li>
</ul>
<p>Для управления доступом к пунктам меню, команды <b>menuentry</b> и <b>submenu</b> поддерживают следующие опции:<br>
<code>--users=</code> позволяет задать список пользователей, которым разрешено выполнять этот пункт меню<br>
<code>--unrestricted</code> разрешает выполнять этот пункт меню без авторизации.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> После активации парольной защиты загрузчика, любые пункты меню, не имеющие ни одной из этих опций, будет доступны только администраторам.</div>
<p>Список администраторов задаётся в переменной <b>superusers</b>, например так:
</p>
<pre>set superusers=root
</pre>
<p>Пароль для каждого пользователя отдельно может быть задан в открытом виде командой
</p>
<pre>password пользователь пароль
</pre>
<p>либо в зашифрованном (хешированном) виде, командой
</p>
<pre>password_pbkdf2 пользователь хеш
</pre>
<p>Для хеширования пароля используется утилита <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/Invoking-grub_002dmkpasswd_002dpbkdf2.html#Invoking-grub_002dmkpasswd_002dpbkdf2">grub-mkpasswd-pbkdf2</a>. Запустив её и введя (дважды) пароль, можно получить его хеш, пригодный для вставки в конфиг GRUB2.
</p>
<p>Чтобы защитить пароли и хеши от просмотра, можно задать права на файл с конфигом GRUB в виде root:root 600, либо вынести команды с паролями в отдельный файл
</p>
<pre>. $prefix/secret.cfg
</pre>
<p>и ограничить доступ только к нему.
</p>
<h4>
<span id=".D0.92.D0.BD.D0.B5.D0.B4.D1.80.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B0.D1.80.D0.BE.D0.BB.D0.B5.D0.B9_.D0.B2_.D0.B3.D0.B5.D0.BD.D0.B5.D1.80.D0.B8.D1.80.D1.83.D0.B5.D0.BC.D1.8B.D0.B9_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3"></span><span class="mw-headline" id="Внедрение_паролей_в_генерируемый_конфиг">Внедрение паролей в генерируемый конфиг</span>
</h4>
<p>Конфигуратор <code>grub-mkconfig</code> сам не умеет ограничивать доступ к загрузчику, хотя и устанавливает права доступа к конфигу в <code>-rw------- root root</code>, что имеет смысл только для сохранения паролей.
</p>
<p>Есть возможность вставить вручную написанный фрагмент конфига с паролями, добавив в конец файла <code>/etc/grub.d/00_header</code> примерно такие строки:
</p>
<pre>cat &lt;&lt; EOF

set superusers=root
password_pbkdf2 root grub.pbkdf2.sha512.10000.C2DDC47FC5C7341CE73DBD6728E8D29A.AA5A1DEA93E23358E908301439DEC488

EOF
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> После генерации такого конфига ВСЕ пункты меню станут доступны только администратору!</div>
<p>Более гибкая настройка доступа к загрузчику, например разрешение штатной загрузки системы без ввода пароля, возможна либо путём добавления своих пунктов меню с опцией <code>--unrestricted</code> в конец файла <code>/etc/grub.d/40_custom</code>, либо при самостоятельном написании всего конфига GRUB.
</p>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D0.B0_.D1.81_.D0.BF.D0.B0.D1.80.D0.BE.D0.BB.D1.8F.D0.BC.D0.B8"></span><span class="mw-headline" id="Пример_конфига_с_паролями">Пример конфига с паролями</span>
</h4>
<p>Здесь "Arch Linux" разрешено загружать без авторизации, "Windows" разрешено загружать пользователю second с паролем dnjhjq, а активировать "Boot next disk", позволяющий загрузиться с подключённой флешки, может только администратор по имени root, который никому не сказал свой пароль.
</p>
<pre>set default=0
set timeout=5
set superusers=root

password second dnjhjq
password_pbkdf2 root grub.pbkdf2.sha512.10000.C2DDC47FC5C7341CE73DBD6728E8D29A.AA5A1DEA93E23358E908301439DEC488

menuentry "Arch Linux" --unrestricted {
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw resume=LABEL=Arch_swap
 initrd /boot/initramfs-linux.img
}

submenu "Windows" --users=second {
 set root=hd0,1
 chainloader +1
}

submenu "Boot next disk" {
 set root=hd1
 chainloader +1
}
</pre>
<h3>
<span id=".D0.92.D0.B8.D0.B7.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0"></span><span class="mw-headline" id="Визуальная_настройка">Визуальная настройка</span>
</h3>
<p>GRUB2 предоставляет возможность менять способы отображения и внешний вид меню.
</p>
<h4>
<span id=".D0.A6.D0.B2.D0.B5.D1.82.D0.B0_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Цвета_меню">Цвета меню</span>
</h4>
<p>Цвета меню GRUB2 задаются в переменных <b>menu_color_normal</b> (общие цвета текста/фона) и <b>menu_color_highlight</b> (цвета текста/фона выделенной строки). Например, цвета по умолчанию для Arch задаются в конфиге GRUB (grub.cfg) так:
</p>
<pre>set menu_color_normal=light-blue/black
set menu_color_highlight=light-cyan/blue
</pre>
<p>или в настройках <code>/etc/default/grub</code> конфигуратора <code>grub-mkconfig</code> так:
</p>
<pre>GRUB_COLOR_NORMAL="light-blue/black"
GRUB_COLOR_HIGHLIGHT="light-cyan/blue"
</pre>
<p>Список доступных в GRUB2 цветов можно найти <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/color_005fnormal.html#color_005fnormal">на сайте</a>.
</p>
<h4>
<span id=".D0.A1.D0.BA.D1.80.D1.8B.D1.82.D0.BE.D0.B5_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Скрытое_меню">Скрытое меню</span>
</h4>
<p><code>grub-mkconfig</code> умеет "скрывать" меню так, что оно появляется на экране только при нажатии клавиши ESC до истечения таймаута. Чтобы использовать эту его возможность, нужно раскомментировать в <code>/etc/default/grub</code> строки
</p>
<pre>GRUB_HIDDEN_TIMEOUT=5
GRUB_HIDDEN_TIMEOUT_QUIET=true
</pre>
<p>В конфиг GRUB (grub.cfg) для получения аналогичного результата можно добавить такой код:
</p>
<pre>set timeout=5

echo -n "Press ESC to see the menu... "
if sleep --verbose --interruptible $timeout
then set timeout=0
else unset timeout
fi
</pre>
<p>Здесь не задаётся отдельный таймаут для скрытого и видимого меню, а используется общий из переменной timeout. После вывода надписи запускается ожидание <b>sleep</b> с в выводом обратного отсчёта <code>--verbose</code> и прерыванием по ESC <code>--interruptible</code> . Если отсчёт не был прерван, таймаут уменьшается до нуля <code>set timeout=0</code>, и меню проскакивает без вывода на экран. В противном случае таймаут отключается вообще <code>unset timeout</code>, чтобы отсчёт не начался повторно после показа меню.
</p>
<p>Если вы используете в загрузчике графический режим с обоями и шрифтами, следует решить, нужно ли их инициализировать <b>до</b> начала отсчёта, или только если отсчёт прерван пользователем.
</p>
<h4>
<span id=".D0.9D.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.BE.D0.B2_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D0.B0_.D1.8D.D0.BA.D1.80.D0.B0.D0.BD.D0.B0"></span><span class="mw-headline" id="Настройка_параметров_режима_экрана">Настройка параметров режима экрана</span>
</h4>
<h5>
<span id=".D0.9F.D1.80.D0.BE.D0.B2.D0.B5.D1.80.D0.BA.D0.B0_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.BD.D1.8B.D1.85_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D0.BE.D0.B2_.D1.8D.D0.BA.D1.80.D0.B0.D0.BD.D0.B0"></span><span class="mw-headline" id="Проверка_доступных_режимов_экрана">Проверка доступных режимов экрана</span>
</h5>
<p>GRUB2 может работать в текстовом и графических режимах экрана. Актуальный список режимов доступных средствами BIOS или <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> на конкретной машине, можно получить, выполнив команду <b>videoinfo</b> в <a href="#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2">консоли загрузчика</a>. На разных машинах, с разными графическими адаптерами, прошивками и мониторами, этот список может существенно отличаться.
</p>
<p>Выбрав нужный режим желательно предварительно его проверить с помощью команды <b>videotest <i>режим</i></b> в той же консоли, примерно так:
</p>
<pre>videotest 1280x1024x32
</pre>
<p>Тестовая картинка должна отображаться на экране до нажатия на любую клавишу. Если вы видите её, значит тест пройден.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Примечание:</strong> Тест графики можно запускать <b>только</b> из <a href="#%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC">текстового режима</a>.</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> Автоматический генератор конфигурации включает графический режим по умолчанию, без проверки. Если графический режим уже задан в конфигурации неудачно и вы не видите на экране интерфейса GRUB2 при загрузке, включите <a href="#%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%80%D0%B5%D0%B6%D0%B8%D0%BC">текстовый режим</a> в настройках конфигуратора.</div>
<h5>
<span id=".D0.A2.D0.B5.D0.BA.D1.81.D1.82.D0.BE.D0.B2.D1.8B.D0.B9_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC"></span><span class="mw-headline" id="Текстовый_режим">Текстовый режим</span>
</h5>
<p>GRUB2 стартует в текстовом режиме. Если нужно вернуться в текстовый режим из графического, можно использовать в скрипте конфигурации, или прямо в <a href="#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2">консоли GRUB</a>, следующие команды:
</p>
<pre>unset lang
terminal_output console
</pre>
<p>Если вы используете автоматический конфигуратор, в настройках которого стоит <b>auto</b> по-умолчанию, загрузчик после старта будет переходить в графический режим. Чтобы изменить это поведение, можно задать для загрузчика текстовый режим:
</p>
<pre>GRUB_GFXMODE=console
</pre>
<p>или же задать текстовый режим только для загрузки ядра:
</p>
<pre>GRUB_GFXPAYLOAD_LINUX=text
</pre>
<h5>
<span id=".D0.93.D1.80.D0.B0.D1.84.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.D1.8B"></span><span class="mw-headline" id="Графические_режимы">Графические режимы</span>
</h5>
<p>GRUB2 позволяет задать режим экрана для самого загрузчика в переменной <b>gfxmode</b> , и отдельно режим, который будет использоваться ядром Linux при загрузке, через переменную <b>gfxpayload</b>
</p>
<p>Эти режимы могут быть разными:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set gfxmode=1024x768x32
set gfxpayload=1280x1024x16
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/default/grub
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">GRUB_GFXMODE=1024x768x32
GRUB_GFXPAYLOAD_LINUX=1280x1024x16
</pre>
<p>или одинаковыми:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set gfxmode=1280x1024x32
set gfxpayload=$gfxmode
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/default/grub
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">GRUB_GFXMODE=1280x1024x32
GRUB_GFXPAYLOAD_LINUX=keep
</pre>
<p>Также можно задать только один из них, не задавая другой.
</p>
<p>Режим экрана для ядра Linux будет установлен в начале загрузки ядра, никаких модулей GRUB для этого специально загружать не требуется.
</p>
<p>Вместо жесткого указания конкретного режима, можно присвоить переменной слово <b>auto</b> , и в этом случае режим будет выбран автоматически, исходя из предпочтений BIOS видеокарты и предпочтительного режима монитора. Обычно <code>auto</code> соответствует максимальному из штатных режимов монитора, но в некоторых случаях нужный режим приходится выставлять вручную.
</p>
<p>Существует также старый, специфический для BIOS, способ задать VESA-режим – через параметр ядра Linux <b>vga</b>, например <code>vga=790</code>
</p>
<p>Возможные значения для параметра vga, в зависимости от количества цветов и пикселей на экране, можно найти в этой таблице
</p>
<pre>+-----+--------------------------------------------+
|     |  640x480    800x600   1024x768   1280x1024 |
+-----+--------------------------------------------+
| 256 | 0x301=769  0x303=771  0x305=773  0x307=775 |
| 32K | 0x310=784  0x313=787  0x316=790  0x319=793 |
| 64K | 0x311=785  0x314=788  0x317=791  0x31A=794 |
| 16M | 0x312=786  0x315=789  0x318=792  0x31B=795 |
+-----+--------------------------------------------+
</pre>
<p>Однако в некоторых версиях BIOS могут использоваться и другие коды режимов. Актуальные значения можно получить из вывода команды <b>videoinfo</b> в консоли GRUB или же выполнить в терминале запущенной ОС GNU/Linux команду
</p>
<pre>sudo hwinfo --framebuffer
</pre>
<p>Команда <b>hwinfo</b> доступна в репозитории <b>community</b>.
</p>
<h4>
<span id=".D0.93.D1.80.D0.B0.D1.84.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B9_.D1.80.D0.B5.D0.B6.D0.B8.D0.BC.2C_.D1.88.D1.80.D0.B8.D1.84.D1.82_.D0.B8_.D0.BE.D0.B1.D0.BE.D0.B8"></span><span class="mw-headline" id="Графический_режим,_шрифт_и_обои">Графический режим, шрифт и обои</span>
</h4>
<p>Установка переменной <b>gfxmode</b> сама по себе НЕ переключает GRUB в графический режим. Чтобы перейти в графику, требуется:<br>
</p>
<ul>
<li>задать режим в переменной <b>gfxmode</b><br>
</li>
<li>загрузить командой <b>loadfont</b> хотя бы один шрифт<br>
</li>
<li>загрузить модуль поддержки графического режима (<b>vbe</b> для BIOS, либо <b>efi_gop</b> и <b>efi_uga</b> для <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a>)</li>
<li>и модуль графического терминала <b>gfxterm</b><br>
</li>
<li>после всего этого запустить графический терминал командой <b>terminal_output gfxterm</b><br>
</li>
</ul>
<p>GRUB2 поддерживает растровые шрифты в собственном формате pf2. Шрифт Unifont включен в пакет grub под именем <code>unicode.pf2</code>, и при установке загрузчика командой <b>grub-install</b> автоматически копируется в каталог <code>/boot/grub/fonts</code>
</p>
<p>В графическом режиме GRUB2 также позволяет установить обои командой <b>background_image</b> . Поддерживаются изображения в форматах tga, png и jpeg, для каждого из них требуется предварительно загрузить соответствующий модуль. Максимальный поддерживаемый размер изображения зависит от вашего оборудования.
</p>
<p>В настройках конфигуратора <code>/etc/default/grub</code> обои можно задать так:
</p>
<pre>GRUB_BACKGROUND=/boot/grub/themes/starfield/starfield.png
</pre>
<p>Пример графического режима с установкой дефолтного шрифта и обоев из дефолтной темы оформления. Нужные модули графического режима выбираются автоматически.
</p>
<pre>if [ "$grub_platform" = "pc" ] ; then
 insmod vbe                        # загружаем модуль для BIOS
else
 insmod efi_gop                    # или для EFI
 insmod efi_uga
fi
loadfont $prefix/fonts/unicode.pf2  # загружаем шрифт
set gfxmode=auto
insmod gfxterm                      # загружаем модуль графического терминала
terminal_output gfxterm             # эта команда запускает графику
insmod png                          # для этих обой требуется модуль png
background_image $prefix/themes/starfield/starfield.png
</pre>
<p>После установки <b>юникодного</b> шрифта можно использовать в меню GRUB кириллицу, и даже перевести на русский язык встроенные сообщения загрузчика, присвоив переменной <b>lang</b> значение <b>ru</b> .
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> Не пытайтесь использовать русский язык в текстовом режиме! Если требуется возврат в текстовый терминал командой <b>terminal_output console</b> , следует предварительно отключить русский язык командой <b>unset lang</b> , иначе вместо надписей на русском останутся одни вопросы.</div>
<p>Чтобы использовать в GRUB свои шрифты, нужно предварительно конвертировать их в формат pf2. Для этого в состав пакета grub входит утилита <b>grub-mkfont</b> . Лучше всего она работает с растровыми шрифтами в формате BDF
</p>
<pre>grub-mkfont шрифт.bdf -o шрифт.pf2
</pre>
<p>и векторными в формате TTF
</p>
<pre>grub-mkfont шрифт.ttf -s размер -o шрифт.pf2
</pre>
<h5>
<span id=".D0.A3.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0_.D1.88.D1.80.D0.B8.D1.84.D1.82.D0.B0_.D0.BD.D0.B0_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D0.B5_Terminus"></span><span class="mw-headline" id="Установка_шрифта_на_примере_Terminus">Установка шрифта на примере Terminus</span>
</h5>
<p>Пакет terminus-font для GRUB не подходит, требуется скачать с <a rel="nofollow" class="external text" href="https://terminus-font.sourceforge.net/">официального сайта</a> его исходники, они как раз в формате BDF. Далее остаётся распаковать архив, конвертировать файл со шрифтом нужного размера, и скопировать в каталог, доступный для GRUB:
</p>
<pre> $ tar xf terminus-font-4.38.tar.gz
 $ cd terminus-font-4.38/
 $ ls *.bdf
ter-u12b.bdf  ter-u14v.bdf  ter-u18b.bdf  ter-u22b.bdf  ter-u28b.bdf
ter-u12n.bdf  ter-u16b.bdf  ter-u18n.bdf  ter-u22n.bdf  ter-u28n.bdf
ter-u14b.bdf  ter-u16n.bdf  ter-u20b.bdf  ter-u24b.bdf  ter-u32b.bdf
ter-u14n.bdf  ter-u16v.bdf  ter-u20n.bdf  ter-u24n.bdf  ter-u32n.bdf
 $ grub-mkfont -v ter-u16b.bdf -o ter-u16b.pf2
Font name: Terminus Bold 16
Max width: 8
Max height: 16
Font ascent: 12
Font descent: 4
Number of glyph: 879
 $ sudo cp ter-u16b.pf2 /boot/grub/fonts/
</pre>
<p>Пример фрагмента конфига GRUB со шрифтом Terminus и русским языком:
</p>
<pre>loadfont $prefix/fonts/ter-u16b.pf2
set gfxmode=auto
set lang=ru      # включаем русский язык
insmod vbe
insmod gfxterm
terminal_output gfxterm
</pre>
<h5>
<span id=".D0.9F.D1.80.D0.BE.D0.B2.D0.B5.D1.80.D0.BA.D0.B0_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B8_.D1.88.D1.80.D0.B8.D1.84.D1.82.D0.BE.D0.B2"></span><span class="mw-headline" id="Проверка_загрузки_шрифтов">Проверка загрузки шрифтов</span>
</h5>
<p>Если шрифты должны были быть загружены, но на экране выглядят неправильно, проверить это можно в <a href="#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2">консоли GRUB</a>, с помощью команды <b>lsfonts</b>, которая выводит список успешно загруженных шрифтов.
</p>
<p>Некоторые файлы шрифтов могут быть устаревшими, и несовместимыми с установленной версией GRUB. Чтобы отдельно проверить загрузку каждого шрифта, можно попробовать вручную загружать их в консоли GRUB командами вида
</p>
<pre>loadfont $prefix/themes/тема/шрифт.pf2
</pre>
<p>При попытке загрузить несовместимый шрифт будут выдаваться сообщения об ошибках.
</p>
<h4>
<span id=".D0.93.D1.80.D0.B0.D1.84.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D1.82.D0.B5.D0.BC.D0.B0_.D0.BE.D1.84.D0.BE.D1.80.D0.BC.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F"></span><span class="mw-headline" id="Графическая_тема_оформления">Графическая тема оформления</span>
</h4>
<p>Даже после переключения в графический режим, меню GRUB отображается с помощью символов псевдографики. Альтернативный вариант отображения GRUB – <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/Theme-file-format.html#Theme-File-Manual">графические темы оформления</a>
</p>
<p>Тема включает в себя файл описания <code>theme.txt</code>, а также может содержать элементы картинок для "рисования" меню, шрифты и обои.
</p>
<p>В пакет grub входит дефолтная тема оформления, при установке командой <code>grub-install</code> она копируется в каталог <code>/boot/grub/themes/starfield/</code> . Тему для GRUB требуется прописывать в виде полного пути к файлу описания темы. В настройках конфигуратора <code>/etc/default/grub</code> это делается так:
</p>
<pre>GRUB_THEME="/boot/grub/themes/starfield/theme.txt"
</pre>
<p>В файлах конфигурации GRUB путь к файлу описания темы требуется записать в переменную <b>theme</b> ДО переключения в графический режим. Чтобы тема могла использовать указанные в ней элементы, до перехода в графику также нужно загрузить модули для использованных в ней форматов картинок (чаще всего <i>png</i>) и загрузить все имеющиеся в ней шрифты.
</p>
<p>Пример загрузки темы оформления, входящей в пакет <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span>:
</p>
<pre>dir=$prefix/themes/starfield # каталог с темой
set theme=$dir/theme.txt     # задаём файл описания
insmod regexp                # этот модуль позволяет использовать шаблоны в именах файлов
loadfont $dir/*.pf2          # загружаем по шаблону сразу все шрифты из темы
insmod png                   # модуль поддержки картинок
set gfxmode=auto
set lang=ru
insmod gfxterm
insmod vbe
terminal_output gfxterm      # включаем графику
</pre>
<p>Некоторые темы оформления GRUB можно найти в <a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/?K=grub">AUR</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Важно:</strong> Некоторые темы оформления могут быть устаревшими, и включенные в них шрифты могут оказаться <a href="#%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8_%D1%88%D1%80%D0%B8%D1%84%D1%82%D0%BE%D0%B2">несовместимыми с текущей версией GRUB</a>.<br>
Также в некоторых темах могут использоваться шрифты без поддержки кириллицы. Имейте это в виду, включая русский язык в конфигурации загрузчика</div>
<h3>
<span id=".D0.90.D0.B2.D1.82.D0.BE.D0.BC.D0.B0.D1.82.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B2_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Автоматизация_в_меню">Автоматизация в меню</span>
</h3>
<h4>
<span id=".D0.97.D0.B0.D0.BF.D0.BE.D0.BC.D0.B8.D0.BD.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B2.D1.8B.D0.B1.D1.80.D0.B0.D0.BD.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BF.D1.83.D0.BD.D0.BA.D1.82.D0.B0_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Запоминание_выбранного_пункта_меню">Запоминание выбранного пункта меню</span>
</h4>
<p>В настройках конфигуратора запоминание включается так:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/default/grub
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">GRUB_DEFAULT="saved"
GRUB_SAVEDEFAULT="true"
</pre>
<p>Пример реализации запоминания в конфиге GRUB2 приведён ниже.
</p>
<h4>
<span id=".D0.9E.D0.B4.D0.BD.D0.BE.D0.BA.D1.80.D0.B0.D1.82.D0.BD.D0.B0.D1.8F_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.B7.D0.B0.D0.B4.D0.B0.D0.BD.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B1.D0.B5.D0.B7_.D1.81.D0.BC.D0.B5.D0.BD.D1.8B_.D0.B4.D0.B5.D1.84.D0.BE.D0.BB.D1.82.D0.B0"></span><span class="mw-headline" id="Однократная_загрузка_заданного_без_смены_дефолта">Однократная загрузка заданного без смены дефолта</span>
</h4>
<p>Существует утилита <b>grub-reboot</b>, с её помощью можно из-под ОС запланировать однократную загрузку другого пункта меню, например так:
</p>
<pre>grub-reboot "Windows XP"
</pre>
<p>В генерированном меню это работает, если перед запуском <code>grub-mkconfig</code> в <code>/etc/default/grub</code> была строка
</p>
<pre>GRUB_DEFAULT="saved"
</pre>
<p>Пример реализации однократного выбора в конфиге GRUB2 приведён ниже.
</p>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D0.B0_GRUB_.D1.81_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B5.D0.B9_.D0.B7.D0.B0.D0.BF.D0.BE.D0.BC.D0.B8.D0.BD.D0.B0.D0.BD.D0.B8.D1.8F"></span><span class="mw-headline" id="Пример_конфига_GRUB_с_реализацией_запоминания">Пример конфига GRUB с реализацией запоминания</span>
</h4>
<pre>set timeout=5
set default=0
load_env # восстанавливаем переменные из файла

if [ -n "$next_entry" ] ; then   # если задан временный выбор
 set default="$next_entry"       # временно подменяем дефолт
 unset next_entry                # и очищаем временный выбор
 save_env next_entry
fi                               # временный дефолт не сохраняем

export default    # на случай использования savedef внутри submenu

function savedef {     # Создаём функцию по имени savedef
 if [ -n "$1" ]               # выбор берём либо
  then def="$1"               # из первого параметра
  else def="$chosen"          # либо из $chosen, переменной GRUB
 fi                           # с заголовком выбранного пункта меню
 if [ "$def" != "$default" ] ; then   # Если выбор отличается
  set default="$def"                  # от текущего дефолта -
  save_env default                    # сохраняем его
 fi
 unset def
}                    # конец функции

menuentry "Arch Linux" {
 savedef
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw
 initrd /boot/initramfs-linux.img
}

menuentry "Arch Linux fallback" {
 savedef "Arch Linux" # в следующий раз выберется "Arch Linux"
 linux /boot/vmlinuz-linux root=LABEL=Arch_root rw
 initrd /boot/initramfs-linux-fallback.img
}

submenu "Windows XP" {
 savedef
 set root=hd0,1
 ntldr /ntldr
}
</pre>
<p>В данном примере используется предоставляемая GRUB2 возможность сохранения переменных между сеансами. 
</p>
<p>Команда <b>load_env</b> загружает из файла все сохранённые в нём переменные.
</p>
<p>Команда <b>save_env</b> сохраняет указанные переменные в файл.
</p>
<p>В переменную <b>chosen</b> после выбора пункта меню помещается его заголовок. При выборе пунктов вложенных меню, в переменную записывается весь "путь", состоящий из последовательно выбранных заголовков, разделённых знаком "<b>&gt;</b>". Например, если в подменю "Fallback" выбран пункт "Arch linux-lts", в переменной будет <code>"Fallback&gt;Arch linux-lts"</code>.
</p>
<p>Также здесь используется объявление <i>функции</i>. Функция вызывается так же, как другие команды GRUB. При каждом вызове эта функция будет сравнивать свой параметр или заголовок выбранного пункта меню с переменной default, и если выбор отличается - записывать его в default и сохранять.
</p>
<p>Переменные сохраняются в файле <code>/boot/grub/grubenv</code> . Так как GRUB не умеет корректно модифицировать файловые системы, файл должен быть заранее создан, а длина его при перезаписи не должна меняться, поэтому конец файла до нужной длины в 1024 байта всегда заполнен символами ### . Для просмотра и изменения при загруженной ОС сохранённых в этом файле переменных, настоятельно рекомендуется использовать утилиту <b>grub-editenv</b>, либо <b>grub-reboot</b> и <b>grub-set-default</b>.
</p>
<h3>
<span id=".D0.94.D0.B8.D0.BD.D0.B0.D0.BC.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B5_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Динамическое_меню">Динамическое меню</span>
</h3>
<p>Конфиг GRUB2 это скрипт, выполняемый загрузчиком. Он действительно генерирует, а не статически описывает меню загрузчика.
</p>
<p>В этом примере загрузчик сам, "на лету", находит в /boot/ все установленные ядра Arch Linux и образы initramfs, правильно группирует их и формирует меню для их загрузки, а после выбора пункта меню запоминает его. При загрузке в параметры ядра подставляется автоматически найденный загрузчиком UUID корневого раздела.
</p>
<p>В grub.cfg пишем только ссылку. (причину см. <a href="#%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">выше</a>.)
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">. $prefix/main.cfg
</pre>
<p>Пользовательские настройки подключаются из отдельного файла <code>settings.cfg</code>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/settings.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set menu_color_normal=white/blue
set menu_color_highlight=white/black
set timeout=5
set default=0

boot=/boot
probe -s UUID -u $root    # автоматически определяем UUID корня
opts="root=UUID=$UUID rw" # и подставляем его в параметры ядра
addimg=$boot/intel-ucode.img # включаем обновление микрокода CPU intel

load_env
</pre>
<p>Центральный файл, здесь реализована функция запоминания выбранного пункта меню, сюда же подключены остальные части конфига:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/main.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># Подключаем файл настроек
. $prefix/settings.cfg

# Поддержка однократного выбора
if [ -n "$next_entry" ] ; then
 set default="$next_entry"
 unset next_entry
 save_env next_entry
fi

export default

# Описываем функцию запоминания
function savedef {
 if [ -n "$1" ]
 then def="$1"
 else def="$chosen"
 fi
 if [ "$def" != "$default" ] ; then
  set default="$def"
  save_env default
 fi
 unset def
}

# Подключаем динамическое меню
. $prefix/dynamic.cfg

# Подключаем файл для дополнительных пунктов меню, если он есть
c="$prefix/custom.cfg"
if [ -f "$c" ] ; then
 . "$c"
fi
</pre>
<p>Скрипт поиска ядер и генерации меню:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/dynamic.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">insmod regexp

initrd=initrd
if [ -n "$addimg" -a -f "$addimg" ] ; then
 initrd="$initrd $addimg"
fi

kpref="$boot/vmlinuz-"
ipref="$boot/initramfs-"

kernels=
for kfile in "$kpref"* ; do
 k=
 regexp -s k "$kpref"'(.+)' "$kfile"
 kernels="$kernels $k"
done

for ifile in "$ipref"* ; do

 kname=
 for k in $kernels; do
  if regexp "$k" "$ifile" ; then
   if ! regexp "$kname" "$k" ; then continue; fi
   head="Arch $k"
   if regexp -s s "$k"'-(.+).img' "$ifile"
   then head="$head $s"; fi
   kname="$k"
  fi
 done

 if [ -n "$kname" ] ; then
  menuentry "$head" --source="savedef
linux $kpref$kname $opts
$initrd $ifile"
 fi

done
</pre>
<h2>
<span id=".D0.9A.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D1.8C_GRUB2"></span><span class="mw-headline" id="Консоль_GRUB2">Консоль GRUB2</span>
</h2>
<p>Загрузчик GRUB2 выполняет свой файл конфигурации как шелл-подобный скрипт, состоящий из команд. Все те же команды он позволяет выполнять и в интерактивном режиме, с помощью консоли.
</p>
<h3>
<span id=".D0.9D.D0.BE.D1.80.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D1.8C"></span><span class="mw-headline" id="Нормальная_консоль">Нормальная консоль</span>
</h3>
<h4>
<span id=".D0.97.D0.B0.D0.BF.D1.83.D1.81.D0.BA_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D0.B8"></span><span class="mw-headline" id="Запуск_консоли">Запуск консоли</span>
</h4>
<p>Если вы видите в терминале GRUB2 приглашение вида <code>grub&gt;</code> , значит вы попали в его нормальную консоль.
</p>
<p>GRUB2 открывает нормальную консоль, если:
</p>
<ul>
<li>при загрузке не найден файл конфигурации <code>grub.cfg</code>;</li>
<li>файл конфигурации найден и выполнен, но в ходе его выполнения так и не было создано меню, и не была выполнена команда <b>boot</b> <i>(см. ниже)</i>, либо её выполнение завершилось неудачно;</li>
<li>в меню загрузчика нажата клавиша "<b>c</b>".</li>
</ul>
<h4>
<span id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B.2C_.D0.BF.D0.BE.D0.BB.D0.B5.D0.B7.D0.BD.D1.8B.D0.B5_.D0.B2_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D0.B8_GRUB2"></span><span class="mw-headline" id="Команды,_полезные_в_консоли_GRUB2">Команды, полезные в консоли GRUB2</span>
</h4>
<p>Кроме уже описанных в части "<a href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0">Настройка</a>", в консоли GRUB2 могут пригодиться:
</p>
<ul>
<li>Переменная <b>pager</b> . Присвоение ей единицы командой <code>pager=1</code> поможет вам полностью читать вывод следующих команд, если он не помещается на экран.</li>
<li>Команда <b>help</b> . Без параметров выводит список <b>всех</b> поддерживаемых в текущей конфигурации команд загрузчика. При вызове вида <code>help слово</code> выводит справку по командам, в которых присутствует заданное слово. Например, команда <code>help normal</code> покажет справку по командам <code>normal</code> и <code>normal_exit</code>.</li>
<li>Команда <b>ls</b> без параметров выводит список дисков и разделов, доступных в данный момент загрузчику. С ключом <b>-l</b> показывает подробные сведения о каждом из них – размер, метку, UUID и тип файловой системы. С ключами <b>-lh</b> выводит размеры в "человекочитаемом" виде. С параметром в виде диска или раздела выводит сведения только о нём, например <code>ls (hd0,1)</code> выведет сведения о первом разделе на нулевом диске.</li>
<li>Команда <b>ls</b> с параметром в виде полного пути к каталогу выводит содержимое каталога. С ключом <b>-l</b> показывает подробные ведения о каждом файле и каталоге, с ключами <b>-lh</b> выводит размеры и даты в "человекочитаемом" фромате. К примеру, команда <code>ls -lh /boot</code> подробно выведет содержимое каталога /boot на текущем <i>(в переменной root)</i> разделе, а <code>ls (hd0,1)/</code> покажет список файлов и каталогов в корневом каталоге раздела hd0,1.</li>
<li>Команда <b>set</b> без параметров. Выводит список всех переменных со значениями.</li>
<li>Команда <b>echo</b> аналогична такой же команде обычного шелла, и выводит всё, что в ней написано. Может использоваться для вывода переменных, например <code>echo $cmdpath $prefix $root</code> покажет значения трёх самых важных переменных загрузчика.</li>
<li>Команда <b>cat</b> аналогична одноимённой команде шелла, и выводит содержимое заданного файла в консоль.  Так как перенаправления ввода-вывода GRUB2 не поддерживает, использовать её можно только для просмотра текстовых файлов, например, конфига самого загрузчика, fstab, и т.д.</li>
<li>Команда <b>boot</b> запускает образ ядра, другого загрузчика, или EFI-приложения, загруженный перед этим командами <code>linux</code>, <code>initrd</code>, <code>ntldr</code>, <code>chainloader</code> и некоторыми другими. В отличии от меню GRUB, где запуск загруженных образов происходит автоматически после завершения кода пункта меню, в консоли выполнение этой команды обязательно – без неё загруженный образ сам не запустится.</li>
</ul>
<p>В нормальной консоли GRUB2 поддерживает возврат к предыдущим командам и автодополнение команд, каталогов и файлов по нажатию клавиши TAB, как в консоли Linux.
</p>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B8_Arch_Linux_.D0.B8.D0.B7_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Пример_загрузки_Arch_Linux_из_консоли_загрузчика">Пример загрузки Arch Linux из консоли загрузчика</span>
</h4>
<p>Если вы успешно установили загрузчик в корневой раздел, но забыли создать конфиг загрузчика, вы увидите меню из дефолтного конфига, но оно не будет работать. Чтобы продолжить загрузку, вы можете войти в консоль, нажав клавишу "<b>c</b>", и выполнить команды:
</p>
<pre>probe -s UUID -u $root
linux /boot/vmlinuz-linux rw root=UUID=$UUID
initrd /boot/initramfs-linux.img
boot
</pre>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B8_.D1.81_.D0.B2.D0.BD.D0.B5.D1.88.D0.BD.D0.B5.D0.B3.D0.BE_.D0.B4.D0.B8.D1.81.D0.BA.D0.B0_.D0.B8.D0.B7_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D0.B8"></span><span class="mw-headline" id="Пример_загрузки_с_внешнего_диска_из_консоли">Пример загрузки с внешнего диска из консоли</span>
</h4>
<p>Во многих версиях BIOS нет специального интерфейса для однократной загрузки с флешки. Для этого можно создать отдельный пункт меню, но на один раз проще обойтись консолью GRUB:
</p>
<pre>root=hd1
chainloader +1
boot
</pre>
<h4>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D0.B0_.D1.81_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.BE.D0.B9_.D0.B1.D0.B5.D0.B7_.D0.BC.D0.B5.D0.BD.D1.8E"></span><span class="mw-headline" id="Пример_конфига_с_загрузкой_без_меню">Пример конфига с загрузкой без меню</span>
</h4>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set timeout=3

probe -s UUID -u $root
linux /boot/vmlinuz-linux rw root=UUID=$UUID
initrd /boot/initramfs-linux.img

if sleep -vi $timeout
then boot
fi
</pre>
<p>В этом примере GRUB2 загружает с диска образы ядра и initramfs, ждёт 3 секунды, и запускает ядро.
</p>
<p>Если же в течении этих секунд пользователь нажмёт ESC, он попадёт в консоль загрузчика. Так как ядро уже загружено, для продолжения загрузки достаточно набрать команду <b>boot</b> в консоли.
</p>
<h3>
<span id=".D0.90.D0.B2.D0.B0.D1.80.D0.B8.D0.B9.D0.BD.D0.B0.D1.8F_.D0.BA.D0.BE.D0.BD.D1.81.D0.BE.D0.BB.D1.8C"></span><span class="mw-headline" id="Аварийная_консоль">Аварийная консоль</span>
</h3>
<p>Если вместо меню или "шапки" нормальной консоли вы видите при старте загрузчика сообщение об ошибке и приглашение вида <code>grub rescue&gt;</code>, значит вы попали в аварийную консоль.
</p>
<p>Аварийная консоль GRUB2 встроена в стартовый образ загрузчика, и запускается в случаях, когда GRUB2 не может самостоятельно перейти в "нормальный" режим. Такое может случиться, если ядро GRUB2 при загрузке не нашло каталог со своими файлами и модулями по пути, указанному в переменной <b>prefix</b>.
</p>
<p>Значение этой переменной обычно имеет вид <code>(диск,раздел)/путь</code>, например <code>(hd0,msdos6)/boot/grub</code>. Обозначение диска подставляется при старте загрузчика, а остальная часть <i>(начиная с запятой)</i> "зашивается" в стартовый образ ещё на этапе установки. Это значит, что после изменения любого из содержащихся в <code>$prefix</code> параметров <i>(таблицы разделов, номера раздела, пути к файлам grub)</i>, загрузчик требуется <a href="#%D0%9F%D0%B5%D1%80%D0%B5%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B0">переустанавливать</a>, в противном случае он "вывалится" в аварийную консоль.
</p>
<p>В режиме аварийной консоли GRUB2 понимает всего 4 команды: <b>set</b> , <b>unset</b> , <b>ls</b> , и <b>insmod</b> . Повтор и автодополнение не поддерживаются, команда <b>ls</b> поддерживается в урезанном виде – без ключей и с выводом в сведениях о разделах только типа файловой системы, если она опознана. По-умолчанию в стартовый образ загрузчика включается модуль для поддержки таблицы разделов и файловой системы только для того раздела, на который устанавливается GRUB2. Остальные модули должны загружаться уже из файлов, если загрузчику удастся их найти.
</p>
<p>В некоторых случаях, когда встроенных в стартовый образ модулей достаточно для продолжения загрузки в изменившихся условиях, загрузку можно продолжить, изменив в аварийной консоли переменную <code>$prefix</code>.
</p>
<p>Если вы попали в аварийную консоль, наберите для начала команду <code>set</code>. Вы увидите значения трёх главных переменных GRUB2. В переменной <b>cmdpath</b> будет обозначение диска, либо полный путь к EFI-файлу, из которого стартовал образ загрузчика. В переменной <b>prefix</b> будет тот путь, по которому должен был быть каталог с остальными файлами загрузчика. В переменной <b>root</b> будет текущий диск или раздел, скорей всего совпадающий с тем, что в <code>$prefix</code>. Попробуйте команды
</p>
<pre>ls
ls $root
ls $prefix
</pre>
<p>Если вы знаете, что делалось с диском перед тем, как GRUB показал ошибку, то возможно, вы уже догадываетесь, в чём ошибка и удастся ли её исправить.
</p>
<p>Если в переменной <code>$root</code> оказался не тот или несуществующий раздел, можно проверять командами вида <code>ls (диск,раздел)/</code> каждый раздел из тех, что вывела первая команда, пока не найдётся нужный. Если он нашелся – к примеру, оказался hd0,msdos5 вместо hd0,msdos6, и читается – запишите его в переменные:
</p>
<pre>root=hd0,5
prefix=($root)/boot/grub
</pre>
<p>Если раздел правильный, а неправильный каталог <i>(команда <code>ls $prefix</code> выдаёт ошибку или не то, что нужно)</i>, запишите в переменную правильный путь, допустим такой:
</p>
<pre>prefix=($root)/grub
</pre>
<p>Если у вас получилось найти правильный диск, раздел и каталог, и вы успешно прописали из в переменные, остаётся загрузить модуль "normal" и выполнить одноимённую команду <i>(она станет доступна после загрузки модуля)</i>, чтобы перейти в "нормальный" режим загрузчика:
</p>
<pre>insmod normal
normal
</pre>
<p>Если же из аварийной консоли не удаётся получить доступ к нужному каталогу с файлами загрузчика – увы, но больше она ничем не сможет помочь, и вам придётся обратиться к другим способам загрузки, например с внешних носителей.
</p>
<h2>
<span id=".D0.97.D0.B0.D0.BF.D1.83.D1.81.D0.BA_GRUB2_.D0.B8.D0.B7_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D1.85_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D1.87.D0.B8.D0.BA.D0.BE.D0.B2"></span><span class="mw-headline" id="Запуск_GRUB2_из_других_загрузчиков">Запуск GRUB2 из других загрузчиков</span>
</h2>
<ul>
<li>Загрузочный EFI-образ GRUB2 в режиме <a href="../ru/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI (Русский)">UEFI</a> может быть запущен так же, как любое EFI-приложение.</li>
<li>Загрузочный образ BIOS-сборки GRUB2 новых версий может быть запущен по стандарту Multiboot из других загрузчиков. См. также главу "<a href="#%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B0_%D0%B4%D0%BB%D1%8F_BIOS_%D0%B1%D0%B5%D0%B7_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8">Генерация загрузочного образа для BIOS без установки</a>".</li>
</ul>
<h3>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.B8.D0.B7_.D1.81.D1.82.D0.B0.D1.80.D1.8B.D1.85_.D0.B2.D0.B5.D1.80.D1.81.D0.B8.D0.B9_GRUB"></span><span class="mw-headline" id="Загрузка_из_старых_версий_GRUB">Загрузка из старых версий GRUB</span>
</h3>
<p>Код конфига для <a href="../en/GRUB_Legacy.html" class="mw-redirect" title="GRUB Legacy (Русский)">GRUB Legacy</a>, с загрузкой GRUB2:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">menu.lst
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">default 0
timeout 1

title       Chainload into GRUB v2
root        (hd0,7)
kernel      /boot/grub/i386-pc/core.img
</pre>
<h3>
<span id=".D0.97.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.B8.D0.B7_syslinux"></span><span class="mw-headline" id="Загрузка_из_syslinux">Загрузка из syslinux</span>
</h3>
<p><a href="../ru/Syslinux.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D1%83_(chainloading)" title="Syslinux (Русский)">Пример загрузки GRUB2</a> из syslinux приведён в <a href="../ru/Syslinux.html" title="Syslinux (Русский)">статье о нём</a>.
</p>
<h2>
<span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B_.D0.B8.D1.81.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BF.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC"></span><span class="mw-headline" id="Примеры_исправления_проблем">Примеры исправления проблем</span>
</h2>
<h3>
<span id=".D0.A1.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BE_.D0.BD.D0.B5.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.B2.D1.81.D1.82.D1.80.D0.B0.D0.B8.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D0.B2_MBR"></span><span class="mw-headline" id="Сообщение_о_невозможности_встраивания_в_MBR">Сообщение о невозможности встраивания в MBR</span>
</h3>
<pre>grub-setup: warn: This msdos-style partition label has no post-MBR gap; embedding won't be possible!
grub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.
            However, blocklists are UNRELIABLE and its use is discouraged.
grub-setup: error: If you really want blocklists, use --force.
</pre>
<p>Эта ошибка может возникнуть, когда вы попытаетесь установить в виртуальную машину VMware. Читайте больше об этом <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=581760#p581760">здесь</a>.
</p>
<p>Это также может случится, если первый раздел начинается сразу после <a href="../ru/Partitioning.html#%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C_(MBR)" class="mw-redirect" title="MBR (Русский)">MBR</a>, без необходимого места в 60 блоков перед первым разделом.
</p>
<h2>
<span id=".D0.A1.D0.BC.D0.BE.D1.82.D1.80.D0.B8.D1.82.D0.B5_.D1.82.D0.B0.D0.BA.D0.B6.D0.B5"></span><span class="mw-headline" id="Смотрите_также">Смотрите также</span>
</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ru:GNU_GRUB" class="extiw" title="wikipedia:ru:GNU GRUB">Статья о GNU GRUB на Википедии</a></li>
<li>
<a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/grub.html">Официальное руководство пользователя GRUB</a> (англ.)</li>
<li>
<a rel="nofollow" class="external text" href="https://help.ubuntu.com/community/Grub2">Статья о GRUB на Ubuntu Wiki</a> (англ.)</li>
<li>
<a rel="nofollow" class="external text" href="https://help.ubuntu.com/community/UEFIBooting">Загрузка на UEFI-системах</a> (англ.)</li>
<li>
<a href="https://en.wikipedia.org/wiki/BIOS_Boot_partition" class="extiw" title="wikipedia:BIOS Boot partition">Загрузочный раздел BIOS</a> (англ.)</li>
<li>
<a rel="nofollow" class="external text" href="https://web.archive.org/web/20160424042444/http://members.iinet.net/~herman546/p20/GRUB2%20Configuration%20File%20Commands.html#Editing_etcgrub.d05_debian_theme">Настройка GRUB</a> (англ.)</li>
<li>
<a rel="nofollow" class="external text" href="https://www.linuxjournal.com/article/4622">Загрузка с помощью GRUB</a> (англ.)</li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../ru/Category:Boot_loaders.html" title="Category:Boot loaders (Русский)">Boot loaders (Русский)</a></li>
<li><a href="../ru/Category:GNU.html" title="Category:GNU (Русский)">GNU (Русский)</a></li>
</ul>
</div></div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=GRUB_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)&amp;oldid=807588">https://wiki.archlinux.org/index.php?title=GRUB_(Русский)&amp;oldid=807588</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 6 May 2024, at 05:49.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
	<li id="footer-places-archwiki-code-of-conduct"><a href="https://terms.archlinux.org/docs/code-of-conduct/" class="extiw" title="archlinux-service-agreements:code-of-conduct">Code of conduct</a></li>
	<li id="footer-places-archwiki-terms-of-service"><a href="https://terms.archlinux.org/docs/terms-of-service/" class="extiw" title="archlinux-service-agreements:terms-of-service">Terms of service</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul>
		<li>
		<button class="cdx-button cdx-button--icon-only vector-limited-width-toggle" id=""><span class="vector-icon mw-ui-icon-fullScreen mw-ui-icon-wikimedia-fullScreen"></span>

<span>Toggle limited content width</span>
</button>
</li>
	</ul>
</div>
</body>
</html>
