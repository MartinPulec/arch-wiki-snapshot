<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-0 vector-feature-client-preferences-disabled vector-feature-client-prefs-pinned-disabled vector-feature-night-mode-disabled skin-theme-clientpref-day vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>QEMU - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.42.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-QEMU rootpage-QEMU skin-vector-2022 action-view skin--responsive">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" role="navigation" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Installation" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Installation">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">1</span>Installation</div>
		</a>
		
			<button aria-controls="toc-Installation-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Installation subsection</span>
			</button>
		
		<ul id="toc-Installation-sublist" class="vector-toc-list">
			<li id="toc-QEMU_variants" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#QEMU_variants">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">1.1</span>QEMU variants</div>
			</a>
			
			<ul id="toc-QEMU_variants-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Details_on_packages_available_in_Arch_Linux" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Details_on_packages_available_in_Arch_Linux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">1.2</span>Details on packages available in Arch Linux</div>
			</a>
			
			<ul id="toc-Details_on_packages_available_in_Arch_Linux-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Graphical_front-ends_for_QEMU" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Graphical_front-ends_for_QEMU">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">2</span>Graphical front-ends for QEMU</div>
		</a>
		
		<ul id="toc-Graphical_front-ends_for_QEMU-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Creating_new_virtualized_system" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Creating_new_virtualized_system">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">3</span>Creating new virtualized system</div>
		</a>
		
			<button aria-controls="toc-Creating_new_virtualized_system-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Creating new virtualized system subsection</span>
			</button>
		
		<ul id="toc-Creating_new_virtualized_system-sublist" class="vector-toc-list">
			<li id="toc-Creating_a_hard_disk_image" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Creating_a_hard_disk_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1</span>Creating a hard disk image</div>
			</a>
			
			<ul id="toc-Creating_a_hard_disk_image-sublist" class="vector-toc-list">
				<li id="toc-Overlay_storage_images" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Overlay_storage_images">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.1</span>Overlay storage images</div>
			</a>
			
			<ul id="toc-Overlay_storage_images-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Resizing_an_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Resizing_an_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.2</span>Resizing an image</div>
			</a>
			
			<ul id="toc-Resizing_an_image-sublist" class="vector-toc-list">
				<li id="toc-Shrinking_an_image" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Shrinking_an_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.2.1</span>Shrinking an image</div>
			</a>
			
			<ul id="toc-Shrinking_an_image-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Converting_an_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Converting_an_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.3</span>Converting an image</div>
			</a>
			
			<ul id="toc-Converting_an_image-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Preparing_the_installation_media" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Preparing_the_installation_media">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.2</span>Preparing the installation media</div>
			</a>
			
			<ul id="toc-Preparing_the_installation_media-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Installing_the_operating_system" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Installing_the_operating_system">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.3</span>Installing the operating system</div>
			</a>
			
			<ul id="toc-Installing_the_operating_system-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Running_virtualized_system" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Running_virtualized_system">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">4</span>Running virtualized system</div>
		</a>
		
			<button aria-controls="toc-Running_virtualized_system-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Running virtualized system subsection</span>
			</button>
		
		<ul id="toc-Running_virtualized_system-sublist" class="vector-toc-list">
			<li id="toc-Enabling_KVM" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Enabling_KVM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.1</span>Enabling KVM</div>
			</a>
			
			<ul id="toc-Enabling_KVM-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Enabling_IOMMU_(Intel_VT-d/AMD-Vi)_support" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Enabling_IOMMU_(Intel_VT-d/AMD-Vi)_support">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.2</span>Enabling IOMMU (Intel VT-d/AMD-Vi) support</div>
			</a>
			
			<ul id="toc-Enabling_IOMMU_(Intel_VT-d/AMD-Vi)_support-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Booting_in_UEFI_mode" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Booting_in_UEFI_mode">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3</span>Booting in UEFI mode</div>
			</a>
			
			<ul id="toc-Booting_in_UEFI_mode-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Trusted_Platform_Module_emulation" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Trusted_Platform_Module_emulation">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.4</span>Trusted Platform Module emulation</div>
			</a>
			
			<ul id="toc-Trusted_Platform_Module_emulation-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Sharing_data_between_host_and_guest" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Sharing_data_between_host_and_guest">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">5</span>Sharing data between host and guest</div>
		</a>
		
			<button aria-controls="toc-Sharing_data_between_host_and_guest-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Sharing data between host and guest subsection</span>
			</button>
		
		<ul id="toc-Sharing_data_between_host_and_guest-sublist" class="vector-toc-list">
			<li id="toc-Network" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Network">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.1</span>Network</div>
			</a>
			
			<ul id="toc-Network-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-QEMU's_port_forwarding" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#QEMU's_port_forwarding">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.2</span>QEMU's port forwarding</div>
			</a>
			
			<ul id="toc-QEMU's_port_forwarding-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-QEMU's_built-in_SMB_server" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#QEMU's_built-in_SMB_server">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.3</span>QEMU's built-in SMB server</div>
			</a>
			
			<ul id="toc-QEMU's_built-in_SMB_server-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Using_filesystem_passthrough_and_VirtFS" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Using_filesystem_passthrough_and_VirtFS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4</span>Using filesystem passthrough and VirtFS</div>
			</a>
			
			<ul id="toc-Using_filesystem_passthrough_and_VirtFS-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Host_file_sharing_with_virtiofsd" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Host_file_sharing_with_virtiofsd">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5</span>Host file sharing with virtiofsd</div>
			</a>
			
			<ul id="toc-Host_file_sharing_with_virtiofsd-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Mounting_a_partition_of_the_guest_on_the_host" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mounting_a_partition_of_the_guest_on_the_host">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6</span>Mounting a partition of the guest on the host</div>
			</a>
			
			<ul id="toc-Mounting_a_partition_of_the_guest_on_the_host-sublist" class="vector-toc-list">
				<li id="toc-Mounting_a_partition_from_a_raw_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Mounting_a_partition_from_a_raw_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1</span>Mounting a partition from a raw image</div>
			</a>
			
			<ul id="toc-Mounting_a_partition_from_a_raw_image-sublist" class="vector-toc-list">
				<li id="toc-With_manually_specifying_byte_offset" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#With_manually_specifying_byte_offset">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.1</span>With manually specifying byte offset</div>
			</a>
			
			<ul id="toc-With_manually_specifying_byte_offset-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-With_loop_module_autodetecting_partitions" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#With_loop_module_autodetecting_partitions">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.2</span>With loop module autodetecting partitions</div>
			</a>
			
			<ul id="toc-With_loop_module_autodetecting_partitions-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-With_kpartx" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#With_kpartx">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.3</span>With kpartx</div>
			</a>
			
			<ul id="toc-With_kpartx-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Mounting_a_partition_from_a_qcow2_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Mounting_a_partition_from_a_qcow2_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.2</span>Mounting a partition from a qcow2 image</div>
			</a>
			
			<ul id="toc-Mounting_a_partition_from_a_qcow2_image-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7</span>Using any real partition as the single primary partition of a hard disk image</div>
			</a>
			
			<ul id="toc-Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image-sublist" class="vector-toc-list">
				<li id="toc-Specifying_kernel_and_initrd_manually" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Specifying_kernel_and_initrd_manually">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.1</span>Specifying kernel and initrd manually</div>
			</a>
			
			<ul id="toc-Specifying_kernel_and_initrd_manually-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Simulating_a_virtual_disk_with_MBR" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Simulating_a_virtual_disk_with_MBR">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2</span>Simulating a virtual disk with MBR</div>
			</a>
			
			<ul id="toc-Simulating_a_virtual_disk_with_MBR-sublist" class="vector-toc-list">
				<li id="toc-Using_the_device-mapper" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Using_the_device-mapper">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.1</span>Using the device-mapper</div>
			</a>
			
			<ul id="toc-Using_the_device-mapper-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Using_a_linear_RAID" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Using_a_linear_RAID">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.2</span>Using a linear RAID</div>
			</a>
			
			<ul id="toc-Using_a_linear_RAID-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Using_a_Network_Block_Device" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Using_a_Network_Block_Device">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.3</span>Using a Network Block Device</div>
			</a>
			
			<ul id="toc-Using_a_Network_Block_Device-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Using_an_entire_physical_disk_device_inside_the_virtual_machine" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Using_an_entire_physical_disk_device_inside_the_virtual_machine">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8</span>Using an entire physical disk device inside the virtual machine</div>
			</a>
			
			<ul id="toc-Using_an_entire_physical_disk_device_inside_the_virtual_machine-sublist" class="vector-toc-list">
				<li id="toc-Windows_virtual_machine_boot_prerequisites" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Windows_virtual_machine_boot_prerequisites">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.1</span>Windows virtual machine boot prerequisites</div>
			</a>
			
			<ul id="toc-Windows_virtual_machine_boot_prerequisites-sublist" class="vector-toc-list">
				<li id="toc-Set_up_the_windows_disk_interface_drivers" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Set_up_the_windows_disk_interface_drivers">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.1.1</span>Set up the windows disk interface drivers</div>
			</a>
			
			<ul id="toc-Set_up_the_windows_disk_interface_drivers-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Find_the_unique_path_of_your_disk" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Find_the_unique_path_of_your_disk">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.2</span>Find the unique path of your disk</div>
			</a>
			
			<ul id="toc-Find_the_unique_path_of_your_disk-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Add_the_disk_in_QEMU_CLI" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Add_the_disk_in_QEMU_CLI">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.3</span>Add the disk in QEMU CLI</div>
			</a>
			
			<ul id="toc-Add_the_disk_in_QEMU_CLI-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Add_the_disk_in_libvirt" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Add_the_disk_in_libvirt">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.4</span>Add the disk in libvirt</div>
			</a>
			
			<ul id="toc-Add_the_disk_in_libvirt-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Add_the_disk_in_virt-manager" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Add_the_disk_in_virt-manager">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.5</span>Add the disk in virt-manager</div>
			</a>
			
			<ul id="toc-Add_the_disk_in_virt-manager-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Networking" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Networking">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">6</span>Networking</div>
		</a>
		
			<button aria-controls="toc-Networking-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Networking subsection</span>
			</button>
		
		<ul id="toc-Networking-sublist" class="vector-toc-list">
			<li id="toc-Link-level_address_caveat" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Link-level_address_caveat">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1</span>Link-level address caveat</div>
			</a>
			
			<ul id="toc-Link-level_address_caveat-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-User-mode_networking" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#User-mode_networking">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.2</span>User-mode networking</div>
			</a>
			
			<ul id="toc-User-mode_networking-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Tap_networking_with_QEMU" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Tap_networking_with_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3</span>Tap networking with QEMU</div>
			</a>
			
			<ul id="toc-Tap_networking_with_QEMU-sublist" class="vector-toc-list">
				<li id="toc-Host-only_networking" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Host-only_networking">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.1</span>Host-only networking</div>
			</a>
			
			<ul id="toc-Host-only_networking-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Internal_networking" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Internal_networking">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.2</span>Internal networking</div>
			</a>
			
			<ul id="toc-Internal_networking-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Bridged_networking_using_qemu-bridge-helper" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Bridged_networking_using_qemu-bridge-helper">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.3</span>Bridged networking using qemu-bridge-helper</div>
			</a>
			
			<ul id="toc-Bridged_networking_using_qemu-bridge-helper-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Creating_bridge_manually" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Creating_bridge_manually">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.4</span>Creating bridge manually</div>
			</a>
			
			<ul id="toc-Creating_bridge_manually-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Network_sharing_between_physical_device_and_a_Tap_device_through_iptables" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Network_sharing_between_physical_device_and_a_Tap_device_through_iptables">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.5</span>Network sharing between physical device and a Tap device through iptables</div>
			</a>
			
			<ul id="toc-Network_sharing_between_physical_device_and_a_Tap_device_through_iptables-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Networking_with_VDE2" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Networking_with_VDE2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4</span>Networking with VDE2</div>
			</a>
			
			<ul id="toc-Networking_with_VDE2-sublist" class="vector-toc-list">
				<li id="toc-What_is_VDE?" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#What_is_VDE?">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.1</span>What is VDE?</div>
			</a>
			
			<ul id="toc-What_is_VDE?-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Basics" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Basics">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.2</span>Basics</div>
			</a>
			
			<ul id="toc-Basics-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Startup_scripts" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Startup_scripts">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.3</span>Startup scripts</div>
			</a>
			
			<ul id="toc-Startup_scripts-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Alternative_method" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Alternative_method">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.4</span>Alternative method</div>
			</a>
			
			<ul id="toc-Alternative_method-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-VDE2_Bridge" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#VDE2_Bridge">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5</span>VDE2 Bridge</div>
			</a>
			
			<ul id="toc-VDE2_Bridge-sublist" class="vector-toc-list">
				<li id="toc-Basics_2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Basics_2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5.1</span>Basics</div>
			</a>
			
			<ul id="toc-Basics_2-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Startup_scripts_2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Startup_scripts_2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5.2</span>Startup scripts</div>
			</a>
			
			<ul id="toc-Startup_scripts_2-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Shorthand_configuration" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Shorthand_configuration">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.6</span>Shorthand configuration</div>
			</a>
			
			<ul id="toc-Shorthand_configuration-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Graphic_card" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Graphic_card">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">7</span>Graphic card</div>
		</a>
		
			<button aria-controls="toc-Graphic_card-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Graphic card subsection</span>
			</button>
		
		<ul id="toc-Graphic_card-sublist" class="vector-toc-list">
			<li id="toc-std" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#std">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.1</span>std</div>
			</a>
			
			<ul id="toc-std-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-qxl" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#qxl">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.2</span>qxl</div>
			</a>
			
			<ul id="toc-qxl-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-vmware" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#vmware">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.3</span>vmware</div>
			</a>
			
			<ul id="toc-vmware-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-virtio" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#virtio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.4</span>virtio</div>
			</a>
			
			<ul id="toc-virtio-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-cirrus" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#cirrus">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.5</span>cirrus</div>
			</a>
			
			<ul id="toc-cirrus-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-none" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#none">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.6</span>none</div>
			</a>
			
			<ul id="toc-none-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-SPICE" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#SPICE">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">8</span>SPICE</div>
		</a>
		
			<button aria-controls="toc-SPICE-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle SPICE subsection</span>
			</button>
		
		<ul id="toc-SPICE-sublist" class="vector-toc-list">
			<li id="toc-Enabling_SPICE_support_on_the_host" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Enabling_SPICE_support_on_the_host">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.1</span>Enabling SPICE support on the host</div>
			</a>
			
			<ul id="toc-Enabling_SPICE_support_on_the_host-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Connecting_to_the_guest_with_a_SPICE_client" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Connecting_to_the_guest_with_a_SPICE_client">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2</span>Connecting to the guest with a SPICE client</div>
			</a>
			
			<ul id="toc-Connecting_to_the_guest_with_a_SPICE_client-sublist" class="vector-toc-list">
				<li id="toc-Manually_running_a_SPICE_client" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Manually_running_a_SPICE_client">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2.1</span>Manually running a SPICE client</div>
			</a>
			
			<ul id="toc-Manually_running_a_SPICE_client-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Running_a_SPICE_client_with_QEMU" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Running_a_SPICE_client_with_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2.2</span>Running a SPICE client with QEMU</div>
			</a>
			
			<ul id="toc-Running_a_SPICE_client_with_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Enabling_SPICE_support_on_the_guest" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Enabling_SPICE_support_on_the_guest">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.3</span>Enabling SPICE support on the guest</div>
			</a>
			
			<ul id="toc-Enabling_SPICE_support_on_the_guest-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Password_authentication_with_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Password_authentication_with_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.4</span>Password authentication with SPICE</div>
			</a>
			
			<ul id="toc-Password_authentication_with_SPICE-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-TLS_encrypted_communication_with_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#TLS_encrypted_communication_with_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.5</span>TLS encrypted communication with SPICE</div>
			</a>
			
			<ul id="toc-TLS_encrypted_communication_with_SPICE-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-VNC" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#VNC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">9</span>VNC</div>
		</a>
		
			<button aria-controls="toc-VNC-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle VNC subsection</span>
			</button>
		
		<ul id="toc-VNC-sublist" class="vector-toc-list">
			<li id="toc-Basic_password_authentication" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Basic_password_authentication">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">9.1</span>Basic password authentication</div>
			</a>
			
			<ul id="toc-Basic_password_authentication-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Audio" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Audio">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">10</span>Audio</div>
		</a>
		
			<button aria-controls="toc-Audio-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Audio subsection</span>
			</button>
		
		<ul id="toc-Audio-sublist" class="vector-toc-list">
			<li id="toc-Creating_an_audio_backend" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Creating_an_audio_backend">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.1</span>Creating an audio backend</div>
			</a>
			
			<ul id="toc-Creating_an_audio_backend-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Using_the_audio_backend" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Using_the_audio_backend">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2</span>Using the audio backend</div>
			</a>
			
			<ul id="toc-Using_the_audio_backend-sublist" class="vector-toc-list">
				<li id="toc-Intel_HD_Audio" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Intel_HD_Audio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2.1</span>Intel HD Audio</div>
			</a>
			
			<ul id="toc-Intel_HD_Audio-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Intel_82801AA_AC97" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Intel_82801AA_AC97">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2.2</span>Intel 82801AA AC97</div>
			</a>
			
			<ul id="toc-Intel_82801AA_AC97-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-VirtIO_sound" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#VirtIO_sound">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2.3</span>VirtIO sound</div>
			</a>
			
			<ul id="toc-VirtIO_sound-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Installing_virtio_drivers" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Installing_virtio_drivers">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">11</span>Installing virtio drivers</div>
		</a>
		
			<button aria-controls="toc-Installing_virtio_drivers-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Installing virtio drivers subsection</span>
			</button>
		
		<ul id="toc-Installing_virtio_drivers-sublist" class="vector-toc-list">
			<li id="toc-Preparing_an_Arch_Linux_guest" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Preparing_an_Arch_Linux_guest">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.1</span>Preparing an Arch Linux guest</div>
			</a>
			
			<ul id="toc-Preparing_an_Arch_Linux_guest-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Preparing_a_Windows_guest" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Preparing_a_Windows_guest">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2</span>Preparing a Windows guest</div>
			</a>
			
			<ul id="toc-Preparing_a_Windows_guest-sublist" class="vector-toc-list">
				<li id="toc-Virtio_drivers_for_Windows" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Virtio_drivers_for_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.1</span>Virtio drivers for Windows</div>
			</a>
			
			<ul id="toc-Virtio_drivers_for_Windows-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Block_device_drivers" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Block_device_drivers">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2</span>Block device drivers</div>
			</a>
			
			<ul id="toc-Block_device_drivers-sublist" class="vector-toc-list">
				<li id="toc-New_Install_of_Windows" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#New_Install_of_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2.1</span>New Install of Windows</div>
			</a>
			
			<ul id="toc-New_Install_of_Windows-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Change_existing_Windows_virtual_machine_to_use_virtio" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Change_existing_Windows_virtual_machine_to_use_virtio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2.2</span>Change existing Windows virtual machine to use virtio</div>
			</a>
			
			<ul id="toc-Change_existing_Windows_virtual_machine_to_use_virtio-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Network_drivers" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Network_drivers">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.3</span>Network drivers</div>
			</a>
			
			<ul id="toc-Network_drivers-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Balloon_driver" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Balloon_driver">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.4</span>Balloon driver</div>
			</a>
			
			<ul id="toc-Balloon_driver-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Preparing_a_FreeBSD_guest" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Preparing_a_FreeBSD_guest">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.3</span>Preparing a FreeBSD guest</div>
			</a>
			
			<ul id="toc-Preparing_a_FreeBSD_guest-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-QEMU_monitor" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#QEMU_monitor">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">12</span>QEMU monitor</div>
		</a>
		
			<button aria-controls="toc-QEMU_monitor-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle QEMU monitor subsection</span>
			</button>
		
		<ul id="toc-QEMU_monitor-sublist" class="vector-toc-list">
			<li id="toc-Accessing_the_monitor_console" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Accessing_the_monitor_console">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1</span>Accessing the monitor console</div>
			</a>
			
			<ul id="toc-Accessing_the_monitor_console-sublist" class="vector-toc-list">
				<li id="toc-Graphical_view" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Graphical_view">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.1</span>Graphical view</div>
			</a>
			
			<ul id="toc-Graphical_view-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Telnet" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Telnet">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.2</span>Telnet</div>
			</a>
			
			<ul id="toc-Telnet-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-UNIX_socket" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#UNIX_socket">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.3</span>UNIX socket</div>
			</a>
			
			<ul id="toc-UNIX_socket-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-TCP" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#TCP">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.4</span>TCP</div>
			</a>
			
			<ul id="toc-TCP-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Standard_I/O" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Standard_I/O">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.5</span>Standard I/O</div>
			</a>
			
			<ul id="toc-Standard_I/O-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Sending_keyboard_presses_to_the_virtual_machine_using_the_monitor_console" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Sending_keyboard_presses_to_the_virtual_machine_using_the_monitor_console">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.2</span>Sending keyboard presses to the virtual machine using the monitor console</div>
			</a>
			
			<ul id="toc-Sending_keyboard_presses_to_the_virtual_machine_using_the_monitor_console-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Creating_and_managing_snapshots_via_the_monitor_console" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Creating_and_managing_snapshots_via_the_monitor_console">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.3</span>Creating and managing snapshots via the monitor console</div>
			</a>
			
			<ul id="toc-Creating_and_managing_snapshots_via_the_monitor_console-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Running_the_virtual_machine_in_immutable_mode" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Running_the_virtual_machine_in_immutable_mode">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.4</span>Running the virtual machine in immutable mode</div>
			</a>
			
			<ul id="toc-Running_the_virtual_machine_in_immutable_mode-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pause_and_power_options_via_the_monitor_console" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pause_and_power_options_via_the_monitor_console">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.5</span>Pause and power options via the monitor console</div>
			</a>
			
			<ul id="toc-Pause_and_power_options_via_the_monitor_console-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Taking_screenshots_of_the_virtual_machine" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Taking_screenshots_of_the_virtual_machine">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.6</span>Taking screenshots of the virtual machine</div>
			</a>
			
			<ul id="toc-Taking_screenshots_of_the_virtual_machine-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-QEMU_machine_protocol" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#QEMU_machine_protocol">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">13</span>QEMU machine protocol</div>
		</a>
		
			<button aria-controls="toc-QEMU_machine_protocol-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle QEMU machine protocol subsection</span>
			</button>
		
		<ul id="toc-QEMU_machine_protocol-sublist" class="vector-toc-list">
			<li id="toc-Start_QMP" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Start_QMP">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.1</span>Start QMP</div>
			</a>
			
			<ul id="toc-Start_QMP-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Live_merging_of_child_image_into_parent_image" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Live_merging_of_child_image_into_parent_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.2</span>Live merging of child image into parent image</div>
			</a>
			
			<ul id="toc-Live_merging_of_child_image_into_parent_image-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Live_creation_of_a_new_snapshot" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Live_creation_of_a_new_snapshot">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.3</span>Live creation of a new snapshot</div>
			</a>
			
			<ul id="toc-Live_creation_of_a_new_snapshot-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Tips_and_tricks" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Tips_and_tricks">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">14</span>Tips and tricks</div>
		</a>
		
			<button aria-controls="toc-Tips_and_tricks-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Tips and tricks subsection</span>
			</button>
		
		<ul id="toc-Tips_and_tricks-sublist" class="vector-toc-list">
			<li id="toc-Improve_virtual_machine_performance" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Improve_virtual_machine_performance">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.1</span>Improve virtual machine performance</div>
			</a>
			
			<ul id="toc-Improve_virtual_machine_performance-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Starting_QEMU_virtual_machines_on_boot" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Starting_QEMU_virtual_machines_on_boot">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2</span>Starting QEMU virtual machines on boot</div>
			</a>
			
			<ul id="toc-Starting_QEMU_virtual_machines_on_boot-sublist" class="vector-toc-list">
				<li id="toc-With_libvirt" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#With_libvirt">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2.1</span>With libvirt</div>
			</a>
			
			<ul id="toc-With_libvirt-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-With_systemd_service" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#With_systemd_service">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2.2</span>With systemd service</div>
			</a>
			
			<ul id="toc-With_systemd_service-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Mouse_integration" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mouse_integration">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.3</span>Mouse integration</div>
			</a>
			
			<ul id="toc-Mouse_integration-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pass-through_host_USB_device" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pass-through_host_USB_device">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.4</span>Pass-through host USB device</div>
			</a>
			
			<ul id="toc-Pass-through_host_USB_device-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-USB_redirection_with_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#USB_redirection_with_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.5</span>USB redirection with SPICE</div>
			</a>
			
			<ul id="toc-USB_redirection_with_SPICE-sublist" class="vector-toc-list">
				<li id="toc-Automatic_USB_forwarding_with_udev" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Automatic_USB_forwarding_with_udev">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.5.1</span>Automatic USB forwarding with udev</div>
			</a>
			
			<ul id="toc-Automatic_USB_forwarding_with_udev-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Enabling_KSM" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Enabling_KSM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.6</span>Enabling KSM</div>
			</a>
			
			<ul id="toc-Enabling_KSM-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Multi-monitor_support" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Multi-monitor_support">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.7</span>Multi-monitor support</div>
			</a>
			
			<ul id="toc-Multi-monitor_support-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Custom_display_resolution" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Custom_display_resolution">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.8</span>Custom display resolution</div>
			</a>
			
			<ul id="toc-Custom_display_resolution-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Copy_and_paste" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Copy_and_paste">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.9</span>Copy and paste</div>
			</a>
			
			<ul id="toc-Copy_and_paste-sublist" class="vector-toc-list">
				<li id="toc-SPICE_2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#SPICE_2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.9.1</span>SPICE</div>
			</a>
			
			<ul id="toc-SPICE_2-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-qemu-vdagent" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#qemu-vdagent">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.9.2</span>qemu-vdagent</div>
			</a>
			
			<ul id="toc-qemu-vdagent-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Windows-specific_notes" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Windows-specific_notes">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10</span>Windows-specific notes</div>
			</a>
			
			<ul id="toc-Windows-specific_notes-sublist" class="vector-toc-list">
				<li id="toc-Fast_startup" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Fast_startup">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10.1</span>Fast startup</div>
			</a>
			
			<ul id="toc-Fast_startup-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Remote_Desktop_Protocol" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Remote_Desktop_Protocol">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10.2</span>Remote Desktop Protocol</div>
			</a>
			
			<ul id="toc-Remote_Desktop_Protocol-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Clone_Linux_system_installed_on_physical_equipment" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Clone_Linux_system_installed_on_physical_equipment">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.11</span>Clone Linux system installed on physical equipment</div>
			</a>
			
			<ul id="toc-Clone_Linux_system_installed_on_physical_equipment-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Chrooting_into_arm/arm64_environment_from_x86_64" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Chrooting_into_arm/arm64_environment_from_x86_64">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.12</span>Chrooting into arm/arm64 environment from x86_64</div>
			</a>
			
			<ul id="toc-Chrooting_into_arm/arm64_environment_from_x86_64-sublist" class="vector-toc-list">
				<li id="toc-sudo_in_chroot" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#sudo_in_chroot">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.12.1</span>sudo in chroot</div>
			</a>
			
			<ul id="toc-sudo_in_chroot-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Not_grabbing_mouse_input" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Not_grabbing_mouse_input">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.13</span>Not grabbing mouse input</div>
			</a>
			
			<ul id="toc-Not_grabbing_mouse_input-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Troubleshooting" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Troubleshooting">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">15</span>Troubleshooting</div>
		</a>
		
			<button aria-controls="toc-Troubleshooting-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Troubleshooting subsection</span>
			</button>
		
		<ul id="toc-Troubleshooting-sublist" class="vector-toc-list">
			<li id="toc-Mouse_cursor_is_jittery_or_erratic" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mouse_cursor_is_jittery_or_erratic">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.1</span>Mouse cursor is jittery or erratic</div>
			</a>
			
			<ul id="toc-Mouse_cursor_is_jittery_or_erratic-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-No_visible_Cursor" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#No_visible_Cursor">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.2</span>No visible Cursor</div>
			</a>
			
			<ul id="toc-No_visible_Cursor-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Two_different_mouse_cursors_are_visible" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Two_different_mouse_cursors_are_visible">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.3</span>Two different mouse cursors are visible</div>
			</a>
			
			<ul id="toc-Two_different_mouse_cursors_are_visible-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Keyboard_issues_when_using_VNC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Keyboard_issues_when_using_VNC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.4</span>Keyboard issues when using VNC</div>
			</a>
			
			<ul id="toc-Keyboard_issues_when_using_VNC-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Keyboard_seems_broken_or_the_arrow_keys_do_not_work" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Keyboard_seems_broken_or_the_arrow_keys_do_not_work">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.5</span>Keyboard seems broken or the arrow keys do not work</div>
			</a>
			
			<ul id="toc-Keyboard_seems_broken_or_the_arrow_keys_do_not_work-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Could_not_read_keymap_file" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Could_not_read_keymap_file">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.6</span>Could not read keymap file</div>
			</a>
			
			<ul id="toc-Could_not_read_keymap_file-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Guest_display_stretches_on_window_resize" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Guest_display_stretches_on_window_resize">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.7</span>Guest display stretches on window resize</div>
			</a>
			
			<ul id="toc-Guest_display_stretches_on_window_resize-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.8</span>ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</div>
			</a>
			
			<ul id="toc-ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-libgfapi_error_message" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#libgfapi_error_message">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.9</span>libgfapi error message</div>
			</a>
			
			<ul id="toc-libgfapi_error_message-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Kernel_panic_on_LIVE-environments" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Kernel_panic_on_LIVE-environments">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.10</span>Kernel panic on LIVE-environments</div>
			</a>
			
			<ul id="toc-Kernel_panic_on_LIVE-environments-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Windows_7_guest_suffers_low-quality_sound" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Windows_7_guest_suffers_low-quality_sound">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.11</span>Windows 7 guest suffers low-quality sound</div>
			</a>
			
			<ul id="toc-Windows_7_guest_suffers_low-quality_sound-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Could_not_access_KVM_kernel_module:_Permission_denied" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Could_not_access_KVM_kernel_module:_Permission_denied">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.12</span>Could not access KVM kernel module: Permission denied</div>
			</a>
			
			<ul id="toc-Could_not_access_KVM_kernel_module:_Permission_denied-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id='toc-"System_Thread_Exception_Not_Handled"_when_booting_a_Windows_virtual_machine' class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href='#"System_Thread_Exception_Not_Handled"_when_booting_a_Windows_virtual_machine'>
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.13</span>"System Thread Exception Not Handled" when booting a Windows virtual machine</div>
			</a>
			
			<ul id='toc-"System_Thread_Exception_Not_Handled"_when_booting_a_Windows_virtual_machine-sublist' class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Certain_Windows_games/applications_crashing/causing_a_bluescreen" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Certain_Windows_games/applications_crashing/causing_a_bluescreen">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.14</span>Certain Windows games/applications crashing/causing a bluescreen</div>
			</a>
			
			<ul id="toc-Certain_Windows_games/applications_crashing/causing_a_bluescreen-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-High_interrupt_latency_and_microstuttering" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#High_interrupt_latency_and_microstuttering">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.15</span>High interrupt latency and microstuttering</div>
			</a>
			
			<ul id="toc-High_interrupt_latency_and_microstuttering-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-QXL_video_causes_low_resolution" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#QXL_video_causes_low_resolution">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.16</span>QXL video causes low resolution</div>
			</a>
			
			<ul id="toc-QXL_video_causes_low_resolution-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Virtual_machine_not_booting_when_using_a_Secure_Boot_enabled_OVMF" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Virtual_machine_not_booting_when_using_a_Secure_Boot_enabled_OVMF">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.17</span>Virtual machine not booting when using a Secure Boot enabled OVMF</div>
			</a>
			
			<ul id="toc-Virtual_machine_not_booting_when_using_a_Secure_Boot_enabled_OVMF-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Virtual_machine_not_booting_into_Arch_ISO" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Virtual_machine_not_booting_into_Arch_ISO">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.18</span>Virtual machine not booting into Arch ISO</div>
			</a>
			
			<ul id="toc-Virtual_machine_not_booting_into_Arch_ISO-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Guest_CPU_interrupts_are_not_firing" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Guest_CPU_interrupts_are_not_firing">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.19</span>Guest CPU interrupts are not firing</div>
			</a>
			
			<ul id="toc-Guest_CPU_interrupts_are_not_firing-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-KDE_with_sddm_does_not_start_spice-vdagent_at_login_automatically" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#KDE_with_sddm_does_not_start_spice-vdagent_at_login_automatically">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.20</span>KDE with sddm does not start spice-vdagent at login automatically</div>
			</a>
			
			<ul id="toc-KDE_with_sddm_does_not_start_spice-vdagent_at_login_automatically-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Error_starting_domain:_Requested_operation_is_not_valid:_network_'default'_is_not_active" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Error_starting_domain:_Requested_operation_is_not_valid:_network_'default'_is_not_active">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.21</span>Error starting domain: Requested operation is not valid: network 'default' is not active</div>
			</a>
			
			<ul id="toc-Error_starting_domain:_Requested_operation_is_not_valid:_network_'default'_is_not_active-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-See_also" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#See_also">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">16</span>See also</div>
		</a>
		
		<ul id="toc-See_also-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body" role="main" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar">
					<nav role="navigation" aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">QEMU</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang">
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 5 languages">
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-5" aria-hidden="true"><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">5 languages</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-de mw-list-item"><a href="https://wiki.archlinux.de/title/QEMU" title="QEMU – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li>
<li class="interlanguage-link interwiki-es mw-list-item"><a href="../es/QEMU.html" title="QEMU – español" lang="es" hreflang="es" class="interlanguage-link-target"><span>Español</span></a></li>
<li class="interlanguage-link interwiki-fr mw-list-item"><a href="../fr/QEMU.html" title="QEMU – français" lang="fr" hreflang="fr" class="interlanguage-link-target"><span>Français</span></a></li>
<li class="interlanguage-link interwiki-ja mw-list-item"><a href="https://wiki.archlinux.jp/index.php/QEMU" title="QEMU – 日本語" lang="ja" hreflang="ja" class="interlanguage-link-target"><span>日本語</span></a></li>
<li class="interlanguage-link interwiki-zh-hans mw-list-item"><a href="https://wiki.archlinuxcn.org/wiki/QEMU" title="QEMU – 中文（简体）" lang="zh-Hans" hreflang="zh-Hans" class="interlanguage-link-target"><span>中文（简体）</span></a></li>
			</ul>
			
		</div>

	</div>
</div>
</header>
				<div class="vector-column-end">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-client-prefs-landmark" aria-label="Appearance">
						</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content">
<div class="mw-content-ltr mw-parser-output" lang="en" dir="ltr">
<div class="archwiki-template-meta-related-articles">
<p>Related articles</p>
<ul>
<li><a href="../en/Category:Hypervisors.html" title="Category:Hypervisors">Category:Hypervisors</a></li>
<li><a href="../en/Libvirt.html" title="Libvirt">Libvirt</a></li>
<li><a href="../en/QEMU/Guest_graphics_acceleration.html" title="QEMU/Guest graphics acceleration">QEMU/Guest graphics acceleration</a></li>
<li><a href="../en/PCI_passthrough_via_OVMF.html" title="PCI passthrough via OVMF">PCI passthrough via OVMF</a></li>
</ul>
</div>
<p>According to the <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Main_Page">QEMU about page</a>, "QEMU is a generic and open source machine emulator and virtualizer."
</p>
<p>When used as a machine emulator, QEMU can run OSes and programs made for one machine (e.g. an ARM board) on a different machine (e.g. your x86 PC). By using dynamic translation, it achieves very good performance.
</p>
<p>QEMU can use other hypervisors like <a href="../en/Xen.html" title="Xen">Xen</a> or <a href="../en/KVM.html" title="KVM">KVM</a> to use CPU extensions (<a href="https://en.wikipedia.org/wiki/Hardware-assisted_virtualization" class="extiw" title="wikipedia:Hardware-assisted virtualization">HVM</a>) for virtualization. When used as a virtualizer, QEMU achieves near native performances by executing the guest code directly on the host CPU.
</p>
<meta property="mw:PageProp/toc">
<h2><span class="mw-headline" id="Installation">Installation</span></h2>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">Install</a> the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-full">qemu-full</a></span> package (or <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-base">qemu-base</a></span> for the version without GUI and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-desktop">qemu-desktop</a></span> for the version with only x86_64 emulation by default) and below optional packages for your needs:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span> - <a href="../en/Glusterfs.html" title="Glusterfs">Glusterfs</a> block support</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> - <a href="../en/ISCSI.html" title="ISCSI">iSCSI</a> block support</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=samba">samba</a></span> - <a href="../en/Samba.html" title="Samba">SMB/CIFS</a> server support</li>
</ul>
<p>Alternatively, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> exists as a usermode and static variant.
</p>
<h3><span class="mw-headline" id="QEMU_variants">QEMU variants</span></h3>
<p>QEMU is offered in several variants suited for different use cases.
</p>
<p>As a first classification, QEMU is offered in full-system and usermode emulation modes:
</p>
<dl>
<dt>Full-system emulation</dt>
<dd>In this mode, QEMU emulates a full system, including one or several processors and various peripherals. It is more accurate but slower, and does not require the emulated OS to be Linux.</dd>
<dd>QEMU commands for full-system emulation are named <code>qemu-system-<i>target_architecture</i></code>, e.g. <code>qemu-system-x86_64</code> for emulating <a href="https://en.wikipedia.org/wiki/x86_64" class="extiw" title="wikipedia:x86 64">x86_64</a> CPUs, <code>qemu-system-i386</code> for Intel <a href="https://en.wikipedia.org/wiki/i386" class="extiw" title="wikipedia:i386">32-bit x86</a> CPUs, <code>qemu-system-arm</code> for <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#32-bit_architecture" class="extiw" title="wikipedia:ARM architecture family">ARM (32 bits)</a>, <code>qemu-system-aarch64</code> for <a href="https://en.wikipedia.org/wiki/AArch64" class="extiw" title="wikipedia:AArch64">ARM64</a>, etc.</dd>
<dd>If the target architecture matches the host CPU, this mode may still benefit from a significant speedup by using a hypervisor like <a href="#Enabling_KVM">KVM</a> or Xen.</dd>
<dt><a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/user/main.html">Usermode emulation</a></dt>
<dd>In this mode, QEMU is able to invoke a Linux executable compiled for a (potentially) different architecture by leveraging the host system resources. There may be compatibility issues, e.g. some features may not be implemented, dynamically linked executables will not work out of the box (see <a href="#Chrooting_into_arm/arm64_environment_from_x86_64">#Chrooting into arm/arm64 environment from x86_64</a> to address this) and only Linux is supported (although <a rel="nofollow" class="external text" href="https://wiki.winehq.org/Emulation">Wine may be used</a> for running Windows executables).</dd>
<dd>QEMU commands for usermode emulation are named <code>qemu-<i>target_architecture</i></code>, e.g. <code>qemu-x86_64</code> for emulating 64-bit CPUs.</dd>
</dl>
<p>QEMU is offered in dynamically-linked and statically-linked variants:
</p>
<dl>
<dt>Dynamically-linked (default)</dt>
<dd>
<code>qemu-*</code> commands depend on the host OS libraries, so executables are smaller.</dd>
<dt>Statically-linked</dt>
<dd>
<code>qemu-*</code> commands can be copied to any Linux system with the same architecture.</dd>
</dl>
<p>In the case of Arch Linux, full-system emulation is offered as:
</p>
<dl>
<dt>Non-headless (default)</dt>
<dd>This variant enables GUI features that require additional dependencies (like SDL or GTK).</dd>
<dt>Headless</dt>
<dd>This is a slimmer variant that does not require GUI (this is suitable e.g. for servers).</dd>
</dl>
<p>Note that headless and non-headless versions install commands with the same name (e.g. <code>qemu-system-x86_64</code>) and thus cannot be both installed at the same time.
</p>
<h3><span class="mw-headline" id="Details_on_packages_available_in_Arch_Linux">Details on packages available in Arch Linux</span></h3>
<ul>
<li>The <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-desktop">qemu-desktop</a></span> package provides the <code>x86_64</code> architecture emulators for full-system emulation (<code>qemu-system-x86_64</code>). The <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span> package provides the <code>x86_64</code> usermode variant (<code>qemu-x86_64</code>) and also for the rest of supported architectures it includes both full-system and usermode variants (e.g. <code>qemu-system-arm</code> and <code>qemu-arm</code>).</li>
<li>The headless versions of these packages (only applicable to full-system emulation) are <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-base">qemu-base</a></span> (<code>x86_64</code>-only) and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span> (rest of architectures).</li>
<li>Full-system emulation can be expanded with some QEMU modules present in separate packages: <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span>.</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> provides a usermode and static variant for all target architectures supported by QEMU. The installed QEMU commands are named <code>qemu-<i>target_architecture</i>-static</code>, for example, <code>qemu-x86_64-static</code> for intel 64-bit CPUs.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> At present, Arch does not offer a full-system mode and statically linked variant (neither officially nor via AUR), as this is usually not needed.</div>
<h2><span class="mw-headline" id="Graphical_front-ends_for_QEMU">Graphical front-ends for QEMU</span></h2>
<p>Unlike other virtualization programs such as <a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a> and <a href="../en/VMware.html" title="VMware">VMware</a>, QEMU does not provide a GUI to manage virtual machines (other than the window that appears when running a virtual machine), nor does it provide a way to create persistent virtual machines with saved settings. All parameters to run a virtual machine must be specified on the command line at every launch, unless you have created a custom script to start your virtual machine(s).
</p>
<p><a href="../en/Libvirt.html" title="Libvirt">Libvirt</a> provides a convenient way to manage QEMU virtual machines. See <a href="../en/Libvirt.html#Client" title="Libvirt">list of libvirt clients</a> for available front-ends.
</p>
<h2><span class="mw-headline" id="Creating_new_virtualized_system">Creating new virtualized system</span></h2>
<h3><span class="mw-headline" id="Creating_a_hard_disk_image">Creating a hard disk image</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Inaccurate.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>The factual accuracy of this article or section is disputed.</b></p>
<div>
<b>Reason:</b> If I get the man page right the raw format only allocates the full size if the filesystem does not support "holes" or it is 
explicitly told to preallocate. See <span class="plainlinks archwiki-template-man" title="$ man 1 qemu-img"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu-img.1#NOTES">qemu-img(1) § NOTES</a></span>. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div> 
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> See <a href="https://en.wikibooks.org/wiki/QEMU/Images" class="extiw" title="wikibooks:QEMU/Images">Wikibooks:QEMU/Images</a> for more information on QEMU images.</div>
<p>To run QEMU you will need a hard disk image, unless you are booting a live system from CD-ROM or the network (and not doing so to install an operating system to a hard disk image). A hard disk image is a file which stores the contents of the emulated hard disk.
</p>
<p>A hard disk image can be <i>raw</i>, so that it is literally byte-by-byte the same as what the guest sees, and will always use the full capacity of the guest hard drive on the host. This method provides the least I/O overhead, but can waste a lot of space, as not-used space on the guest cannot be used on the host.
</p>
<p>Alternatively, the hard disk image can be in a format such as <i>qcow2</i> which only allocates space to the image file when the guest operating system actually writes to those sectors on its virtual hard disk. The image appears as the full size to the guest operating system, even though it may take up only a very small amount of space on the host system. This image format also supports QEMU snapshotting functionality (see <a href="#Creating_and_managing_snapshots_via_the_monitor_console">#Creating and managing snapshots via the monitor console</a> for details). However, using this format instead of <i>raw</i> will likely affect performance.
</p>
<p>QEMU provides the <code>qemu-img</code> command to create hard disk images. For example to create a 4 GiB image in the <i>raw</i> format:
</p>
<pre>$ qemu-img create -f raw <i>image_file</i> 4G
</pre>
<p>You may use <code>-f qcow2</code> to create a <i>qcow2</i> disk instead.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> You can also simply create a <i>raw</i> image by creating a file of the needed size using <code>dd</code> or <code>fallocate</code>.</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> If you store the hard disk images on a <a href="../en/Btrfs.html" title="Btrfs">Btrfs</a> file system, you should consider disabling <a href="../en/Btrfs.html#Copy-on-Write_(CoW)" title="Btrfs">Copy-on-Write</a> for the directory before creating any images. Can be specified in option nocow for qcow2 format when creating image: <pre>$ qemu-img create -f qcow2 <i>image_file</i> -o nocow=on 4G</pre>
</div>
<h4><span class="mw-headline" id="Overlay_storage_images">Overlay storage images</span></h4>
<p>You can create a storage image once (the 'backing' image) and have QEMU keep mutations to this image in an overlay image. This allows you to revert to a previous state of this storage image. You could revert by creating a new overlay image at the time you wish to revert, based on the original backing image.
</p>
<p>To create an overlay image, issue a command like:
</p>
<pre>$ qemu-img create -o backing_file=<i>img1.raw</i>,backing_fmt=<i>raw</i> -f <i>qcow2</i> <i>img1.cow</i>
</pre>
<p>After that you can run your QEMU virtual machine as usual (see <a href="#Running_virtualized_system">#Running virtualized system</a>):
</p>
<pre>$ qemu-system-x86_64 <i>img1.cow</i>
</pre>
<p>The backing image will then be left intact and mutations to this storage will be recorded in the overlay image file.
</p>
<p>When the path to the backing image changes, repair is required.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> The backing image's absolute filesystem path is stored in the (binary) overlay image file. Changing the backing image's path requires some effort.</div>
<p>Make sure that the original backing image's path still leads to this image. If necessary, make a symbolic link at the original path to the new path. Then issue a command like:
</p>
<pre>$ qemu-img rebase -b <i>/new/img1.raw</i> <i>/new/img1.cow</i>
</pre>
<p>At your discretion, you may alternatively perform an 'unsafe' rebase where the old path to the backing image is not checked:
</p>
<pre>$ qemu-img rebase -u -b <i>/new/img1.raw</i> <i>/new/img1.cow</i>
</pre>
<h4><span class="mw-headline" id="Resizing_an_image">Resizing an image</span></h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Resizing an image containing an NTFS boot file system could make the operating system installed on it unbootable. It is recommended to create a backup first.</div>
<p>The <code>qemu-img</code> executable has the <code>resize</code> option, which enables easy resizing of a hard drive image. It works for both <i>raw</i> and <i>qcow2</i>. For example, to increase image space by 10 GiB, run:
</p>
<pre>$ qemu-img resize <i>disk_image</i> +10G
</pre>
<p>After enlarging the disk image, you must use file system and partitioning tools inside the virtual machine to actually begin using the new space. 
</p>
<h5><span class="mw-headline" id="Shrinking_an_image">Shrinking an image</span></h5>
<p>When shrinking a disk image, you must first reduce the allocated file systems and partition sizes using the file system and partitioning tools inside the virtual machine and then shrink the disk image accordingly. For a Windows guest, this can be performed from the "create and format hard disk partitions" control panel.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Proceeding to shrink the disk image without reducing the guest partition sizes will result in data loss.</div>
<p>Then, to decrease image space by 10 GiB, run:
</p>
<pre>$ qemu-img resize --shrink <i>disk_image</i> -10G
</pre>
<h4><span class="mw-headline" id="Converting_an_image">Converting an image</span></h4>
<p>You can convert an image to other formats using <code>qemu-img convert</code>. This example shows how to convert a <i>raw</i> image to <i>qcow2</i>:
</p>
<pre>$ qemu-img convert -f raw -O qcow2 <i>input</i>.img <i>output</i>.qcow2
</pre>
<p>This will not remove the original input file.
</p>
<h3><span class="mw-headline" id="Preparing_the_installation_media">Preparing the installation media</span></h3>
<p>To install an operating system into your disk image, you need the installation medium (e.g. optical disc, USB-drive, or ISO image) for the operating system. The installation medium should not be mounted because QEMU accesses the media directly.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> If using an optical disc, it is a good idea to first dump the media to a file because this both improves performance and does not require you to have direct access to the devices (that is, you can run QEMU as a regular user without having to change access permissions on the media's device file). For example, if the CD-ROM device node is named <code>/dev/cdrom</code>, you can dump it to a file with the command: <pre>$ dd if=/dev/cdrom of=<i>cd_image.iso</i> bs=4k</pre>
</div>
<h3><span class="mw-headline" id="Installing_the_operating_system">Installing the operating system</span></h3>
<p>This is the first time you will need to start the emulator. To install the operating system on the disk image, you must attach both the disk image and the installation media to the virtual machine, and have it boot from the installation media.
</p>
<p>For example on i386 guests, to install from a bootable ISO file as CD-ROM and a raw disk image:
</p>
<pre>$ qemu-system-x86_64 -cdrom <i>iso_image</i> -boot order=d -drive file=<i>disk_image</i>,format=raw
</pre>
<p>See <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> for more information about loading other media types (such as floppy, disk images or physical drives) and <a href="#Running_virtualized_system">#Running virtualized system</a> for other useful options.
</p>
<p>After the operating system has finished installing, the QEMU image can be booted directly (see <a href="#Running_virtualized_system">#Running virtualized system</a>).
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> By default only 128 MiB of memory is assigned to the machine. The amount of memory can be adjusted with the <code>-m</code> switch, for example <code>-m 512M</code> or <code>-m 2G</code>.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>Instead of specifying <code>-boot order=x</code>, some users may feel more comfortable using a boot menu: <code>-boot menu=on</code>, at least during configuration and experimentation.</li>
<li>When running QEMU in headless mode, it starts a local VNC server on port 5900 per default. You can use <a href="../en/TigerVNC.html" title="TigerVNC">TigerVNC</a> to connect to the guest OS: <code>vncviewer :5900</code>
</li>
<li>If you need to replace floppies or CDs as part of the installation process, you can use the QEMU machine monitor (press <code>Ctrl+Alt+2</code> in the virtual machine's window) to remove and attach storage devices to a virtual machine. Type <code>info block</code> to see the block devices, and use the <code>change</code> command to swap out a device. Press <code>Ctrl+Alt+1</code> to go back to the virtual machine.</li>
</ul>
</div>
<h2><span class="mw-headline" id="Running_virtualized_system">Running virtualized system</span></h2>
<p><code>qemu-system-*</code> binaries (for example <code>qemu-system-i386</code> or <code>qemu-system-x86_64</code>, depending on guest's architecture) are used to run the virtualized guest. The usage is:
</p>
<pre>$ qemu-system-x86_64 <i>options</i> <i>disk_image</i>
</pre>
<p>Options are the same for all <code>qemu-system-*</code> binaries, see <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> for documentation of all options.
</p>
<p>Usually, if an option has many possible values, you can use
</p>
<pre>$ qemu-system-x86_64 <i>option</i> <i>help</i>
</pre>
<p>to list all possible values. If it supports properties, you can use
</p>
<pre>$ qemu-system-x86_64 <i>option</i> <i>value,help</i>
</pre>
<p>to list all available properties.
</p>
<p>For example:
</p>
<pre>$ qemu-system-x86_64 -machine help
$ qemu-system-x86_64 -machine q35,help
$ qemu-system-x86_64 -device help
$ qemu-system-x86_64 -device qxl,help
</pre>
<p>You can use these methods and the <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> documentation to understand the options used in follow sections.
</p>
<p>By default, QEMU will show the virtual machine's video output in a window. One thing to keep in mind: when you click inside the QEMU window, the mouse pointer is grabbed. To release it, press <code>Ctrl+Alt+g</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> QEMU should never be run as root. If you must launch it in a script as root, you should use the <code>-runas</code> option to make QEMU drop root privileges.</div>
<h3><span class="mw-headline" id="Enabling_KVM">Enabling KVM</span></h3>
<p>KVM (<i>Kernel-based Virtual Machine</i>) full virtualization must be supported by your Linux kernel and your hardware, and necessary <a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">kernel modules</a> must be loaded. See <a href="../en/KVM.html" title="KVM">KVM</a> for more information.
</p>
<p>To start QEMU in KVM mode, append <code>-accel kvm</code> to the additional start options. To check if KVM is enabled for a running virtual machine, enter the <a href="#QEMU_monitor">#QEMU monitor</a> and type <code>info kvm</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>The argument <code>accel=kvm</code> of the <code>-machine</code> option is equivalent to the <code>-enable-kvm</code> or the <code>-accel kvm</code> option.</li>
<li>CPU model <code>host</code> requires KVM.</li>
<li>If you start your virtual machine with a GUI tool and experience very bad performance, you should check for proper KVM support, as QEMU may be falling back to software emulation.</li>
<li>KVM needs to be enabled in order to start Windows 7 or Windows 8 properly without a <i>blue screen</i>.</li>
</ul>
</div>
<h3>
<span id="Enabling_IOMMU_.28Intel_VT-d.2FAMD-Vi.29_support"></span><span class="mw-headline" id="Enabling_IOMMU_(Intel_VT-d/AMD-Vi)_support">Enabling IOMMU (Intel VT-d/AMD-Vi) support</span>
</h3>
<p>First enable IOMMU, see <a href="../en/PCI_passthrough_via_OVMF.html#Setting_up_IOMMU" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Setting up IOMMU</a>.
</p>
<p>Add <code>-device intel-iommu</code> to create the IOMMU device:
</p>
<pre>$ qemu-system-x86_64 <b>-enable-kvm -machine q35 -device intel-iommu</b> -cpu host ..
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
On Intel CPU based systems creating an IOMMU device in a QEMU guest with <code>-device intel-iommu</code> will disable PCI passthrough with an error like: <pre>Device at bus pcie.0 addr 09.0 requires iommu notifier which is currently not supported by intel-iommu emulation</pre> While adding the kernel parameter <code>intel_iommu=on</code> is still needed for remapping IO (e.g. <a href="../en/PCI_passthrough_via_OVMF.html#Isolating_the_GPU" title="PCI passthrough via OVMF">PCI passthrough with vfio-pci</a>), <code>-device intel-iommu</code> should not be set if PCI passthrough is required.
</div>
<h3><span class="mw-headline" id="Booting_in_UEFI_mode">Booting in UEFI mode</span></h3>
<p>The default firmware used by QEMU is <a rel="nofollow" class="external text" href="https://www.coreboot.org/SeaBIOS">SeaBIOS</a>, which is a Legacy BIOS implementation. QEMU uses <code>/usr/share/qemu/bios-256k.bin</code> (provided by the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=seabios">seabios</a></span> package) as a default read-only (ROM) image. You can use the <code>-bios</code> argument to select another firmware file. However, UEFI requires writable memory to work properly, so you need to emulate <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/PC_System_Flash">PC System Flash</a> instead.
</p>
<p><a rel="nofollow" class="external text" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a> is a TianoCore project to enable UEFI support for Virtual Machines. It can be <a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">installed</a> with the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=edk2-ovmf">edk2-ovmf</a></span> package.
</p>
<p>There are two ways to use OVMF as a firmware. The first is to copy <code>/usr/share/edk2/x64/OVMF.4m.fd</code>, make it writable and use as a pflash drive:
</p>
<pre>-drive if=pflash,format=raw,file=<i>/copy/of/OVMF.4m.fd</i>
</pre>
<p>All changes to the UEFI settings will be saved directly to this file.
</p>
<p>Another and more preferable way is to split OVMF into two files. The first one will be read-only and store the firmware executable, and the second one will be used as a writable variable store. The advantage is that you can use the firmware file directly without copying, so it will be updated automatically by <a href="../en/Pacman.html" title="Pacman">pacman</a>.
</p>
<p>Use <code>/usr/share/edk2/x64/OVMF_CODE.4m.fd</code> as a first read-only pflash drive. Copy <code>/usr/share/edk2/x64/OVMF_VARS.4m.fd</code>, make it writable and use as a second writable pflash drive:
</p>
<pre>-drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd \
-drive if=pflash,format=raw,file=<i>/copy/of/OVMF_VARS.4m.fd</i>
</pre>
<p>If secure boot is wanted, use q35 machine type and replace <code>/usr/share/edk2/x64/OVMF_CODE.4m.fd</code> with <code>/usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd</code>.
</p>
<h3><span class="mw-headline" id="Trusted_Platform_Module_emulation">Trusted Platform Module emulation</span></h3>
<p>QEMU can emulate <a href="../en/Trusted_Platform_Module.html" title="Trusted Platform Module">Trusted Platform Module</a>, which is required by some systems such as Windows 11 (which requires TPM 2.0).
</p>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">Install</a> the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=swtpm">swtpm</a></span> package, which provides a software TPM implementation. Create some directory for storing TPM data (<code><i>/path/to/mytpm</i></code> will be used as an example). Run this command to start the emulator:
</p>
<pre>$ swtpm socket --tpm2 --tpmstate dir=<i>/path/to/mytpm</i> --ctrl type=unixio,path=<i>/path/to/mytpm/swtpm-sock</i>
</pre>
<p><code><i>/path/to/mytpm/swtpm-sock</i></code> will be created by <i>swtpm</i>: this is a UNIX socket to which QEMU will connect. You can put it in any directory.
</p>
<p>By default, <i>swtpm</i> starts a TPM version 1.2 emulator. The <code>--tpm2</code> option enables TPM 2.0 emulation.
</p>
<p>Finally, add the following options to QEMU:
</p>
<pre>-chardev socket,id=chrtpm,path=<i>/path/to/mytpm/swtpm-sock</i> \
-tpmdev emulator,id=tpm0,chardev=chrtpm \
-device tpm-tis,tpmdev=tpm0
</pre>
<p>and TPM will be available inside the virtual machine. After shutting down the virtual machine, <i>swtpm</i> will be automatically terminated.
</p>
<p>See <a rel="nofollow" class="external text" href="https://qemu-project.gitlab.io/qemu/specs/tpm.html">the QEMU documentation</a> for more information. 
</p>
<p>If guest OS still doesn't recognize the TPM device, try to adjust <i>CPU Models and Topology</i> options. It might cause problem.
</p>
<h2><span class="mw-headline" id="Sharing_data_between_host_and_guest">Sharing data between host and guest</span></h2>
<h3><span class="mw-headline" id="Network">Network</span></h3>
<p>Data can be shared between the host and guest OS using any network protocol that can transfer files, such as <a href="../en/NFS.html" title="NFS">NFS</a>, <a href="../en/Samba.html" class="mw-redirect" title="SMB">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_block_device" class="extiw" title="wikipedia:Network block device">NBD</a>, HTTP, <a href="../en/Very_Secure_FTP_Daemon.html" title="Very Secure FTP Daemon">FTP</a>, or <a href="../en/Secure_Shell.html" class="mw-redirect" title="SSH">SSH</a>, provided that you have set up the network appropriately and enabled the appropriate services.
</p>
<p>The default user-mode networking allows the guest to access the host OS at the IP address 10.0.2.2. Any servers that you are running on your host OS, such as a SSH server or SMB server, will be accessible at this IP address. So on the guests, you can mount directories exported on the host via <a href="../en/Samba.html" class="mw-redirect" title="SMB">SMB</a> or <a href="../en/NFS.html" title="NFS">NFS</a>, or you can access the host's HTTP server, etc.
It will not be possible for the host OS to access servers running on the guest OS, but this can be done with other network configurations (see <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>).
</p>
<h3>
<span id="QEMU.27s_port_forwarding"></span><span class="mw-headline" id="QEMU's_port_forwarding">QEMU's port forwarding</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> QEMU's port forwarding is IPv4-only. IPv6 port forwarding is not implemented and the last patches were proposed in 2018.<a rel="nofollow" class="external autonumber" href="https://lore.kernel.org/qemu-devel/1540512223-21199-1-git-send-email-max7255@yandex-team.ru/T/#u">[1]</a>
</div>
<p>QEMU can forward ports from the host to the guest to enable e.g. connecting from the host to an SSH server running on the guest.
</p>
<p>For example, to bind port 60022 on the host with port 22 (SSH) on the guest, start QEMU with a command like:
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::60022-:22
</pre>
<p>Make sure the sshd is running on the guest and connect with:
</p>
<pre>$ ssh <i>guest-user</i>@127.0.0.1 -p 60022
</pre>
<p>You can use <a href="../en/SSHFS.html" title="SSHFS">SSHFS</a> to mount the guest's file system at the host for shared read and write access.
</p>
<p>To forward several ports, you just repeat the <code>hostfwd</code> in the <code>-nic</code> argument, e.g. for VNC's port:
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::5900-:5900
</pre>
<h3>
<span id="QEMU.27s_built-in_SMB_server"></span><span class="mw-headline" id="QEMU's_built-in_SMB_server">QEMU's built-in SMB server</span>
</h3>
<p>QEMU's documentation says it has a "built-in" SMB server, but actually it just starts up <a href="../en/Samba.html" title="Samba">Samba</a> on the host with an automatically generated <code>smb.conf</code> file located in <code>/tmp/qemu-smb.<i>random_string</i></code> and makes it accessible to the guest at a different IP address (10.0.2.4 by default). This only works for user networking, and is useful when you do not want to start the normal <a href="../en/Samba.html" title="Samba">Samba</a> service on the host, which the guest can also access if you have set up shares on it.
</p>
<p>Only a single directory can be set as shared with the option <code>smb=</code>, but adding more directories (even while the virtual machine is running) could be as easy as creating symbolic links in the shared directory if QEMU configured SMB to follow symbolic links. It does not do so, but the configuration of the running SMB server can be changed as described below.
</p>
<p><i>Samba</i> must be installed on the host. To enable this feature, start QEMU with a command like:
</p>
<pre>$ qemu-system-x86_64 -nic user,id=nic0,smb=<i>shared_dir_path</i> <i>disk_image</i>
</pre>
<p>where <code><i>shared_dir_path</i></code> is a directory that you want to share between the guest and host.
</p>
<p>Then, in the guest, you will be able to access the shared directory on the host 10.0.2.4 with the share name "qemu". For example, in Windows Explorer you would go to <code>\\10.0.2.4\qemu</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>If you are using sharing options multiple times like <code>-net user,smb=<i>shared_dir_path1</i> -net user,smb=<i>shared_dir_path2</i></code> or <code>-net user,smb=<i>shared_dir_path1</i>,smb=<i>shared_dir_path2</i></code> then it will share only the last defined one.</li>
<li>If you cannot access the shared folder and the guest system is Windows, check that the <a rel="nofollow" class="external text" href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">NetBIOS protocol is enabled</a><sup title="Last check status: domain name not resolved">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2023-05-06 ⓘ]</sup> and that a firewall does not block <a rel="nofollow" class="external text" href="https://technet.microsoft.com/en-us/library/cc940063.aspx">ports</a> used by the NetBIOS protocol.</li>
<li>If you cannot access the shared folder and the guest system is Windows 10 Enterprise or Education or Windows Server 2016, <a rel="nofollow" class="external text" href="https://support.microsoft.com/en-us/help/4046019">enable guest access</a>.</li>
<li>If you use <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>, use <code>-device virtio-net,netdev=vmnic -netdev user,id=vmnic,smb=<i>shared_dir_path</i></code> to get SMB.</li>
</ul>
</div>
<p>One way to share multiple directories and to add or remove them while the virtual machine is running, is to share an empty directory and create/remove symbolic links to the directories in the shared directory. For this to work, the configuration of the running SMB server can be changed with the following script, which also allows the execution of files on the guest that are not set executable on the host:
</p>
<pre>#!/bin/sh
eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print "pid="$1";conf="$6}')
echo "[global]
allow insecure wide links = yes
[qemu]
follow symlinks = yes
wide links = yes
acl allow execute always = yes" &gt;&gt; "$conf"
# in case the change is not detected automatically:
smbcontrol --configfile="$conf" "$pid" reload-config
</pre>
<p>This can be applied to the running server started by qemu only after the guest has connected to the network drive the first time. An alternative to this method is to add additional shares to the configuration file like so:
</p>
<pre>echo "[<i>myshare</i>]
path=<i>another_path</i>
read only=no
guest ok=yes
force user=<i>username</i>" &gt;&gt; $conf
</pre>
<p>This share will be available on the guest as <code>\\10.0.2.4\<i>myshare</i></code>.
</p>
<h3><span class="mw-headline" id="Using_filesystem_passthrough_and_VirtFS">Using filesystem passthrough and VirtFS</span></h3>
<p>See the <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Documentation/9psetup">QEMU documentation</a>.
</p>
<h3><span class="mw-headline" id="Host_file_sharing_with_virtiofsd">Host file sharing with virtiofsd</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> See <a href="../en/Help:Style/Formatting_and_punctuation.html" title="Help:Style/Formatting and punctuation">Help:Style/Formatting and punctuation</a>. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>virtiofsd is shipped with the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virtiofsd">virtiofsd</a></span> package. See the <a rel="nofollow" class="external text" href="https://gitlab.com/virtio-fs/virtiofsd/-/blob/main/README.md?ref_type=heads#user-content-usage">online</a> documentation or <code>/usr/share/doc/virtiofsd/README.md</code> for a full list of available options.
</p>
<p>Add user that runs qemu to the 'kvm' <a href="../en/Users_and_groups.html#Group_management" class="mw-redirect" title="User group">user group</a>, because it needs to access the virtiofsd socket. You might have to logout for change to take effect.
</p>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Inaccurate.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>The factual accuracy of this article or section is disputed.</b></p>
<div>
<b>Reason:</b> Running services as root is not secure. Also the process should be wrapped in a systemd service. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>Start as virtiofsd as root:
</p>
<pre># /usr/lib/virtiofsd --socket-path=/var/run/qemu-vm-001.sock --shared-dir /tmp/vm-001 --cache always
</pre>
<p>where
</p>
<ul>
<li>
<code>/var/run/qemu-vm-001.sock</code> is a socket file,</li>
<li>
<code>/tmp/vm-001</code> is a shared directory between the host and the guest virtual machine.</li>
</ul>
<p>The created socket file has root only access permission. Give group kvm access to it with:
</p>
<pre># chgrp kvm qemu-vm-001.sock; chmod g+rxw qemu-vm-001.sock
</pre>
<p>Add the following configuration options when starting the virtual machine:
</p>
<pre>-object memory-backend-memfd,id=mem,size=4G,share=on \
-numa node,memdev=mem \
-chardev socket,id=char0,path=/var/run/qemu-vm-001.sock \
-device vhost-user-fs-pci,chardev=char0,tag=myfs
</pre>
<p>where
</p>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-view-fullscreen.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs expansion.</b></p>
<div>
<b>Reason:</b> Explain the remaining options (or remove them if they are not necessary). (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<ul>
<li>
<code>size=4G</code> shall match size specified with <code>-m 4G</code> option,</li>
<li>
<code>/var/run/qemu-vm-001.sock</code> points to socket file started earlier,</li>
</ul>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> The section should not be specific to Windows. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>Remember, that guest must be configured to enable sharing. For Windows there are <a rel="nofollow" class="external text" href="https://virtio-fs.gitlab.io/howto-windows.html">instructions</a>. Once configured, Windows will have the <code>Z:</code> drive mapped automatically with shared directory content.
</p>
<p>Your Windows 10 guest system is properly configured if it has:
</p>
<ul>
<li>VirtioFSSService windows service,</li>
<li>WinFsp.Launcher windows service,</li>
<li>VirtIO FS Device driver under "System devices" in Windows "Device Manager".</li>
</ul>
<p>If the above installed and <code>Z:</code> drive is still not listed, try repairing "Virtio-win-guest-tools" in Windows <i>Add/Remove programs</i>.
</p>
<h3><span class="mw-headline" id="Mounting_a_partition_of_the_guest_on_the_host">Mounting a partition of the guest on the host</span></h3>
<p>It can be useful to mount a drive image under the host system, it can be a way to transfer files in and out of the guest. This should be done when the virtual machine is not running.
</p>
<p>The procedure to mount the drive on the host depends on the type of qemu image, <i>raw</i> or <i>qcow2</i>. We detail thereafter the steps to mount a drive in the two formats in <a href="#Mounting_a_partition_from_a_raw_image">#Mounting a partition from a raw image</a> and <a href="#Mounting_a_partition_from_a_qcow2_image">#Mounting a partition from a qcow2 image</a>. For the full documentation see <a href="https://en.wikibooks.org/wiki/QEMU/Images#Mounting_an_image_on_the_host" class="extiw" title="wikibooks:QEMU/Images">Wikibooks:QEMU/Images#Mounting an image on the host</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> You must unmount the partitions before running the virtual machine again. Otherwise, data corruption is very likely to occur.</div>
<h4><span class="mw-headline" id="Mounting_a_partition_from_a_raw_image">Mounting a partition from a raw image</span></h4>
<p>It is possible to mount partitions that are inside a raw disk image file by setting them up as loopback devices.
</p>
<h5><span class="mw-headline" id="With_manually_specifying_byte_offset">With manually specifying byte offset</span></h5>
<p>One way to mount a disk image partition is to mount the disk image at a certain offset using a command like the following:
</p>
<pre># mount -o loop,offset=32256 <i>disk_image</i> <i>mountpoint</i>
</pre>
<p>The <code>offset=32256</code> option is actually passed to the <code>losetup</code> program to set up a loopback device that starts at byte offset 32256 of the file and continues to the end. This loopback device is then mounted. You may also use the <code>sizelimit</code> option to specify the exact size of the partition, but this is usually unnecessary.
</p>
<p>Depending on your disk image, the needed partition may not start at offset 32256. Run <code>fdisk -l <i>disk_image</i></code> to see the partitions in the image. fdisk gives the start and end offsets in 512-byte sectors, so multiply by 512 to get the correct offset to pass to <code>mount</code>.
</p>
<h5><span class="mw-headline" id="With_loop_module_autodetecting_partitions">With loop module autodetecting partitions</span></h5>
<p>The Linux loop driver actually supports partitions in loopback devices, but it is disabled by default. To enable it, do the following:
</p>
<ul>
<li>Get rid of all your loopback devices (unmount all mounted images, etc.).</li>
<li>
<a href="../en/Kernel_module.html#Manual_module_handling" class="mw-redirect" title="Kernel modules">Unload</a> the <code>loop</code> kernel module, and load it with the <code>max_part=15</code> parameter set. Additionally, the maximum number of loop devices can be controlled with the <code>max_loop</code> parameter.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> You can put an entry in <code>/etc/modprobe.d</code> to load the loop module with <code>max_part=15</code> every time, or you can put <code>loop.max_part=15</code> on the kernel command-line, depending on whether you have the <code>loop.ko</code> module built into your kernel or not.</div>
<p>Set up your image as a loopback device:
</p>
<pre># losetup -f -P <i>disk_image</i>
</pre>
<p>Then, if the device created was <code>/dev/loop0</code>, additional devices <code>/dev/loop0p<i>X</i></code> will have been automatically created, where X is the number of the partition. These partition loopback devices can be mounted directly. For example:
</p>
<pre># mount /dev/loop0p1 <i>mountpoint</i>
</pre>
<p>To mount the disk image with <i>udisksctl</i>, see <a href="../en/Udisks.html#Mount_loop_devices" title="Udisks">Udisks#Mount loop devices</a>.
</p>
<h5><span class="mw-headline" id="With_kpartx">With kpartx</span></h5>
<p><i>kpartx</i> from the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=multipath-tools">multipath-tools</a></span> package can read a partition table on a device and create a new device for each partition. For example:
</p>
<pre># kpartx -a <i>disk_image</i>
</pre>
<p>This will setup the loopback device and create the necessary partition(s) device(s) in <code>/dev/mapper/</code>.
</p>
<h4><span class="mw-headline" id="Mounting_a_partition_from_a_qcow2_image">Mounting a partition from a qcow2 image</span></h4>
<p>We will use <code>qemu-nbd</code>, which lets use the NBD (<i>network block device</i>) protocol to share the disk image.
</p>
<p>First, we need the <i>nbd</i> module loaded:
</p>
<pre># modprobe nbd max_part=16
</pre>
<p>Then, we can share the disk and create the device entries:
</p>
<pre># qemu-nbd -c /dev/nbd0 <i>/path/to/image.qcow2</i>
</pre>
<p>Discover the partitions:
</p>
<pre># partprobe /dev/nbd0
</pre>
<p><i>fdisk</i> can be used to get information regarding the different partitions in <code><i>nbd0</i></code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/nbd0</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Disk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xa6a4d542

Device      Boot   Start      End  Sectors  Size Id Type
/dev/nbd0p1 *       2048  1026047  1024000  500M  7 HPFS/NTFS/exFAT
/dev/nbd0p2      1026048 52877311 51851264 24.7G  7 HPFS/NTFS/exFAT</pre>
<p>Then mount any partition of the drive image, for example the partition 2:
</p>
<pre># mount /dev/nbd0<b>p2</b> <i>mountpoint</i>
</pre>
<p>After the usage, it is important to unmount the image and reverse previous steps, i.e. unmount the partition and disconnect the nbd device:
</p>
<pre># umount <i>mountpoint</i>
# qemu-nbd -d /dev/nbd0
</pre>
<h3><span class="mw-headline" id="Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image">Using any real partition as the single primary partition of a hard disk image</span></h3>
<p>Sometimes, you may wish to use one of your system partitions from within QEMU. Using a raw partition for a virtual machine will improve performance, as the read and write operations do not go through the file system layer on the physical host. Such a partition also provides a way to share data between the host and guest.
</p>
<p>In Arch Linux, device files for raw partitions are, by default, owned by <i>root</i> and the <i>disk</i> group. If you would like to have a non-root user be able to read and write to a raw partition, you must either change the owner of the partition's device file to that user, add that user to the <i>disk</i> group, or use <a href="../en/Access_Control_Lists.html" class="mw-redirect" title="ACL">ACL</a> for more fine-grained access control.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> 
<ul>
<li>Although it is possible, it is not recommended to allow virtual machines to alter critical data on the host system, such as the root partition.</li>
<li>You must not mount a file system on a partition read-write on both the host and the guest at the same time. Otherwise, data corruption will result.</li>
</ul>
</div>
<p>After doing so, you can attach the partition to a QEMU virtual machine as a virtual disk.
</p>
<p>However, things are a little more complicated if you want to have the <i>entire</i> virtual machine contained in a partition. In that case, there would be no disk image file to actually boot the virtual machine since you cannot install a boot loader to a partition that is itself formatted as a file system and not as a partitioned device with an MBR. Such a virtual machine can be booted either by: <a href="#Specifying_kernel_and_initrd_manually">#Specifying kernel and initrd manually</a>, <a href="#Simulating_a_virtual_disk_with_MBR">#Simulating a virtual disk with MBR</a>, <a href="#Using_the_device-mapper">#Using the device-mapper</a>, <a href="#Using_a_linear_RAID">#Using a linear RAID</a> or <a href="#Using_a_Network_Block_Device">#Using a Network Block Device</a>.
</p>
<h4><span class="mw-headline" id="Specifying_kernel_and_initrd_manually">Specifying kernel and initrd manually</span></h4>
<p>QEMU supports loading <a href="../en/Kernel.html" class="mw-redirect" title="Kernels">Linux kernels</a> and <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">init ramdisks</a> directly, thereby circumventing boot loaders such as <a href="../en/GRUB.html" title="GRUB">GRUB</a>. It then can be launched with the physical partition containing the root file system as the virtual disk, which will not appear to be partitioned. This is done by issuing a command similar to the following:
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> In this example, it is the <b>host's</b> images that are being used, not the guest's. If you wish to use the guest's images, either mount <code>/dev/sda3</code> read-only (to protect the file system from the host) and specify the <code>/full/path/to/images</code> or use some kexec hackery in the guest to reload the guest's kernel (extends boot time). </div>
<pre>$ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3
</pre>
<p>In the above example, the physical partition being used for the guest's root file system is <code>/dev/sda3</code> on the host, but it shows up as <code>/dev/sda</code> on the guest.
</p>
<p>You may, of course, specify any kernel and initrd that you want, and not just the ones that come with Arch Linux.
</p>
<p>When there are multiple <a href="../en/Kernel_parameters.html" title="Kernel parameters">kernel parameters</a> to be passed to the <code>-append</code> option, they need to be quoted using single or double quotes. For example:
</p>
<pre>... -append 'root=/dev/sda1 console=ttyS0'
</pre>
<h4><span class="mw-headline" id="Simulating_a_virtual_disk_with_MBR">Simulating a virtual disk with MBR</span></h4>
<p>A more complicated way to have a virtual machine use a physical partition, while keeping that partition formatted as a file system and not just having the guest partition the partition as if it were a disk, is to simulate an MBR for it so that it can boot using a boot loader such as GRUB.
</p>
<p>For the following, suppose you have a plain, unmounted <code>/dev/hda<i>N</i></code> partition with some file system on it you wish to make part of a QEMU disk image. The trick is to dynamically prepend a master boot record (MBR) to the real partition you wish to embed in a QEMU raw disk image. More generally, the partition can be any part of a larger simulated disk, in particular a block device that simulates the original physical disk but only exposes <code>/dev/hda<i>N</i></code> to the virtual machine.
</p>
<p>A virtual disk of this type can be represented by a VMDK file that contains references to (a copy of) the MBR and the partition, but QEMU does not support this VMDK format. For instance, a virtual disk <a rel="nofollow" class="external text" href="https://www.virtualbox.org/manual/ch09.html#rawdisk">created by</a>
</p>
<pre>$ VBoxManage internalcommands createrawvmdk -filename <i>/path/to/file.vmdk</i> -rawdisk /dev/hda
</pre>
<p>will be rejected by QEMU with the error message
</p>
<pre>Unsupported image type 'partitionedDevice'
</pre>
<p>Note that <code>VBoxManage</code> creates two files, <code><i>file.vmdk</i></code> and <code><i>file-pt.vmdk</i></code>, the latter being a copy of the MBR, to which the text file <code>file.vmdk</code> points. Read operations outside the target partition or the MBR would give zeros, while written data would be discarded.
</p>
<h5><span class="mw-headline" id="Using_the_device-mapper">Using the device-mapper</span></h5>
<p>A method that is similar to the use of a VMDK descriptor file uses the <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/device-mapper/index.html">device-mapper</a> to prepend a loop device attached to the MBR file to the target partition. In case we do not need our virtual disk to have the same size as the original, we first create a file to hold the MBR:
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=2048
</pre>
<p>Here, a 1 MiB (2048 * 512 bytes) file is created in accordance with partition alignment policies used by modern disk partitioning tools. For compatibility with older partitioning software, 63 sectors instead of 2048 might be required. The MBR only needs a single 512 bytes block, the additional free space can be used for a BIOS boot partition and, in the case of a hybrid partitioning scheme, for a GUID Partition Table. Then, we attach a loop device to the MBR file:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># losetup --show -f <i>/path/to/mbr</i></pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/dev/loop0</pre>
<p>In this example, the resulting device is <code>/dev/loop0</code>. The device mapper is now used to join the MBR and the partition:
</p>
<pre># echo "0 2048 linear /dev/loop0 0
2048 `blockdev --getsz /dev/hda<i>N</i>` linear /dev/hda<i>N</i> 0" | dmsetup create qemu
</pre>
<p>The resulting <code>/dev/mapper/qemu</code> is what we will use as a QEMU raw disk image. Additional steps are required to create a partition table (see the section that describes the use of a linear RAID for an example) and boot loader code on the virtual disk (which will be stored in <code><i>/path/to/mbr</i></code>).
</p>
<p>The following setup is an example where the position of <code>/dev/hda<i>N</i></code> on the virtual disk is to be the same as on the physical disk and the rest of the disk is hidden, except for the MBR, which is provided as a copy:
</p>
<pre># dd if=/dev/hda count=1 of=<i>/path/to/mbr</i>
# loop=`losetup --show -f <i>/path/to/mbr</i>`
# start=`blockdev --report /dev/hda<i>N</i> | tail -1 | awk '{print $5}'`
# size=`blockdev --getsz /dev/hda<i>N</i>`
# disksize=`blockdev --getsz /dev/hda`
# echo "0 1 linear $loop 0
1 $((start-1)) zero
$start $size linear /dev/hda<i>N</i> 0
$((start+size)) $((disksize-start-size)) zero" | dmsetup create qemu
</pre>
<p>The table provided as standard input to <code>dmsetup</code> has a similar format as the table in a VMDK descriptor file produced by <code>VBoxManage</code> and can alternatively be loaded from a file with <code>dmsetup create qemu --table <i>table_file</i></code>. To the virtual machine, only <code>/dev/hda<i>N</i></code> is accessible, while the rest of the hard disk reads as zeros and discards written data, except for the first sector. We can print the table for <code>/dev/mapper/qemu</code> with <code>dmsetup table qemu</code> (use <code>udevadm info -rq name /sys/dev/block/<i>major</i>:<i>minor</i></code> to translate <code><i>major</i>:<i>minor</i></code> to the corresponding <code>/dev/<i>blockdevice</i></code> name). Use <code>dmsetup remove qemu</code> and <code>losetup -d $loop</code> to delete the created devices.
</p>
<p>A situation where this example would be useful is an existing Windows XP installation in a multi-boot configuration and maybe a hybrid partitioning scheme (on the physical hardware, Windows XP could be the only operating system that uses the MBR partition table, while more modern operating systems installed on the same computer could use the GUID Partition Table). Windows XP supports hardware profiles, so that that the same installation can be used with different hardware configurations alternatingly (in this case bare metal vs. virtual) with Windows needing to install drivers for newly detected hardware only once for every profile. Note that in this example the boot loader code in the copied MBR needs to be updated to directly load Windows XP from <code>/dev/hda<i>N</i></code> instead of trying to start the multi-boot capable boot loader (like GRUB) present in the original system. Alternatively, a copy of the boot partition containing the boot loader installation can be included in the virtual disk the same way as the MBR.
</p>
<h5><span class="mw-headline" id="Using_a_linear_RAID">Using a linear RAID</span></h5>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:View-refresh-red.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section is out of date.</b></p>
<div>
<b>Reason:</b> <a rel="nofollow" class="external text" href="https://github.com/torvalds/linux/commit/849d18e27be9a1253f2318cb4549cc857219d991">CONFIG_MD_LINEAR Removal</a> Linear RAID has been deprecated since 2021 and removed on Kernel Version 6.8. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>You can also do this using software <a href="../en/RAID.html" title="RAID">RAID</a> in linear mode (you need the <code>linear.ko</code> kernel driver) and a loopback device: 
</p>
<p>First, you create some small file to hold the MBR:
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=32
</pre>
<p>Here, a 16 KiB (32 * 512 bytes) file is created. It is important not to make it too small (even if the MBR only needs a single 512 bytes block), since the smaller it will be, the smaller the chunk size of the software RAID device will have to be, which could have an impact on performance. Then, you setup a loopback device to the MBR file:
</p>
<pre># losetup -f <i>/path/to/mbr</i>
</pre>
<p>Let us assume the resulting device is <code>/dev/loop0</code>, because we would not already have been using other loopbacks. Next step is to create the "merged" MBR + <code>/dev/hda<i>N</i></code> disk image using software RAID:
</p>
<pre># modprobe linear
# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hda<i>N</i>
</pre>
<p>The resulting <code>/dev/md0</code> is what you will use as a QEMU raw disk image (do not forget to set the permissions so that the emulator can access it). The last (and somewhat tricky) step is to set the disk configuration (disk geometry and partitions table) so that the primary partition start point in the MBR matches the one of <code>/dev/hda<i>N</i></code> inside <code>/dev/md0</code> (an offset of exactly 16 * 512 = 16384 bytes in this example). Do this using <code>fdisk</code> on the host machine, not in the emulator: the default raw disc detection routine from QEMU often results in non-kibibyte-roundable offsets (such as 31.5 KiB, as in the previous section) that cannot be managed by the software RAID code. Hence, from the host:
</p>
<pre># fdisk /dev/md0
</pre>
<p>Press <code>X</code> to enter the expert menu. Set number of 's'ectors per track so that the size of one cylinder matches the size of your MBR file. For two heads and a sector size of 512, the number of sectors per track should be 16, so we get cylinders of size 2x16x512=16k.
</p>
<p>Now, press <code>R</code> to return to the main menu.
</p>
<p>Press <code>P</code> and check that the cylinder size is now 16k.
</p>
<p>Now, create a single primary partition corresponding to <code>/dev/hda<i>N</i></code>. It should start at cylinder 2 and end at the end of the disk (note that the number of cylinders now differs from what it was when you entered fdisk.
</p>
<p>Finally, 'w'rite the result to the file: you are done. You now have a partition you can mount directly from your host, as well as part of a QEMU disk image:
</p>
<pre>$ qemu-system-x86_64 -hdc /dev/md0 <i>[...]</i>
</pre>
<p>You can, of course, safely set any boot loader on this disk image using QEMU, provided the original <code>/dev/hda<i>N</i></code> partition contains the necessary tools.
</p>
<h5><span class="mw-headline" id="Using_a_Network_Block_Device">Using a Network Block Device</span></h5>
<p>With <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/blockdev/nbd.html">Network Block Device</a>, Linux can use a remote server as one of its block device. You may use <code>nbd-server</code> (from the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nbd">nbd</a></span> package) to create an MBR wrapper for QEMU.
</p>
<p>Assuming you have already set up your MBR wrapper file like above, rename it to <code>wrapper.img.0</code>. Then create a symbolic link named <code>wrapper.img.1</code> in the same directory, pointing to your partition. Then put the following script in the same directory:
</p>
<pre>#!/bin/sh
dir="$(realpath "$(dirname "$0")")"
cat &gt;wrapper.conf &lt;&lt;EOF
[generic]
allowlist = true
listenaddr = 127.713705
port = 10809

[wrap]
exportname = $dir/wrapper.img
multifile = true
EOF

nbd-server \
    -C wrapper.conf \
    -p wrapper.pid \
    "$@"</pre>
<p>The <code>.0</code> and <code>.1</code> suffixes are essential; the rest can be changed. After running the above script (which you may need to do as root to make sure nbd-server is able to access the partition), you can launch QEMU with:
</p>
<pre>qemu-system-x86_64 -drive file=nbd:127.713705:10809:exportname=wrap <i>[...]</i>
</pre>
<h3><span class="mw-headline" id="Using_an_entire_physical_disk_device_inside_the_virtual_machine">Using an entire physical disk device inside the virtual machine</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> Duplicates <a href="#Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image">#Using any real partition as the single primary partition of a hard disk image</a>, libvirt instructions do not belong to this page. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>You may have a second disk with a different OS (like Windows) on it and may want to gain the ability to also boot it inside a virtual machine.
Since the disk access is raw, the disk will perform quite well inside the virtual machine.
</p>
<h4><span class="mw-headline" id="Windows_virtual_machine_boot_prerequisites">Windows virtual machine boot prerequisites</span></h4>
<p>Be sure to install the <a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/">virtio drivers</a> inside the OS on that disk before trying to boot it in the virtual machine.
For Win 7 use version <a rel="nofollow" class="external text" href="https://askubuntu.com/questions/1310440/using-virtio-win-drivers-with-win7-sp1-x64">0.1.173-4</a>.
Some singular drivers from newer virtio builds may be used on Win 7 but you will have to install them manually via device manager.
For Win 10 you can use the latest virtio build.
</p>
<h5><span class="mw-headline" id="Set_up_the_windows_disk_interface_drivers">Set up the windows disk interface drivers</span></h5>
<p>You may get a <code>0x0000007B</code> bluescreen when trying to boot the virtual machine. This means Windows can not access the drive during the early boot stage because the disk interface driver it would need for that is not loaded / is set to start manually.
</p>
<p>The solution is to <a rel="nofollow" class="external text" href="https://superuser.com/a/1032769">enable these drivers to start at boot</a>.
</p>
<p>In <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</code>, find the folders <code>aliide, amdide, atapi, cmdide, iastor (may not exist), iastorV, intelide, LSI_SAS, msahci, pciide and viaide</code>.
Inside each of those, set all their "start" values to 0 in order to enable them at boot.
If your drive is a PCIe NVMe drive, also enable that driver (should it exist).
</p>
<h4><span class="mw-headline" id="Find_the_unique_path_of_your_disk">Find the unique path of your disk</span></h4>
<p>Run <code>ls /dev/disk/by-id/</code>: tere you pick out the ID of the drive you want to insert into the virtual machine, for example <code>ata-TS512GMTS930L_C199211383</code>.
Now add that ID to <code>/dev/disk/by-id/</code> so you get <code>/dev/disk/by-id/ata-TS512GMTS930L_C199211383</code>.
That is the unique path to that disk.
</p>
<h4><span class="mw-headline" id="Add_the_disk_in_QEMU_CLI">Add the disk in QEMU CLI</span></h4>
<p>In QEMU CLI that would probably be:
</p>
<p><code>-drive file=/dev/disk/by-id/ata-TS512GMTS930L_C199211383,format=raw,media=disk</code>
</p>
<p>Just modify <code>file=</code> to be the unique path of your drive.
</p>
<h4><span class="mw-headline" id="Add_the_disk_in_libvirt">Add the disk in libvirt</span></h4>
<p>In libvirt XML that translates to
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ virsh edit <i>vmname</i></pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
    &lt;disk type="block" device="disk"&gt;
      &lt;driver name="qemu" type="raw" cache="none" io="native"/&gt;
      &lt;source dev="/dev/disk/by-id/ata-TS512GMTS930L_C199211383"/&gt;
      &lt;target dev="sda" bus="sata"/&gt;
      &lt;address type="drive" controller="0" bus="0" target="0" unit="0"/&gt;
    &lt;/disk&gt;
...
</pre>
<p>Just modify "source dev" to be the unique path of your drive.
</p>
<h4><span class="mw-headline" id="Add_the_disk_in_virt-manager">Add the disk in virt-manager</span></h4>
<p>When creating a virtual machine, select "import existing drive" and just paste that unique path.
If you already have the virtual machine, add a device, storage, then select or create custom storage.
Now paste the unique path.
</p>
<h2><span class="mw-headline" id="Networking">Networking</span></h2>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> Network topologies (sections <a href="#Host-only_networking">#Host-only networking</a>, <a href="#Internal_networking">#Internal networking</a> and info spread out across other sections) should not be described alongside the various virtual interfaces implementations, such as <a href="#User-mode_networking">#User-mode networking</a>, <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>, <a href="#Networking_with_VDE2">#Networking with VDE2</a>. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>The performance of virtual networking should be better with tap devices and bridges than with user-mode networking or vde because tap devices and bridges are implemented in-kernel.
</p>
<p>In addition, networking performance can be improved by assigning virtual machines a <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a> network device rather than the default emulation of an e1000 NIC. See <a href="#Installing_virtio_drivers">#Installing virtio drivers</a> for more information.
</p>
<h3><span class="mw-headline" id="Link-level_address_caveat">Link-level address caveat</span></h3>
<p>By giving the <code>-net nic</code> argument to QEMU, it will, by default, assign a virtual machine a network interface with the link-level address <code>52:54:00:12:34:56</code>. However, when using bridged networking with multiple virtual machines, it is essential that each virtual machine has a unique link-level (MAC) address on the virtual machine side of the tap device. Otherwise, the bridge will not work correctly, because it will receive packets from multiple sources that have the same link-level address. This problem occurs even if the tap devices themselves have unique link-level addresses because the source link-level address is not rewritten as packets pass through the tap device.
</p>
<p>Make sure that each virtual machine has a unique link-level address, but it should always start with <code>52:54:</code>. Use the following option, replace <i>X</i> with arbitrary hexadecimal digit:
</p>
<pre>$ qemu-system-x86_64 -net nic,macaddr=52:54:<i>XX:XX:XX:XX</i> -net vde <i>disk_image</i>
</pre>
<p>Generating unique link-level addresses can be done in several ways:
</p>
<ul>
<li>Manually specify unique link-level address for each NIC. The benefit is that the DHCP server will assign the same IP address each time the virtual machine is run, but it is unusable for large number of virtual machines.</li>
<li>Generate random link-level address each time the virtual machine is run. Practically zero probability of collisions, but the downside is that the DHCP server will assign a different IP address each time. You can use the following command in a script to generate random link-level address in a <code>macaddr</code> variable:</li>
</ul>
<pre>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
qemu-system-x86_64 -net nic,macaddr="$macaddr" -net vde <i>disk_image</i></pre>
<ul><li>Use the following script <code>qemu-mac-hasher.py</code> to generate the link-level address from the virtual machine name using a hashing function. Given that the names of virtual machines are unique, this method combines the benefits of the aforementioned methods: it generates the same link-level address each time the script is run, yet it preserves the practically zero probability of collisions.</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">qemu-mac-hasher.py</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/usr/bin/env python
# usage: qemu-mac-hasher.py &lt;VMName&gt;

import sys
import zlib

crc = str(hex(zlib.crc32(sys.argv[1].encode("utf-8")))).replace("x", "")[-8:]
print("52:54:%s%s:%s%s:%s%s:%s%s" % tuple(crc))</pre>
<p>In a script, you can use for example:
</p>
<pre>vm_name="<i>VM Name</i>"
qemu-system-x86_64 -name "$vm_name" -net nic,macaddr=$(qemu-mac-hasher.py "$vm_name") -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="User-mode_networking">User-mode networking</span></h3>
<p>By default, without any <code>-netdev</code> arguments, QEMU will use user-mode networking with a built-in DHCP server. Your virtual machines will be assigned an IP address when they run their DHCP client, and they will be able to access the physical host's network through IP masquerading done by QEMU.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> ICMPv6 will not work, as support for it is not implemented: <code>Slirp: external icmpv6 not supported yet</code>. <a href="../en/Network_configuration.html#Ping" class="mw-redirect" title="Ping">Pinging</a> an IPv6 address will not work.</div>
<p>This default configuration allows your virtual machines to easily access the Internet, provided that the host is connected to it, but the virtual machines will not be directly visible on the external network, nor will virtual machines be able to talk to each other if you start up more than one concurrently.
</p>
<p>QEMU's user-mode networking can offer more capabilities such as built-in TFTP or SMB servers, redirecting host ports to the guest (for example to allow SSH connections to the guest) or attaching guests to VLANs so that they can talk to each other. See the QEMU documentation on the <code>-net user</code> flag for more details.
</p>
<p>However, user-mode networking has limitations in both utility and performance. More advanced network configurations require the use of tap devices or other methods.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> If the host system uses <a href="../en/Systemd-networkd.html" title="Systemd-networkd">systemd-networkd</a>, make sure to symlink the <code>/etc/resolv.conf</code> file as described in <a href="../en/Systemd-networkd.html#Required_services_and_setup" title="Systemd-networkd">systemd-networkd#Required services and setup</a>, otherwise the DNS lookup in the guest system will not work.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>To use the virtio driver with user-mode networking, the option is: <code>-nic user,model=virtio-net-pci</code>.</li>
<li>You can isolate user-mode networking from the host and the outside world by adding <code>restrict=y</code>, for example: <code>-net user,restrict=y</code>
</li>
</ul>
</div>
<h3><span class="mw-headline" id="Tap_networking_with_QEMU">Tap networking with QEMU</span></h3>
<p><a href="https://en.wikipedia.org/wiki/TUN/TAP" class="extiw" title="wikipedia:TUN/TAP">Tap devices</a> are a Linux kernel feature that allows you to create virtual network interfaces that appear as real network interfaces. Packets sent to a tap interface are delivered to a userspace program, such as QEMU, that has bound itself to the interface.
</p>
<p>QEMU can use tap networking for a virtual machine so that packets sent to the tap interface will be sent to the virtual machine and appear as coming from a network interface (usually an Ethernet interface) in the virtual machine. Conversely, everything that the virtual machine sends through its network interface will appear on the tap interface.
</p>
<p>Tap devices are supported by the Linux bridge drivers, so it is possible to bridge together tap devices with each other and possibly with other host interfaces such as <code>eth0</code>. This is desirable if you want your virtual machines to be able to talk to each other, or if you want other machines on your LAN to be able to talk to the virtual machines.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> If you bridge together tap device and some host interface, such as <code>eth0</code>, your virtual machines will appear directly on the external network, which will expose them to possible attack. Depending on what resources your virtual machines have access to, you may need to take all the <a href="../en/Category:Firewalls.html" class="mw-redirect" title="Firewalls">precautions</a> you normally would take in securing a computer to secure your virtual machines. If the risk is too great, virtual machines have little resources or you set up multiple virtual machines, a better solution might be to use <a href="#Host-only_networking">host-only networking</a> and set up NAT. In this case you only need one firewall on the host instead of multiple firewalls for each guest.</div>
<p>As indicated in the user-mode networking section, tap devices offer higher networking performance than user-mode. If the guest OS supports virtio network driver, then the networking performance will be increased considerably as well. Supposing the use of the tap0 device, that the virtio driver is used on the guest, and that no scripts are used to help start/stop networking, next is part of the qemu command one should see:
</p>
<pre>-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no
</pre>
<p>But if already using a tap device with virtio networking driver, one can even boost the networking performance by enabling vhost, like:
</p>
<pre>-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on
</pre>
<p>See <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20160222161955/http://www.linux-kvm.com:80/content/how-maximize-virtio-net-performance-vhost-net">[2]</a> for more information.
</p>
<h4><span class="mw-headline" id="Host-only_networking">Host-only networking</span></h4>
<p>If the bridge is given an IP address and traffic destined for it is allowed, but no real interface (e.g. <code>eth0</code>) is connected to the bridge, then the virtual machines will be able to talk to each other and the host system. However, they will not be able to talk to anything on the external network, provided that you do not set up IP masquerading on the physical host. This configuration is called <i>host-only networking</i> by other virtualization software such as <a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>If you want to set up IP masquerading, e.g. NAT for virtual machines, see the <a href="../en/Internet_sharing.html#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a> page.</li>
<li>See <a href="../en/Network_bridge.html" title="Network bridge">Network bridge</a> for information on creating bridge.</li>
<li>You may want to have a DHCP server running on the bridge interface to service the virtual network. For example, to use the <code>172.20.0.1/16</code> subnet with <a href="../en/Dnsmasq.html" title="Dnsmasq">dnsmasq</a> as the DHCP server:</li>
</ul>
<pre># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq -C /dev/null --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254</pre>
</div>
<h4><span class="mw-headline" id="Internal_networking">Internal networking</span></h4>
<p>If you do not give the bridge an IP address and add an <a href="../en/Iptables.html" title="Iptables">iptables</a> rule to drop all traffic to the bridge in the INPUT chain, then the virtual machines will be able to talk to each other, but not to the physical host or to the outside network. This configuration is called <i>internal networking</i> by other virtualization software such as <a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a>. You will need to either assign static IP addresses to the virtual machines or run a DHCP server on one of them.
</p>
<p>By default iptables would drop packets in the bridge network. You may need to use such iptables rule to allow packets in a bridged network:
</p>
<pre># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4><span class="mw-headline" id="Bridged_networking_using_qemu-bridge-helper">Bridged networking using qemu-bridge-helper</span></h4>
<p>This method does not require a start-up script and readily accommodates multiple taps and multiple bridges. It uses <code>/usr/lib/qemu/qemu-bridge-helper</code> binary, which allows creating tap devices on an existing bridge.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>See <a href="../en/Network_bridge.html" title="Network bridge">Network bridge</a> for information on creating bridge.</li>
<li>See <a rel="nofollow" class="external free" href="https://wiki.qemu.org/Features/HelperNetworking">https://wiki.qemu.org/Features/HelperNetworking</a> for more information on QEMU's network helper.</li>
</ul>
</div>
<p>First, create a configuration file containing the names of all bridges to be used by QEMU:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu/bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">allow <i>br0</i>
allow <i>br1</i>
...</pre>
<p>Make sure <code>/etc/qemu/</code> has <code>755</code> <a href="../en/File_permissions_and_attributes.html" class="mw-redirect" title="Permissions">permissions</a>. <a rel="nofollow" class="external text" href="https://gitlab.com/qemu-project/qemu/-/issues/515">QEMU issues</a> and <a rel="nofollow" class="external text" href="https://www.gns3.com/community/discussions/gns3-cannot-work-with-qemu">GNS3 issues</a> may arise if this is not the case.
</p>
<p>Now start the virtual machine; the most basic usage to run QEMU with the default network helper and default bridge <code>br0</code>:
</p>
<pre>$ qemu-system-x86_64 -nic bridge <i>[...]</i>
</pre>
<p>Using the bridge <code>br1</code> and the virtio driver:
</p>
<pre>$ qemu-system-x86_64 -nic bridge,br=<i>br1</i>,model=virtio-net-pci <i>[...]</i>
</pre>
<h4><span class="mw-headline" id="Creating_bridge_manually">Creating bridge manually</span></h4>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> This section needs serious cleanup and may contain out-of-date information. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Since QEMU 1.1, the <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/HelperNetworking">network bridge helper</a> can set tun/tap up for you without the need for additional scripting. See <a href="#Bridged_networking_using_qemu-bridge-helper">#Bridged networking using qemu-bridge-helper</a>.</div>
<p>The following describes how to bridge a virtual machine to a host interface such as <code>eth0</code>, which is probably the most common configuration. This configuration makes it appear that the virtual machine is located directly on the external network, on the same Ethernet segment as the physical host machine.
</p>
<p>We will replace the normal Ethernet adapter with a bridge adapter and bind the normal Ethernet adapter to it.
</p>
<ul><li>Install <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>, which provides <code>brctl</code> to manipulate bridges.</li></ul>
<ul><li>Enable IPv4 forwarding:</li></ul>
<pre># sysctl -w net.ipv4.ip_forward=1
</pre>
<p>To make the change permanent, change <code>net.ipv4.ip_forward = 0</code> to <code>net.ipv4.ip_forward = 1</code> in <code>/etc/sysctl.d/99-sysctl.conf</code>.
</p>
<ul><li>Load the <code>tun</code> module and configure it to be loaded on boot. See <a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">Kernel modules</a> for details.</li></ul>
<ul><li>Optionally create the bridge. See <a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">Bridge with netctl</a> for details. Remember to name your bridge as <code>br0</code>, or change the scripts below to your bridge's name. In the <code>run-qemu</code> script below, <code>br0</code> is set up if not listed, as it is assumed that by default the host is not accessing network via the bridge.</li></ul>
<ul><li>Create the script that QEMU uses to bring up the tap adapter with <code>root:kvm</code> 750 permissions:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifup</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifup"
echo "Bringing up $1 for bridged mode..."
sudo /usr/bin/ip link set $1 up promisc on
echo "Adding $1 to br0..."
sudo /usr/bin/brctl addif br0 $1
sleep 2
</pre>
<ul><li>Create the script that QEMU uses to bring down the tap adapter in <code>/etc/qemu-ifdown</code> with <code>root:kvm</code> 750 permissions:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifdown</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifdown"
sudo /usr/bin/ip link set $1 down
sudo /usr/bin/brctl delif br0 $1
sudo /usr/bin/ip link delete dev $1
</pre>
<ul><li>Use <code>visudo</code> to add the following to your <code>sudoers</code> file:</li></ul>
<pre>Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
%kvm     ALL=NOPASSWD: QEMU
</pre>
<ul><li>You launch QEMU using the following <code>run-qemu</code> script:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">run-qemu</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/bash
: '
e.g. with img created via:
qemu-img create -f qcow2 example.img 90G
run-qemu -cdrom archlinux-x86_64.iso -boot order=d -drive file=example.img,format=qcow2 -m 4G -enable-kvm -cpu host -smp 4
run-qemu -drive file=example.img,format=qcow2 -m 4G -enable-kvm -cpu host -smp 4
'

nicbr0() {
    sudo ip link set dev $1 promisc on up &amp;&gt; /dev/null
    sudo ip addr flush dev $1 scope host &amp;&gt;/dev/null
    sudo ip addr flush dev $1 scope site &amp;&gt;/dev/null
    sudo ip addr flush dev $1 scope global &amp;&gt;/dev/null
    sudo ip link set dev $1 master br0 &amp;&gt; /dev/null
}
_nicbr0() {
    sudo ip link set $1 promisc off down &amp;&gt; /dev/null
    sudo ip link set dev $1 nomaster &amp;&gt; /dev/null
}

HASBR0="$( ip link show | grep br0 )"
if [ -z $HASBR0 ] ; then
    ROUTER="192.168.1.1"
    SUBNET="192.168.1."
    NIC=$(ip link show | grep en | grep 'state UP' | head -n 1 | cut -d":" -f 2 | xargs)
    IPADDR=$(ip addr show | grep -o "inet $SUBNET\([0-9]*\)" | cut -d ' ' -f2)
    sudo ip link add name br0 type bridge &amp;&gt; /dev/null
    sudo ip link set dev br0 up
    sudo ip addr add $IPADDR/24 brd + dev br0
    sudo ip route del default &amp;&gt; /dev/null
    sudo ip route add default via $ROUTER dev br0 onlink
    nicbr0 $NIC
    sudo iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
fi

USERID=$(whoami)
precreationg=$(ip tuntap list | cut -d: -f1 | sort)
sudo ip tuntap add user $USERID mode tap
postcreation=$(ip tuntap list | cut -d: -f1 | sort)
TAP=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))
nicbr0 $TAP

printf -v MACADDR "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
qemu-system-x86_64 -net nic,macaddr=$MACADDR,model=virtio \
    -net tap,ifname=$TAP,script=no,downscript=no,vhost=on \
    $@

_nicbr0 $TAP
sudo ip link set dev $TAP down &amp;&gt; /dev/null
sudo ip tuntap del $TAP mode tap

if [ -z $HASBR0 ] ; then
    _nicbr0 $NIC
    sudo ip addr del dev br0 $IPADDR/24 &amp;&gt; /dev/null
    sudo ip link set dev br0 down
    sudo ip link delete br0 type bridge &amp;&gt; /dev/null
    sudo ip route del default &amp;&gt; /dev/null
    sudo ip link set dev $NIC up
    sudo ip route add default via $ROUTER dev $NIC onlink &amp;&gt; /dev/null
fi
</pre>
<p>Then to launch a virtual machine, do something like this
</p>
<pre>$ run-qemu -hda <i>myvm.img</i> -m 512
</pre>
<ul><li>It is recommended for performance and security reasons to disable the <a rel="nofollow" class="external text" href="https://ebtables.netfilter.org/documentation/bridge-nf.html">firewall on the bridge</a>:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/10-disable-firewall-on-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
</pre>
<p>In order to apply the parameters described above on boot, you will also need to load the br-netfilter module on boot. Otherwise, the parameters will not exist when sysctl will try to modify them.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/modules-load.d/br_netfilter.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">br_netfilter
</pre>
<p>Run <code>sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf</code> to apply the changes immediately.
</p>
<p>See the <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Networking#Creating_network_initscripts">libvirt wiki</a> and <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=512206">Fedora bug 512206</a>. If you get errors by sysctl during boot about non-existing files, make the <code>bridge</code> module load at boot. See <a href="../en/Kernel_module.html#systemd" title="Kernel module">Kernel module#systemd</a>.
</p>
<p>Alternatively, you can configure <a href="../en/Iptables.html" title="Iptables">iptables</a> to allow all traffic to be forwarded across the bridge by adding a rule like this:
</p>
<pre>-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4><span class="mw-headline" id="Network_sharing_between_physical_device_and_a_Tap_device_through_iptables">Network sharing between physical device and a Tap device through iptables</span></h4>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Merge-arrows-2.svg" decoding="async" width="36" height="40" class="mw-file-element"></span></span><b>This article or section is a candidate for merging with <a href="../en/Internet_sharing.html" title="Internet sharing">Internet_sharing</a>.</b></p>
<div>
<b>Notes:</b> Duplication, not specific to QEMU. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>Bridged networking works fine between a wired interface (Eg. eth0), and it is easy to setup. However if the host gets connected to the network through a wireless device, then bridging is not possible.
</p>
<p>See <a href="../en/Network_bridge.html#Wireless_interface_on_a_bridge" title="Network bridge">Network bridge#Wireless interface on a bridge</a> as a reference.
</p>
<p>One way to overcome that is to setup a tap device with a static IP, making linux automatically handle the routing for it, and then forward traffic between the tap interface and the device connected to the network through iptables rules.
</p>
<p>See <a href="../en/Internet_sharing.html" title="Internet sharing">Internet sharing</a> as a reference.
</p>
<p>There you can find what is needed to share the network between devices, included tap and tun ones. The following just hints further on some of the host configurations required. As indicated in the reference above, the client needs to be configured for a static IP, using the IP assigned to the tap interface as the gateway. The caveat is that the DNS servers on the client might need to be manually edited if they change when changing from one host device connected to the network to another.
</p>
<p>To allow IP forwarding on every boot, one need to add the following lines to sysctl configuration file inside <code>/etc/sysctl.d</code>:
</p>
<pre>net.ipv4.ip_forward = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.conf.all.forwarding = 1
</pre>
<p>The iptables rules can look like:
</p>
<pre># Forwarding from/to outside
iptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT
iptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT
# NAT/Masquerade (network address translation)
iptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE
</pre>
<p>The prior supposes there are 3 devices connected to the network sharing traffic with one internal device, where for example:
</p>
<pre>INT=tap0
EXT_0=eth0
EXT_1=wlan0
EXT_2=tun0
</pre>
<p>The prior shows a forwarding that would allow sharing wired and wireless connections with the tap device.
</p>
<p>The forwarding rules shown are stateless, and for pure forwarding. One could think of restricting specific traffic, putting a firewall in place to protect the guest and others. However those would decrease the networking performance, while a simple bridge does not include any of that.
</p>
<p>Bonus:  Whether the connection is wired or wireless, if one gets connected through VPN to a remote site with a tun device, supposing the tun device opened for that connection is tun0, and the prior iptables rules are applied, then the remote connection gets also shared with the guest. This avoids the need for the guest to also open a VPN connection. Again, as the guest networking needs to be static, then if connecting the host remotely this way, one most probably will need to edit the DNS servers on the guest.
</p>
<h3><span class="mw-headline" id="Networking_with_VDE2">Networking with VDE2</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> This section needs serious cleanup and may contain out-of-date information. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<h4>
<span id="What_is_VDE.3F"></span><span class="mw-headline" id="What_is_VDE?">What is VDE?</span>
</h4>
<p>VDE stands for Virtual Distributed Ethernet. It started as an enhancement of <a href="../en/User-mode_Linux.html" title="User-mode Linux">uml</a>_switch. It is a toolbox to manage virtual networks.
</p>
<p>The idea is to create virtual switches, which are basically sockets, and to "plug" both physical and virtual machines in them. The configuration we show here is quite simple; However, VDE is much more powerful than this, it can plug virtual switches together, run them on different hosts and monitor the traffic in the switches. You are invited to read <a rel="nofollow" class="external text" href="https://wiki.virtualsquare.org/">the documentation of the project</a>.
</p>
<p>The advantage of this method is you do not have to add sudo privileges to your users. Regular users should not be allowed to run modprobe.
</p>
<h4><span class="mw-headline" id="Basics">Basics</span></h4>
<p>VDE support can be <a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">installed</a> via the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=vde2">vde2</a></span> package.
</p>
<p>In our config, we use tun/tap to create a virtual interface on my host. Load the <code>tun</code> module (see <a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">Kernel modules</a> for details):
</p>
<pre># modprobe tun
</pre>
<p>Now create the virtual switch:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
</pre>
<p>This line creates the switch, creates <code>tap0</code>, "plugs" it, and allows the users of the group <code>users</code> to use it.
</p>
<p>The interface is plugged in but not configured yet. To configure it, run this command:
</p>
<pre># ip addr add 192.168.100.254/24 dev tap0
</pre>
<p>Now, you just have to run KVM with these <code>-net</code> options as a normal user:
</p>
<pre>$ qemu-system-x86_64 -net nic -net vde -hda <i>[...]</i>
</pre>
<p>Configure networking for your guest as you would do in a physical network.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> You might want to set up NAT on tap device to access the internet from the virtual machine. See <a href="../en/Internet_sharing.html#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a> for more information.</div>
<h4><span class="mw-headline" id="Startup_scripts">Startup scripts</span></h4>
<p>Example of main script starting VDE:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/scripts/qemu-network-env</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
# QEMU/VDE network environment preparation script

# The IP configuration for the tap device that will be used for
# the virtual machine network:

TAP_DEV=tap0
TAP_IP=192.168.100.254
TAP_MASK=24
TAP_NETWORK=192.168.100.0

# Host interface
NIC=eth0

case "$1" in
  start)
        echo -n "Starting VDE network for QEMU: "

        # If you want tun kernel module to be loaded by script uncomment here
	#modprobe tun 2&gt;/dev/null
	## Wait for the module to be loaded
 	#while ! lsmod | grep -q "^tun"; do echo "Waiting for tun device"; sleep 1; done

        # Start tap switch
        vde_switch -tap "$TAP_DEV" -daemon -mod 660 -group users

        # Bring tap interface up
        ip address add "$TAP_IP"/"$TAP_MASK" dev "$TAP_DEV"
        ip link set "$TAP_DEV" up

        # Start IP Forwarding
        echo "1" &gt; /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE
        ;;
  stop)
        echo -n "Stopping VDE network for QEMU: "
        # Delete the NAT rules
        iptables -t nat -D POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE

        # Bring tap interface down
        ip link set "$TAP_DEV" down

        # Kill VDE switch
        pgrep vde_switch | xargs kill -TERM
        ;;
  restart|reload)
        $0 stop
        sleep 1
        $0 start
        ;;
  *)
        echo "Usage: $0 {start|stop|restart|reload}"
        exit 1
esac
exit 0
</pre>
<p>Example of systemd service using the above script:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu-network-env.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Manage VDE Switch

[Service]
Type=oneshot
ExecStart=/etc/systemd/scripts/qemu-network-env start
ExecStop=/etc/systemd/scripts/qemu-network-env stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</pre>
<p>Change permissions for <code>qemu-network-env</code> to be <a href="../en/Help:Reading.html#Make_executable" class="mw-redirect" title="Executable">executable</a>. 
</p>
<p>You can <a href="../en/Help:Reading.html#Control_of_systemd_units" class="mw-redirect" title="Start">start</a> <code>qemu-network-env.service</code> as usual.
</p>
<h4><span class="mw-headline" id="Alternative_method">Alternative method</span></h4>
<p>If the above method does not work or you do not want to mess with kernel configs, TUN, dnsmasq, and iptables you can do the following for the same result.
</p>
<pre># vde_switch -daemon -mod 660 -group users
# slirpvde --dhcp --daemon
</pre>
<p>Then, to start the virtual machine with a connection to the network of the host:
</p>
<pre>$ qemu-system-x86_64 -net nic,macaddr=52:54:00:00:EE:03 -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="VDE2_Bridge">VDE2 Bridge</span></h3>
<p>Based on <a rel="nofollow" class="external text" href="https://selamatpagicikgu.wordpress.com/2011/06/08/quickhowto-qemu-networking-using-vde-tuntap-and-bridge/">quickhowto: qemu networking using vde, tun/tap, and bridge</a> graphic. Any virtual machine connected to vde is externally exposed. For example, each virtual machine can receive DHCP configuration directly from your ADSL router.
</p>
<h4><span class="mw-headline" id="Basics_2">Basics</span></h4>
<p>Remember that you need <code>tun</code> module and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span> package.
</p>
<p>Create the vde2/tap device:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
# ip link set tap0 up
</pre>
<p>Create bridge:
</p>
<pre># brctl addbr br0
</pre>
<p>Add devices:
</p>
<pre># brctl addif br0 eth0
# brctl addif br0 tap0
</pre>
<p>And configure bridge interface:
</p>
<pre># dhcpcd br0
</pre>
<h4><span class="mw-headline" id="Startup_scripts_2">Startup scripts</span></h4>
<p>All devices must be set up. And only the bridge needs an IP address. For physical devices on the bridge (e.g. <code>eth0</code>), this can be done with <a href="../en/Netctl.html" title="Netctl">netctl</a> using a custom Ethernet profile with:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/netctl/ethernet-noip</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Description='A more versatile static Ethernet connection'
Interface=eth0
Connection=ethernet
IP=no</pre>
<p>The following custom systemd service can be used to create and activate a VDE2 tap interface for users in the <code>users</code> user group.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/vde2@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Network Connectivity for %i
Wants=network.target
Before=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users
ExecStart=/usr/bin/ip link set dev %i up
ExecStop=/usr/bin/ip addr flush dev %i
ExecStop=/usr/bin/ip link set dev %i down

[Install]
WantedBy=multi-user.target</pre>
<p>And finally, you can create the <a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">bridge interface with netctl</a>.
</p>
<h3><span class="mw-headline" id="Shorthand_configuration">Shorthand configuration</span></h3>
<p>If you are using QEMU with various networking options a lot, you probably have created a lot of <code>-netdev</code> and <code>-device</code> argument pairs, which gets quite repetitive. You can instead use the <code>-nic</code> argument to combine <code>-netdev</code> and <code>-device</code> together, so that, for example, these arguments:
</p>
<pre>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</pre>
<p>become:
</p>
<pre>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</pre>
<p>Notice the lack of network IDs, and that the device was created with <code>model=</code>. The first half of the <code>-nic</code> parameters are <code>-netdev</code> parameters, whereas the second half (after <code>model=</code>) are related with the device. The same parameters (for example, <code>smb=</code>) are used. To completely disable the networking use <code>-nic none</code>.
</p>
<p>See <a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/6.0/system/net.html">QEMU networking documentation</a> for more information on parameters you can use.
</p>
<h2><span class="mw-headline" id="Graphic_card">Graphic card</span></h2>
<p>QEMU can emulate a standard graphic card text mode using <code>-display curses</code> command line option. This allows to type text and see text output directly inside a text terminal. Alternatively, <code>-nographic</code> serves a similar purpose.
</p>
<p>QEMU can emulate several types of VGA card. The card type is passed in the <code>-vga <i>type</i></code> command line option and can be <code>std</code>, <code>qxl</code>, <code>vmware</code>, <code>virtio</code>, <code>cirrus</code> or <code>none</code>.
</p>
<h3><span class="mw-headline" id="std">std</span></h3>
<p>With <code>-vga std</code> you can get a resolution of up to 2560 x 1600 pixels without requiring guest drivers. This is the default since QEMU 2.2.
</p>
<h3><span class="mw-headline" id="qxl">qxl</span></h3>
<p>QXL is a paravirtual graphics driver with 2D support. To use it, pass the <code>-vga qxl</code> option and install drivers in the guest. You may want to use <a href="#SPICE">#SPICE</a> for improved graphical performance when using QXL.
</p>
<p>On Linux guests, the <code>qxl</code> and <code>bochs_drm</code> kernel modules must be loaded in order to gain a decent performance.
</p>
<p>Default VGA memory size for QXL devices is 16M which is sufficient to drive resolutions approximately up to QHD (2560x1440). To enable higher resolutions, <a href="#Multi-monitor_support">increase vga_memmb</a>.
</p>
<h3><span class="mw-headline" id="vmware">vmware</span></h3>
<p>Although it is a bit buggy, it performs better than std and cirrus. Install the VMware drivers <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a></span> and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a></span> for Arch Linux guests.
</p>
<h3><span class="mw-headline" id="virtio">virtio</span></h3>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> is a paravirtual 3D graphics driver based on <a rel="nofollow" class="external text" href="https://virgil3d.github.io/">virgl</a>. It's mature, currently supporting only Linux guests with <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa">mesa</a></span> compiled with the option <code>gallium-drivers=virgl</code>.
</p>
<p>To enable 3D acceleration on the guest system, select this vga with <code>-device virtio-vga-gl</code> and enable the OpenGL context in the display device with <code>-display sdl,gl=on</code> or <code>-display gtk,gl=on</code> for the SDL and GTK display output respectively. Successful configuration can be confirmed looking at the kernel log in the guest:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># dmesg | grep drm </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</pre>
<h3><span class="mw-headline" id="cirrus">cirrus</span></h3>
<p>The cirrus graphical adapter was the default <a rel="nofollow" class="external text" href="https://wiki.qemu.org/ChangeLog/2.2#VGA">before 2.2</a>. It <a rel="nofollow" class="external text" href="https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">should not</a> be used on modern systems.
</p>
<h3><span class="mw-headline" id="none">none</span></h3>
<p>This is like a PC that has no VGA card at all. You would not even be able to access it with the <code>-vnc</code> option. Also, this is different from the <code>-nographic</code> option which lets QEMU emulate a VGA card, but disables the SDL display.
</p>
<h2><span class="mw-headline" id="SPICE">SPICE</span></h2>
<p>The <a rel="nofollow" class="external text" href="https://www.spice-space.org/">SPICE project</a> aims to provide a complete open source solution for remote access to virtual machines in a seamless way.
</p>
<h3><span class="mw-headline" id="Enabling_SPICE_support_on_the_host">Enabling SPICE support on the host</span></h3>
<p>The following is an example of booting with SPICE as the remote desktop protocol, including the support for copy and paste from host:
</p>
<pre>$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>The parameters have the following meaning:
</p>
<ol>
<li>
<code>-device virtio-serial-pci</code> adds a virtio-serial device</li>
<li>
<code>-spice port=5930,disable-ticketing=on</code> set TCP port <code>5930</code> for spice channels listening and allow client to connect without authentication<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Using <a href="https://en.wikipedia.org/wiki/Unix_socket" class="extiw" title="wikipedia:Unix socket">Unix sockets</a> instead of TCP ports does not involve using network stack on the host system. It does not imply that packets are encapsulated and decapsulated to use the network and the related protocol. The sockets are identified solely by the inodes on the hard drive. It is therefore considered better for performance. Use instead <code>-spice unix=on,addr=/tmp/vm_spice.socket,disable-ticketing=on</code>.</div>
</li>
<li>
<code>-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0</code> opens a port for spice vdagent in the virtio-serial device,</li>
<li>
<code>-chardev spicevmc,id=spicechannel0,name=vdagent</code> adds a spicevmc chardev for that port. It is important that the <code>chardev=</code> option of the <code>virtserialport</code> device matches the <code>id=</code> option given to the <code>chardev</code> option (<code>spicechannel0</code> in this example). It is also important that the port name is <code>com.redhat.spice.0</code>, because that is the namespace where vdagent is looking for in the guest. And finally, specify <code>name=vdagent</code> so that spice knows what this channel is for.</li>
</ol>
<h3><span class="mw-headline" id="Connecting_to_the_guest_with_a_SPICE_client">Connecting to the guest with a SPICE client</span></h3>
<p>A SPICE client is necessary to connect to the guest. In Arch, the following clients are available:
</p>
<ul><li>
<b>virt-viewer</b> — SPICE client recommended by the protocol developers, a subset of the virt-manager project.</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://virt-manager.org/">https://virt-manager.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>
</dd></dl>
<ul><li>
<b>spice-gtk</b> — SPICE GTK client, a subset of the SPICE project. Embedded into other applications as a widget.</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://www.spice-space.org/">https://www.spice-space.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span>
</dd></dl>
<p>For clients that run on smartphone or on other platforms, refer to the <i>Other clients</i> section in <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">spice-space download</a>.
</p>
<h4><span class="mw-headline" id="Manually_running_a_SPICE_client">Manually running a SPICE client</span></h4>
<p>One way of connecting to a guest listening on Unix socket <code>/tmp/vm_spice.socket</code> is to manually run the SPICE client using <code>$ remote-viewer spice+unix:///tmp/vm_spice.socket</code> or <code>$ spicy --uri="spice+unix:///tmp/vm_spice.socket"</code>, depending on the desired client. Since QEMU in SPICE mode acts similarly to a remote desktop server, it may be more convenient to run QEMU in daemon mode with the <code>-daemonize</code> parameter.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
To connect to the guest through SSH tunneling, the following type of command can be used: <pre>$ ssh -fL 5999:localhost:5930 <i>my.domain.org</i> sleep 10; spicy -h 127.0.0.1 -p 5999</pre>
<p>This example connects <i>spicy</i> to the local port <code>5999</code> which is forwarded through SSH to the guest's SPICE server located at the address <i>my.domain.org</i>, port <code>5930</code>.
Note the <code>-f</code> option that requests ssh to execute the command <code>sleep 10</code> in the background. This way, the ssh session runs while the client is active and auto-closes once the client ends.
</p>
</div>
<h4><span class="mw-headline" id="Running_a_SPICE_client_with_QEMU">Running a SPICE client with QEMU</span></h4>
<p>QEMU can automatically start a SPICE client with an appropriate socket, if the display is set to SPICE with the <code>-display spice-app</code> parameter. This will use the system's default SPICE client as the viewer, determined by your <a href="../en/XDG_MIME_Applications.html#mimeapps.list" title="XDG MIME Applications">mimeapps.list</a> files.
</p>
<h3><span class="mw-headline" id="Enabling_SPICE_support_on_the_guest">Enabling SPICE support on the guest</span></h3>
<p>For <b>Arch Linux guests</b>, for improved support for multiple monitors or clipboard sharing, the following packages should be installed:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-vdagent">spice-vdagent</a></span>: Spice agent xorg client that enables copy and paste between client and X-session and more. (Refer to this <a rel="nofollow" class="external text" href="https://github.com/systemd/systemd/issues/18791">issue</a>, until fixed, for workarounds to get this to work on non-GNOME desktops.)</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-qxl">xf86-video-qxl</a></span>: Xorg X11 qxl video driver</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/x-resize/">x-resize</a></span><sup><small>AUR</small></sup>: Desktop environments other than GNOME do not react automatically when the SPICE client window is resized. This package uses a <a href="../en/Udev.html" title="Udev">udev</a> rule and <a href="../en/Xrandr.html" title="Xrandr">xrandr</a> to implement auto-resizing for all X11-based desktop environments and window managers.</li>
</ul>
<p>For guests under <b>other operating systems</b>, refer to the <i>Guest</i> section in spice-space <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">download</a>.
</p>
<h3><span class="mw-headline" id="Password_authentication_with_SPICE">Password authentication with SPICE</span></h3>
<p>If you want to enable password authentication with SPICE you need to remove <code>disable-ticketing</code> from the <code>-spice</code> argument and instead add <code>password=<i>yourpassword</i></code>. For example:
</p>
<pre>$ qemu-system-x86_64 -vga qxl -spice port=5900,password=<i>yourpassword</i> -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>Your SPICE client should now ask for the password to be able to connect to the SPICE server.
</p>
<h3><span class="mw-headline" id="TLS_encrypted_communication_with_SPICE">TLS encrypted communication with SPICE</span></h3>
<p>You can also configure TLS encryption for communicating with the SPICE server. First, you need to have a directory which contains the following files (the names must be exactly as indicated):
</p>
<ul>
<li>
<code>ca-cert.pem</code>: the CA master certificate.</li>
<li>
<code>server-cert.pem</code>: the server certificate signed with <code>ca-cert.pem</code>.</li>
<li>
<code>server-key.pem</code>: the server private key.</li>
</ul>
<p>An example of generation of self-signed certificates with your own generated CA for your server is shown in the <a rel="nofollow" class="external text" href="https://www.spice-space.org/spice-user-manual.html#_generating_self_signed_certificates">Spice User Manual</a>.
</p>
<p>Afterwards, you can run QEMU with SPICE as explained above but using the following <code>-spice</code> argument: <code>-spice tls-port=5901,password=<i>yourpassword</i>,x509-dir=<i>/path/to/pki_certs</i></code>, where <code><i>/path/to/pki_certs</i></code> is the directory path that contains the three needed files shown earlier.
</p>
<p>It is now possible to connect to the server using <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>:
</p>
<pre>$ remote-viewer spice://<i>hostname</i>?tls-port=5901 --spice-ca-file=<i>/path/to/ca-cert.pem</i> --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<p>Keep in mind that the <code>--spice-host-subject</code> parameter needs to be set according to your <code>server-cert.pem</code> subject. You also need to copy <code>ca-cert.pem</code> to every client to verify the server certificate.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> You can get the subject line of the server certificate in the correct format for <code>--spice-host-subject</code> (with entries separated by commas) using the following command: <pre>$ openssl x509 -noout -subject -in server-cert.pem | cut -d' ' -f2- | sed 's/\///' | sed 's/\//,/g'</pre>
</div>
<p>The equivalent <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span> command is:
</p>
<pre>$ spicy -h <i>hostname</i> -s 5901 --spice-ca-file=ca-cert.pem --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<h2><span class="mw-headline" id="VNC">VNC</span></h2>
<p>One can add the <code>-vnc :<i>X</i></code> option to have QEMU redirect the VGA display to the VNC session. Substitute <code><i>X</i></code> for the number of the display (0 will then listen on 5900, 1 on 5901...).
</p>
<pre>$ qemu-system-x86_64 -vnc :0
</pre>
<p>An example is also provided in the <a href="#Starting_QEMU_virtual_machines_on_boot">#Starting QEMU virtual machines on boot</a> section.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> The default VNC server setup does not use any form of authentication. Any user can connect from any host.</div>
<h3><span class="mw-headline" id="Basic_password_authentication">Basic password authentication</span></h3>
<p>An access password can be setup easily by using the <code>password</code> option. The password must be indicated in the QEMU monitor and connection is only possible once the password is provided.
</p>
<pre>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<p>In the QEMU monitor, password is set using the command <code>change vnc password</code> and then indicating the password.
</p>
<p>The following command line directly runs vnc with a password:
</p>
<pre>$ printf "change vnc password\n%s\n" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> The password is limited to 8 characters and can be guessed through brute force attack. More elaborated protection is strongly recommended for public network.</div>
<h2><span class="mw-headline" id="Audio">Audio</span></h2>
<h3><span class="mw-headline" id="Creating_an_audio_backend">Creating an audio backend</span></h3>
<p>The <code>-audiodev</code> flag sets the audio backend driver on the host and its options.
</p>
<p>To list availabe audio backend drivers:
</p>
<pre>$ qemu-system-x86_64 -audiodev help
</pre>
<p>Their optional settings are detailed in the <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> man page.
</p>
<p>At the bare minimum, one need to choose an audio backend and set an id, for <a href="../en/PulseAudio.html" title="PulseAudio">PulseAudio</a> for example:
</p>
<pre>-audiodev pa,id=snd0
</pre>
<h3><span class="mw-headline" id="Using_the_audio_backend">Using the audio backend</span></h3>
<h4><span class="mw-headline" id="Intel_HD_Audio">Intel HD Audio</span></h4>
<p>For Intel HD Audio emulation, add both controller and codec devices. To list the available Intel HDA Audio devices:
</p>
<pre>$ qemu-system-x86_64 -device help | grep hda
</pre>
<p>Add the audio controller:
</p>
<pre>-device ich9-intel-hda
</pre>
<p>Also, add the audio codec and map it to a host audio backend id:
</p>
<pre>-device hda-output,audiodev=snd0
</pre>
<h4><span class="mw-headline" id="Intel_82801AA_AC97">Intel 82801AA AC97</span></h4>
<p>For AC97 emulation just add the audio card device and map it to a host audio backend id:
</p>
<pre>-device AC97,audiodev=snd0
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>If the audiodev backend is not provided, QEMU looks up for it and adds it automatically, this only works for a single audiodev. For example <code>-device intel-hda -device hda-duplex</code> will emulate <code>intel-hda</code> on the guest using the default audiodev backend.</li>
<li>Video graphic card emulated drivers for the guest machine may also cause a problem with the sound quality. Test one by one to make it work. You can list possible options with <code>qemu-system-x86_64 -h | grep vga</code>.</li>
</ul>
</div>
<h4><span class="mw-headline" id="VirtIO_sound">VirtIO sound</span></h4>
<p>VirtIO sound is also available since QEMU 8.2.0. The usage is:
</p>
<pre>-device virtio-sound-pci,audiodev=my_audiodev -audiodev alsa,id=my_audiodev
</pre>
<p>More information can be found in <a rel="nofollow" class="external text" href="https://qemu-project.gitlab.io/qemu/system/devices/virtio-snd.html">QEMU documentation</a>.
</p>
<h2><span class="mw-headline" id="Installing_virtio_drivers">Installing virtio drivers</span></h2>
<p>QEMU offers guests the ability to use paravirtualized block and network devices using the <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a> drivers, which provide better performance and lower overhead.
</p>
<ul><li>A virtio block device requires the option <code>-drive</code> for passing a disk image, with parameter <code>if=virtio</code>:</li></ul>
<pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=<b>virtio</b>
</pre>
<ul><li>Almost the same goes for the network:</li></ul>
<pre>$ qemu-system-x86_64 -nic user,model=<b>virtio-net-pci</b>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> This will only work if the guest machine has drivers for virtio devices. Linux does, and the required drivers are included in Arch Linux, but there is no guarantee that virtio devices will work with other operating systems.</div>
<h3><span class="mw-headline" id="Preparing_an_Arch_Linux_guest">Preparing an Arch Linux guest</span></h3>
<p>To use virtio devices after an Arch Linux guest has been installed, the following modules must be loaded in the guest: <code>virtio</code>, <code>virtio_pci</code>, <code>virtio_blk</code>, <code>virtio_net</code>, and <code>virtio_ring</code>. For 32-bit guests, the specific "virtio" module is not necessary.
</p>
<p>If you want to boot from a virtio disk, the initial ramdisk must contain the necessary modules. By default, this is handled by <a href="../en/Mkinitcpio.html" title="Mkinitcpio">mkinitcpio</a>'s <code>autodetect</code> hook. Otherwise use the <code>MODULES</code> array in <code>/etc/mkinitcpio.conf</code> to include the necessary modules and rebuild the initial ramdisk.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">MODULES=(virtio virtio_blk virtio_pci virtio_net)</pre>
<p>Virtio disks are recognized with the prefix <code><b>v</b></code> (e.g. <code><b>v</b>da</code>, <code><b>v</b>db</code>, etc.); therefore, changes must be made in at least <code>/etc/fstab</code> and <code>/boot/grub/grub.cfg</code> when booting from a virtio disk.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> When referencing disks by <a href="../en/Persistent_block_device_naming.html#by-uuid" class="mw-redirect" title="UUID">UUID</a> in both <code>/etc/fstab</code> and boot loader, nothing has to be done.</div>
<p>Further information on paravirtualization with KVM can be found <a rel="nofollow" class="external text" href="https://www.linux-kvm.org/page/Boot_from_virtio_block_device">here</a>.
</p>
<p>You might also want to install <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span> to implement support for QMP commands that will enhance the hypervisor management capabilities.
</p>
<h3><span class="mw-headline" id="Preparing_a_Windows_guest">Preparing a Windows guest</span></h3>
<h4><span class="mw-headline" id="Virtio_drivers_for_Windows">Virtio drivers for Windows</span></h4>
<p>Windows does not come with the virtio drivers. The latest and stable versions of the drivers are regularly built by Fedora, details on downloading the drivers are given on <a rel="nofollow" class="external text" href="https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md">virtio-win on GitHub</a>. In the following sections we will mostly use the stable ISO file provided here: <a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">virtio-win.iso</a>. Alternatively, use <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/virtio-win/">virtio-win</a></span><sup><small>AUR</small></sup>.
</p>
<h4><span class="mw-headline" id="Block_device_drivers">Block device drivers</span></h4>
<h5><span class="mw-headline" id="New_Install_of_Windows">New Install of Windows</span></h5>
<p>The drivers need to be loaded during installation, the procedure is to load the ISO image with the virtio drivers in a cdrom device along with the primary disk device and the Windows ISO install media:
</p>
<pre>$ qemu-system-x86_64 ... \
-drive file=<i>disk_image</i>,index=0,media=disk,if=virtio \
-drive file=<i>windows.iso</i>,index=2,media=cdrom \
-drive file=<i>virtio-win.iso</i>,index=3,media=cdrom \
...
</pre>
<p>During the installation, at some stage, the Windows installer will ask "Where do you want to install Windows?", it will give a warning that no disks are found. Follow the example instructions below (based on Windows Server 2012 R2 with Update).
</p>
<ul>
<li>Select the option <i>Load Drivers</i>.</li>
<li>Uncheck the box for <i>Hide drivers that are not compatible with this computer's hardware</i>.</li>
<li>Click the browse button and open the CDROM for the virtio iso, usually named "virtio-win-XX".</li>
<li>Now browse to <code>E:\viostor\[your-os]\amd64</code>, select it, and confirm.</li>
</ul>
<p>You should now see your virtio disk(s) listed here, ready to be selected, formatted and installed to.
</p>
<h5><span class="mw-headline" id="Change_existing_Windows_virtual_machine_to_use_virtio">Change existing Windows virtual machine to use virtio</span></h5>
<p>Modifying an existing Windows guest for booting from virtio disk requires that the virtio driver is loaded by the guest at boot time.
We will therefore need to teach Windows to load the virtio driver at boot time before being able to boot a disk image in virtio mode.
</p>
<p>To achieve that, first create a new disk image that will be attached in virtio mode and trigger the search for the driver:
</p>
<pre>$ qemu-img create -f qcow2 <i>dummy.qcow2</i> 1G
</pre>
<p>Run the original Windows guest with the boot disk still in IDE mode, the fake disk in virtio mode and the driver ISO image.
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>disk_image</i>,if=ide -drive file=<i>dummy.qcow2</i>,if=virtio -cdrom virtio-win.iso
</pre>
<p>Windows will detect the fake disk and look for a suitable driver. If it fails, go to <i>Device Manager</i>, locate the SCSI drive with an exclamation mark icon (should be open), click <i>Update driver</i> and select the virtual CD-ROM. Do not navigate to the driver folder within the CD-ROM, simply select the CD-ROM drive and Windows will find the appropriate driver automatically (tested for Windows 7 SP1).
</p>
<p>Request Windows to boot in safe mode next time it starts up. This can be done using the <i>msconfig.exe</i> tool in Windows. In safe mode all the drivers will be loaded at boot time including the new virtio driver. Once Windows knows that the virtio driver is required at boot it will memorize it for future boot.
</p>
<p>Once instructed to boot in safe mode, you can turn off the virtual machine and launch it again, now with the boot disk attached in virtio mode:
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>disk_image</i>,if=virtio
</pre>
<p>You should boot in safe mode with virtio driver loaded, you can now return to <i>msconfig.exe</i> disable safe mode boot and restart Windows.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> If you encounter the blue screen of death using the <code>if=virtio</code> parameter, it probably means the virtio disk driver is not installed or not loaded at boot time, reboot in safe mode and check your driver configuration.</div>
<h4><span class="mw-headline" id="Network_drivers">Network drivers</span></h4>
<p>Installing virtio network drivers is a bit easier, simply add the <code>-nic</code> argument.
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>windows_disk_image</i>,if=virtio -nic user,model=virtio-net-pci -cdrom virtio-win.iso
</pre>
<p>Windows will detect the network adapter and try to find a driver for it. If it fails, go to the <i>Device Manager</i>, locate the network adapter with an exclamation mark icon (should be open), click <i>Update driver</i> and select the virtual CD-ROM. Do not forget to select the checkbox which says to search for directories recursively.
</p>
<h4><span class="mw-headline" id="Balloon_driver">Balloon driver</span></h4>
<p>If you want to track you guest memory state (for example via <code>virsh</code> command <code>dommemstat</code>) or change guest's memory size in runtime (you still will not be able to change memory size, but can limit memory usage via inflating balloon driver) you will need to install guest balloon driver.
</p>
<p>For this you will need to go to <i>Device Manager</i>, locate <i>PCI standard RAM Controller</i> in <i>System devices</i> (or unrecognized PCI controller from <i>Other devices</i>) and choose <i>Update driver</i>. In opened window you will need to choose <i>Browse my computer...</i> and select the CD-ROM (and do not forget the <i>Include subdirectories</i> checkbox). Reboot after installation. This will install the driver and you will be able to inflate the balloon (for example via hmp command <code>balloon <i>memory_size</i></code>, which will cause balloon to take as much memory as possible in order to shrink the guest's available memory size to <i>memory_size</i>). However, you still will not be able to track guest memory state. In order to do this you will need to install <i>Balloon</i> service properly. For that open command line as administrator, go to the CD-ROM, <i>Balloon</i> directory and deeper, depending on your system and architecture. Once you are in <i>amd64</i> (<i>x86</i>) directory, run <code>blnsrv.exe -i</code> which will do the installation. After that <code>virsh</code> command <code>dommemstat</code> should be outputting all supported values.
</p>
<h3><span class="mw-headline" id="Preparing_a_FreeBSD_guest">Preparing a FreeBSD guest</span></h3>
<p>Install the <code>emulators/virtio-kmod</code> port if you are using FreeBSD 8.3 or later up until 10.0-CURRENT where they are included into the kernel. After installation, add the following to your <code>/boot/loader.conf</code> file:
</p>
<pre>virtio_load="YES"
virtio_pci_load="YES"
virtio_blk_load="YES"
if_vtnet_load="YES"
virtio_balloon_load="YES"</pre>
<p>Then modify your <code>/etc/fstab</code> by doing the following:
</p>
<pre># sed -ibak "s/ada/vtbd/g" /etc/fstab
</pre>
<p>And verify that <code>/etc/fstab</code> is consistent. If anything goes wrong, just boot into a rescue CD and copy <code>/etc/fstab.bak</code> back to <code>/etc/fstab</code>.
</p>
<h2><span class="mw-headline" id="QEMU_monitor">QEMU monitor</span></h2>
<p>While QEMU is running, a monitor console is provided in order to provide several ways to interact with the virtual machine running. The QEMU monitor offers interesting capabilities such as obtaining information about the current virtual machine, hotplugging devices, creating snapshots of the current state of the virtual machine, etc. To see the list of all commands, run <code>help</code> or <code>?</code> in the QEMU monitor console or review the relevant section of the <a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/system/monitor.html">official QEMU documentation</a>.
</p>
<h3><span class="mw-headline" id="Accessing_the_monitor_console">Accessing the monitor console</span></h3>
<h4><span class="mw-headline" id="Graphical_view">Graphical view</span></h4>
<p>When using the <code>std</code> default graphics option, one can access the QEMU monitor by pressing <code>Ctrl+Alt+2</code> or by clicking <i>View &gt; compatmonitor0</i> in the QEMU window. To return to the virtual machine graphical view either press <code>Ctrl+Alt+1</code> or click <i>View &gt; VGA</i>.
</p>
<p>However, the standard method of accessing the monitor is not always convenient and does not work in all graphic outputs QEMU supports.
</p>
<h4><span class="mw-headline" id="Telnet">Telnet</span></h4>
<p>To enable <a href="../en/Telnet.html" title="Telnet">telnet</a>, run QEMU with the <code>-monitor telnet:127.0.0.1:<i>port</i>,server,nowait</code> parameter. When the virtual machine is started you will be able to access the monitor via telnet:
</p>
<pre>$ telnet 127.0.0.1 <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> If <code>127.0.0.1</code> is specified as the IP to listen it will be only possible to connect to the monitor from the same host QEMU is running on. If connecting from remote hosts is desired, QEMU must be told to listen <code>0.0.0.0</code> as follows: <code>-monitor telnet:0.0.0.0:<i>port</i>,server,nowait</code>. Keep in mind that it is recommended to have a <a href="../en/Category:Firewalls.html" class="mw-redirect" title="Firewall">firewall</a> configured in this case or make sure your local network is completely trustworthy since this connection is completely unauthenticated and unencrypted.</div>
<h4><span class="mw-headline" id="UNIX_socket">UNIX socket</span></h4>
<p>Run QEMU with the <code>-monitor unix:<i>socketfile</i>,server,nowait</code> parameter. Then you can connect with either <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=socat">socat</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nmap">nmap</a></span> or <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span>.
</p>
<p>For example, if QEMU is run via:
</p>
<pre>$ qemu-system-x86_64 -monitor unix:/tmp/monitor.sock,server,nowait <i>[...]</i>
</pre>
<p>It is possible to connect to the monitor with:
</p>
<pre>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</pre>
<p>Or with:
</p>
<pre>$ nc -U /tmp/monitor.sock
</pre>
<p>Alternatively with <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nmap">nmap</a></span>:
</p>
<pre>$ ncat -U /tmp/monitor.sock
</pre>
<h4><span class="mw-headline" id="TCP">TCP</span></h4>
<p>You can expose the monitor over TCP with the argument <code>-monitor tcp:127.0.0.1:<i>port</i>,server,nowait</code>. Then connect with netcat, either <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span> or <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a></span> by running:
</p>
<pre>$ nc 127.0.0.1 <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> In order to be able to connect to the tcp socket from other devices other than the same host QEMU is being run on you need to listen to <code>0.0.0.0</code> like explained in the telnet case. The same security warnings apply in this case as well.</div>
<h4>
<span id="Standard_I.2FO"></span><span class="mw-headline" id="Standard_I/O">Standard I/O</span>
</h4>
<p>It is possible to access the monitor automatically from the same terminal QEMU is being run by running it with the argument <code>-monitor stdio</code>.
</p>
<h3><span class="mw-headline" id="Sending_keyboard_presses_to_the_virtual_machine_using_the_monitor_console">Sending keyboard presses to the virtual machine using the monitor console</span></h3>
<p>Some combinations of keys may be difficult to perform on virtual machines due to the host intercepting them instead in some configurations (a notable example is the <code>Ctrl+Alt+F*</code> key combinations, which change the active tty). To avoid this problem, the problematic combination of keys may be sent via the monitor console instead. Switch to the monitor and use the <code>sendkey</code> command to forward the necessary keypresses to the virtual machine. For example:
</p>
<pre>(qemu) sendkey ctrl-alt-f2
</pre>
<h3><span class="mw-headline" id="Creating_and_managing_snapshots_via_the_monitor_console">Creating and managing snapshots via the monitor console</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> This feature will <b>only</b> work when the virtual machine disk image is in <i>qcow2</i> format. It will not work with <i>raw</i> images.</div>
<p>It is sometimes desirable to save the current state of a virtual machine and having the possibility of reverting the state of the virtual machine to that of a previously saved snapshot at any time. The QEMU monitor console provides the user with the necessary utilities to create snapshots, manage them, and revert the machine state to a saved snapshot.
</p>
<ul>
<li>Use <code>savevm <i>name</i></code> in order to create a snapshot with the tag <i>name</i>.</li>
<li>Use <code>loadvm <i>name</i></code> to revert the virtual machine to the state of the snapshot <i>name</i>.</li>
<li>Use <code>delvm <i>name</i></code> to delete the snapshot tagged as <i>name</i>.</li>
<li>Use <code>info snapshots</code> to see a list of saved snapshots. Snapshots are identified by both an auto-incremented ID number and a text tag (set by the user on snapshot creation).</li>
</ul>
<h3><span class="mw-headline" id="Running_the_virtual_machine_in_immutable_mode">Running the virtual machine in immutable mode</span></h3>
<p>It is possible to run a virtual machine in a frozen state so that all changes will be discarded when the virtual machine is powered off just by running QEMU with the <code>-snapshot</code> parameter. When the disk image is written by the guest, changes will be saved in a temporary file in <code>/tmp</code> and will be discarded when QEMU halts.
</p>
<p>However, if a machine is running in frozen mode it is still possible to save the changes to the disk image if it is afterwards desired by using the monitor console and running the following command:
</p>
<pre>(qemu) commit all
</pre>
<p>If snapshots are created when running in frozen mode they will be discarded as soon as QEMU is exited unless changes are explicitly commited to disk, as well.
</p>
<h3><span class="mw-headline" id="Pause_and_power_options_via_the_monitor_console">Pause and power options via the monitor console</span></h3>
<p>Some operations of a physical machine can be emulated by QEMU using some monitor commands:
</p>
<ul>
<li>
<code>system_powerdown</code> will send an ACPI shutdown request to the virtual machine. This effect is similar to the power button in a physical machine.</li>
<li>
<code>system_reset</code> will reset the virtual machine similarly to a reset button in a physical machine. This operation can cause data loss and file system corruption since the virtual machine is not cleanly restarted.</li>
<li>
<code>stop</code> will pause the virtual machine.</li>
<li>
<code>cont</code> will resume a virtual machine previously paused.</li>
</ul>
<h3><span class="mw-headline" id="Taking_screenshots_of_the_virtual_machine">Taking screenshots of the virtual machine</span></h3>
<p>Screenshots of the virtual machine graphic display can be obtained in the PPM format by running the following command in the monitor console:
</p>
<pre>(qemu) screendump <i>file.ppm</i>
</pre>
<h2><span class="mw-headline" id="QEMU_machine_protocol">QEMU machine protocol</span></h2>
<p>The QEMU machine protocol (QMP) is a JSON-based protocol which allows applications to control a QEMU instance. Similarly to the <a href="#QEMU_monitor">#QEMU monitor</a> it offers ways to interact with a running machine and the JSON protocol allows to do it programmatically. The description of all the QMP commands can be found in <a rel="nofollow" class="external text" href="https://raw.githubusercontent.com/coreos/qemu/master/qmp-commands.hx">qmp-commands</a>.
</p>
<h3><span class="mw-headline" id="Start_QMP">Start QMP</span></h3>
<p>The usual way to control the guest using the QMP protocol, is to open a TCP socket when launching the machine using the <code>-qmp</code> option. Here it is using for example the TCP port 4444:
</p>
<pre>$ qemu-system-x86_64 <i>[...]</i> -qmp tcp:localhost:4444,server,nowait
</pre>
<p>Then one way to communicate with the QMP agent is to use <a href="../en/Network_tools.html#Netcat" class="mw-redirect" title="Netcat">netcat</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">nc localhost 4444</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"QMP": {"version": {"qemu": {"micro": 0, "minor": 1, "major": 3}, "package": ""}, "capabilities": []} } </pre>
<p>At this stage, the only command that can be recognized is <code>qmp_capabilities</code>, so that QMP enters into command mode. Type:
</p>
<pre>{"execute": "qmp_capabilities"}
</pre>
<p>Now, QMP is ready to receive commands, to retrieve the list of recognized commands, use:
</p>
<pre>{"execute": "query-commands"}
</pre>
<h3><span class="mw-headline" id="Live_merging_of_child_image_into_parent_image">Live merging of child image into parent image</span></h3>
<p>It is possible to merge a running snapshot into its parent by issuing a <code>block-commit</code> command. In its simplest form the following line will commit the child into its parent:
</p>
<pre>{"execute": "block-commit", "arguments": {"device": "<i>devicename</i>"}}
</pre>
<p>Upon reception of this command, the handler looks for the base image and converts it from read only to read write mode and then runs the commit job.
</p>
<p>Once the <i>block-commit</i> operation has completed, the event <code>BLOCK_JOB_READY</code> will be emitted, signalling that the synchronization has finished. The job can then be gracefully completed by issuing the command <code>block-job-complete</code>:
</p>
<pre>{"execute": "block-job-complete", "arguments": {"device": "<i>devicename</i>"}}
</pre>
<p>Until such a command is issued, the <i>commit</i> operation remains active.
After successful completion, the base image remains in read write mode and becomes the new active layer. On the other hand, the child image becomes invalid and it is the responsibility of the user to clean it up.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> The list of device and their names can be retrieved by executing the command <code>query-block</code> and parsing the results. The device name is in the <code>device</code> field, for example <code>ide0-hd0</code> for the hard disk in this example: <pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">{"execute": "query-block"}</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"return": [{"io-status": "ok", "device": "<b>ide0-hd0</b>", "locked": false, "removable": false, "inserted": {"iops_rd": 0, "detect_zeroes": "off", "image": {"backing-image": {"virtual-size": 27074281472, "filename": "parent.qcow2", ... } </pre> </div>
<h3><span class="mw-headline" id="Live_creation_of_a_new_snapshot">Live creation of a new snapshot</span></h3>
<p>To create a new snapshot out of a running image, run the command:
</p>
<pre>{"execute": "blockdev-snapshot-sync", "arguments": {"device": "<i>devicename</i>","snapshot-file": "<i>new_snapshot_name</i>.qcow2"}}
</pre>
<p>This creates an overlay file named <code><i>new_snapshot_name</i>.qcow2</code> which then becomes the new active layer.
</p>
<h2><span class="mw-headline" id="Tips_and_tricks">Tips and tricks</span></h2>
<h3><span class="mw-headline" id="Improve_virtual_machine_performance">Improve virtual machine performance</span></h3>
<p>There are a number of techniques that you can use to improve the performance of the virtual machine. For example:
</p>
<ul>
<li>Apply <a href="#Enabling_KVM">#Enabling KVM</a> for full virtualization.</li>
<li>Use the <code>-cpu host</code> option to make QEMU emulate the host's exact CPU rather than a more generic CPU.</li>
<li>Especially for Windows guests, enable <a rel="nofollow" class="external text" href="https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Hyper-V enlightenments</a>: <code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>. See the <a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/system/i386/hyperv.html">QEMU documentation</a> for more information and flags.</li>
<li>multiple cores can be assigned to the guest using the <code>-smp cores=x,threads=y,sockets=1,maxcpus=z</code> option. The threads parameter is used to assign <a rel="nofollow" class="external text" href="https://www.tomshardware.com/reviews/simultaneous-multithreading-definition,5762.html">SMT cores</a>. Leaving a physical core for QEMU, the hypervisor and the host system to operate unimpeded is highly beneficial.</li>
<li>Make sure you have assigned the virtual machine enough memory. By default, QEMU only assigns 128 MiB of memory to each virtual machine. Use the <code>-m</code> option to assign more memory. For example, <code>-m 1024</code> runs a virtual machine with 1024 MiB of memory.</li>
<li>If supported by drivers in the guest operating system, use virtio for network and/or block devices, see <a href="#Installing_virtio_drivers">#Installing virtio drivers</a>.</li>
<li>Use TAP devices instead of user-mode networking, see <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>.</li>
<li>If the guest OS is doing heavy writing to its disk, you may benefit from certain mount options on the host's file system. For example, you can mount an <a href="../en/Ext4.html" title="Ext4">ext4 file system</a> with the option <code>barrier=0</code>. You should read the documentation for any options that you change because sometimes performance-enhancing options for file systems come at the cost of data integrity.</li>
<li>If you have a raw disk or partition, you may want to disable the cache: <pre>$ qemu-system-x86_64 -drive file=/dev/<i>disk</i>,if=virtio,<b>cache=none</b></pre>
</li>
<li>Use the native Linux AIO: <pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=virtio<b>,aio=native,cache.direct=on</b></pre>
</li>
<li>If you are running multiple virtual machines concurrently that all have the same operating system installed, you can save memory by enabling <a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)" class="extiw" title="wikipedia:Kernel SamePage Merging (KSM)">kernel same-page merging</a>. See <a href="#Enabling_KSM">#Enabling KSM</a>.</li>
<li>In some cases, memory can be reclaimed from running virtual machines by running a memory ballooning driver in the guest operating system and launching QEMU using <code>-device virtio-balloon</code>.</li>
<li>It is possible to use a emulation layer for an ICH-9 AHCI controller (although it may be unstable). The AHCI emulation supports <a href="https://en.wikipedia.org/wiki/Native_Command_Queuing" class="extiw" title="wikipedia:Native Command Queuing">NCQ</a>, so multiple read or write requests can be outstanding at the same time: <pre>$ qemu-system-x86_64 -drive id=disk,file=<i>disk_image</i>,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0</pre>
</li>
</ul>
<p>See <a rel="nofollow" class="external free" href="https://www.linux-kvm.org/page/Tuning_KVM">https://www.linux-kvm.org/page/Tuning_KVM</a> for more information.
</p>
<h3><span class="mw-headline" id="Starting_QEMU_virtual_machines_on_boot">Starting QEMU virtual machines on boot</span></h3>
<h4><span class="mw-headline" id="With_libvirt">With libvirt</span></h4>
<p>If a virtual machine is set up with <a href="../en/Libvirt.html" title="Libvirt">libvirt</a>, it can be configured with <code>virsh autostart</code> or through the <i>virt-manager</i> GUI to start at host boot by going to the Boot Options for the virtual machine and selecting "Start virtual machine on host boot up".
</p>
<h4><span class="mw-headline" id="With_systemd_service">With systemd service</span></h4>
<p>To run QEMU virtual machines on boot, you can use following systemd unit and config.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=QEMU virtual machine

[Service]
Environment="haltcmd=kill -INT $MAINPID"
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/usr/bin/bash -c ${haltcmd}
ExecStop=/usr/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> This service will wait for the console port to be released, which means that the virtual machine has been shutdown, to graciously end.</div>
<p>Then create per-VM configuration files, named <code>/etc/conf.d/qemu.d/<i>vm_name</i></code>, with the variables <code>args</code> and <code>haltcmd</code> set. Example configs:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/one</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0"

haltcmd="echo 'system_powerdown' | nc localhost 7100" # or netcat/ncat</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/two</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1"

haltcmd="ssh powermanager@vm2 sudo poweroff"</pre>
<p>The description of the variables is the following:
</p>
<ul>
<li>
<code>args</code> - QEMU command line arguments to be used.</li>
<li>
<code>haltcmd</code> - Command to shut down a virtual machine safely. In the first example, the QEMU monitor is exposed via telnet using <code>-monitor telnet:..</code> and the virtual machines are powered off via ACPI by sending <code>system_powerdown</code> to monitor with the <code>nc</code> command. In the other example, SSH is used.</li>
</ul>
<p>To set which virtual machines will start on boot-up, <a href="../en/Help:Reading.html#Control_of_systemd_units" class="mw-redirect" title="Enable">enable</a> the <code>qemu@<i>vm_name</i>.service</code> systemd unit.
</p>
<h3><span class="mw-headline" id="Mouse_integration">Mouse integration</span></h3>
<p>To prevent the mouse from being grabbed when clicking on the guest operating system's window, add the options <code>-usb -device usb-tablet</code>. This means QEMU is able to report the mouse position without having to grab the mouse. This also overrides PS/2 mouse emulation when activated. For example:
</p>
<pre>$ qemu-system-x86_64 -hda <i>disk_image</i> -m 512 -usb -device usb-tablet
</pre>
<p>If that does not work, try using <code>-vga qxl</code> parameter, also look at the instructions <a href="#Mouse_cursor_is_jittery_or_erratic">#Mouse cursor is jittery or erratic</a>.
</p>
<h3><span class="mw-headline" id="Pass-through_host_USB_device">Pass-through host USB device</span></h3>
<p>It is possible to access the physical device connected to a USB port of the host from the guest. The first step is to identify where the device is connected, this can be found running the <code>lsusb</code> command. For example:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ lsusb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
Bus <b>003</b> Device <b>007</b>: ID <b>0781</b>:<b>5406</b> SanDisk Corp. Cruzer Micro U3
</pre>
<p>The outputs in bold above will be useful to identify respectively the <i>host_bus</i> and <i>host_addr</i> or the <i>vendor_id</i> and <i>product_id</i>.
</p>
<p>In qemu, the idea is to emulate an EHCI (USB 2) or XHCI (USB 1.1   USB 2   USB 3) controller with the option <code>-device usb-ehci,id=ehci</code> or <code>-device qemu-xhci,id=xhci</code> respectively and then attach the physical device to it with the option <code>-device usb-host,..</code>. We will consider that <i>controller_id</i> is either <code>ehci</code> or <code>xhci</code> for the rest of this section.
</p>
<p>Then, there are two ways to connect to the USB of the host with qemu:
</p>
<ol>
<li>Identify the device and connect to it on any bus and address it is attached to on the host, the generic syntax is: <pre>-device usb-host,bus=<i>controller_id</i>.0,vendorid=0x<i>vendor_id</i>,productid=0x<i>product_id</i></pre>Applied to the device used in the example above, it becomes:<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x<b>0781</b>,productid=0x<b>5406</b></pre>One can also add the <code>...,port=<i>port_number</i></code> setting to the previous option to specify in which physical port of the virtual controller the device should be attached, useful in the case one wants to add multiple USB devices to the virtual machine. Another option is to use the new <code>hostdevice</code> property of <code>usb-host</code> which is available since QEMU 5.1.0, the syntax is: <pre>-device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007</pre>
</li>
<li>Attach whatever is connected to a given USB bus and address, the syntax is:<pre>-device usb-host,bus=<i>controller_id</i>.0,hostbus=<i>host_bus</i>,host_addr=<i>host_addr</i></pre>Applied to the bus and the address in the example above, it becomes:<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,hostbus=<b>3</b>,hostaddr=<b>7</b></pre>
</li>
</ol>
<p>See <a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/system/devices/usb.html">QEMU/USB emulation</a> for more information.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> If you encounter permission errors when running QEMU, see <a href="../en/Udev.html#About_udev_rules" title="Udev">udev#About udev rules</a> for information on how to set permissions of the device.</div>
<h3><span class="mw-headline" id="USB_redirection_with_SPICE">USB redirection with SPICE</span></h3>
<p>When using <a href="#SPICE">#SPICE</a> it is possible to redirect USB devices from the client to the virtual machine without needing to specify them in the QEMU command. It is possible to configure the number of USB slots available for redirected devices (the number of slots will determine the maximum number of devices which can be redirected simultaneously). The main advantages of using SPICE for redirection compared to the previously-mentioned <code>-usbdevice</code> method is the possibility of hot-swapping USB devices after the virtual machine has started, without needing to halt it in order to remove USB devices from the redirection or adding new ones. This method of USB redirection also allows us to redirect USB devices over the network, from the client to the server. In summary, it is the most flexible method of using USB devices in a QEMU virtual machine.
</p>
<p>We need to add one EHCI/UHCI controller per available USB redirection slot desired as well as one SPICE redirection channel per slot. For example, adding the following arguments to the QEMU command you use for starting the virtual machine in SPICE mode will start the virtual machine with three available USB slots for redirection:
</p>
<pre>-device ich9-usb-ehci1,id=usb \
-device ich9-usb-uhci1,masterbus=usb.0,firstport=0,multifunction=on \
-device ich9-usb-uhci2,masterbus=usb.0,firstport=2 \
-device ich9-usb-uhci3,masterbus=usb.0,firstport=4 \
-chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 \
-chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 \
-chardev spicevmc,name=usbredir,id=usbredirchardev3 -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3</pre>
<p>See <a rel="nofollow" class="external text" href="https://www.spice-space.org/usbredir.html">SPICE/usbredir</a> for more information.
</p>
<p>Both <code>spicy</code> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span> (<i>Input &gt; Select USB Devices for redirection</i>) and <code>remote-viewer</code> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span> (<i>File &gt; USB device selection</i>) support this feature. Please make sure that you have installed the necessary SPICE Guest Tools on the virtual machine for this functionality to work as expected (see the <a href="#SPICE">#SPICE</a> section for more information).
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Keep in mind that when a USB device is redirected from the client, it will not be usable from the client operating system itself until the redirection is stopped. It is specially important to never redirect the input devices (namely mouse and keyboard), since it will be then difficult to access the SPICE client menus to revert the situation, because the client will not respond to the input devices after being redirected to the virtual machine.</div>
<h4><span class="mw-headline" id="Automatic_USB_forwarding_with_udev">Automatic USB forwarding with udev</span></h4>
<p>Normally, forwarded devices must be available at the boot time of the virtual machine to be forwarded. If that device is disconnected, it will not be forwarded anymore.
</p>
<p>You can use <a href="../en/Udev.html#About_udev_rules" class="mw-redirect" title="Udev rule">udev rules</a> to automatically attach a device when it comes online. Create a <code>hostdev</code> entry somewhere on disk. <a href="../en/File_permissions_and_attributes.html#Changing_ownership" class="mw-redirect" title="Chown">chown</a> it to root to prevent other users modifying it.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/usr/local/hostdev-mydevice.xml</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">&lt;hostdev mode='subsystem' type='usb'&gt;
  &lt;source&gt;
    &lt;vendor id='0x03f0'/&gt;
    &lt;product id='0x4217'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</pre>
<p>Then create a <i>udev</i> rule which will attach/detach the device:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/usr/lib/udev/rules.d/90-libvirt-mydevice</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="add", \
    SUBSYSTEM=="usb", \
    ENV{ID_VENDOR_ID}=="03f0", \
    ENV{ID_MODEL_ID}=="4217", \
    RUN+="/usr/bin/virsh attach-device GUESTNAME /usr/local/hostdev-mydevice.xml"
ACTION=="remove", \
    SUBSYSTEM=="usb", \
    ENV{ID_VENDOR_ID}=="03f0", \
    ENV{ID_MODEL_ID}=="4217", \
    RUN+="/usr/bin/virsh detach-device GUESTNAME /usr/local/hostdev-mydevice.xml"</pre>
<p><a rel="nofollow" class="external text" href="https://rolandtapken.de/blog/2011-04/how-auto-hotplug-usb-devices-libvirt-vms-update-1">Source and further reading</a>.
</p>
<h3><span class="mw-headline" id="Enabling_KSM">Enabling KSM</span></h3>
<p>Kernel Samepage Merging (KSM) is a feature of the Linux kernel that allows for an application to register with the kernel to have its pages merged with other processes that also register to have their pages merged. The KSM mechanism allows for guest virtual machines to share pages with each other. In an environment where many of the guest operating systems are similar, this can result in significant memory savings.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Although KSM may reduce memory usage, it may increase CPU usage. Also note some security issues may occur, see <a href="https://en.wikipedia.org/wiki/Kernel_same-page_merging" class="extiw" title="wikipedia:Kernel same-page merging">Wikipedia:Kernel same-page merging</a>.</div>
<p>To enable KSM:
</p>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<p>To make it permanent, use <a href="../en/Systemd.html#systemd-tmpfiles_-_temporary_files" title="Systemd">systemd's temporary files</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/tmpfiles.d/ksm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">w /sys/kernel/mm/ksm/run - - - - 1
</pre>
<p>If KSM is running, and there are pages to be merged (i.e. at least two similar virtual machines are running), then <code>/sys/kernel/mm/ksm/pages_shared</code> should be non-zero. See <a rel="nofollow" class="external free" href="https://docs.kernel.org/admin-guide/mm/ksm.html">https://docs.kernel.org/admin-guide/mm/ksm.html</a> for more information.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> An easy way to see how well KSM is performing is to simply print the contents of all the files in that directory:
<pre>$ grep -r . /sys/kernel/mm/ksm/
</pre>
</div>
<h3><span class="mw-headline" id="Multi-monitor_support">Multi-monitor support</span></h3>
<p>The Linux QXL driver supports four heads (virtual screens) by default. This can be changed via the <code>qxl.heads=N</code> kernel parameter.
</p>
<p>The default VGA memory size for QXL devices is 16M (VRAM size is 64M). This is not sufficient if you would like to enable two 1920x1200 monitors since that requires 2 × 1920 × 4 (color depth) × 1200 = 17.6 MiB VGA memory. This can be changed by replacing <code>-vga qxl</code> by <code>-vga none -device qxl-vga,vgamem_mb=32</code>. If you ever increase vgamem_mb beyond 64M, then you also have to increase the <code>vram_size_mb</code> option.
</p>
<h3><span class="mw-headline" id="Custom_display_resolution">Custom display resolution</span></h3>
<p>A custom display resolution can be set with <code>-device VGA,edid=on,xres=1280,yres=720</code> (see <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data" class="extiw" title="wikipedia:Extended Display Identification Data">EDID</a> and <a href="https://en.wikipedia.org/wiki/Display_resolution" class="extiw" title="wikipedia:Display resolution">display resolution</a>).
</p>
<h3><span class="mw-headline" id="Copy_and_paste">Copy and paste</span></h3>
<h4><span class="mw-headline" id="SPICE_2">SPICE</span></h4>
<p>One way to share the clipboard between the host and the guest is to enable the SPICE remote desktop protocol and access the client with a SPICE client.
One needs to follow the steps described in <a href="#SPICE">#SPICE</a>. A guest run this way will support copy paste with the host.
</p>
<h4><span class="mw-headline" id="qemu-vdagent">qemu-vdagent</span></h4>
<p>QEMU provides its own implementation of the spice vdagent chardev called <code>qemu-vdagent</code>. It interfaces with the spice-vdagent guest service and allows the guest and host share a clipboard.
</p>
<p>To access this shared clipboard with QEMU's GTK display, you will need to compile QEMU <a href="../en/Arch_build_system.html" title="Arch build system">from source</a> with the <code>--enable-gtk-clipboard</code> configure parameter. It is sufficient to replace the installed <code>qemu-ui-gtk</code> package.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>Feature request <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/79716">FS#79716</a> submitted to enable the functionality in the official package.</li>
<li>The shared clipboard in qemu-ui-gtk has been pushed back to experimental as it can <a rel="nofollow" class="external text" href="https://gitlab.com/qemu-project/qemu/-/issues/1150">freeze guests under certain circumstances</a>. A fix has been proposed to solve the issue upstream.</li>
</ul>
</div>
<p>Add the following QEMU command line arguments:
</p>
<pre>-device virtio-serial,packed=on,ioeventfd=on
-device virtserialport,name=com.redhat.spice.0,chardev=vdagent0
-chardev qemu-vdagent,id=vdagent0,name=vdagent,clipboard=on,mouse=off
</pre>
<p>These arguments are also valid if converted to <a href="../en/Libvirt.html#QEMU_command_line_arguments" title="Libvirt">libvirt form</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> While the spicevmc chardev will start the spice-vdagent service of the guest automatically, the qemu-vdagent chardev may not.</div>
<p>On linux guests, you may <a href="../en/Help:Reading.html#Control_of_systemd_units" class="mw-redirect" title="Start">start</a> the <code>spice-vdagent.service</code> <a href="../en/Systemd/User.html" class="mw-redirect" title="User unit">user unit</a> manually. On Windows guests, set the spice-agent startup type to automatic.
</p>
<h3><span class="mw-headline" id="Windows-specific_notes">Windows-specific notes</span></h3>
<p>QEMU can run any version of Windows from Windows 95 through Windows 11.
</p>
<p>It is possible to run <a href="../en/Windows_PE.html" title="Windows PE">Windows PE</a> in QEMU.
</p>
<h4><span class="mw-headline" id="Fast_startup">Fast startup</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> An administrator account is required to change power settings.</div>
<p>For Windows 8 (or later) guests it is better to disable "Turn on fast startup (recommended)" from the Power Options of the Control Panel as explained in the following <a rel="nofollow" class="external text" href="https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html">forum page</a>, as it causes the guest to hang during every other boot.
</p>
<p>Fast Startup may also need to be disabled for changes to the <code>-smp</code> option to be properly applied.
</p>
<h4><span class="mw-headline" id="Remote_Desktop_Protocol">Remote Desktop Protocol</span></h4>
<p>If you use a MS Windows guest, you might want to use RDP to connect to your guest virtual machine. If you are using a VLAN or are not in the same network as the guest, use:
</p>
<pre>$ qemu-system-x86_64 -nographic -nic user,hostfwd=tcp::5555-:3389
</pre>
<p>Then connect with either <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=rdesktop">rdesktop</a></span> or <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=freerdp">freerdp</a></span> to the guest. For example:
</p>
<pre>$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan
</pre>
<h3><span class="mw-headline" id="Clone_Linux_system_installed_on_physical_equipment">Clone Linux system installed on physical equipment</span></h3>
<p>Linux system installed on physical equipment can be cloned for running on a QEMU virtual machine. See <a rel="nofollow" class="external text" href="https://coffeebirthday.wordpress.com/2018/09/14/clone-linux-system-for-qemu-virtual-machine/">Clone Linux system from hardware for QEMU virtual machine</a>
</p>
<h3>
<span id="Chrooting_into_arm.2Farm64_environment_from_x86_64"></span><span class="mw-headline" id="Chrooting_into_arm/arm64_environment_from_x86_64">Chrooting into arm/arm64 environment from x86_64</span>
</h3>
<p>Sometimes it is easier to work directly on a disk image instead of the real ARM based device. This can be achieved by mounting an SD card/storage containing the <i>root</i> partition and chrooting into it.
</p>
<p>Another use case for an ARM chroot is building ARM packages on an x86_64 machine. Here, the chroot environment can be created from an image tarball from <a rel="nofollow" class="external text" href="https://archlinuxarm.org">Arch Linux ARM</a> - see <a rel="nofollow" class="external autonumber" href="https://nerdstuff.org/posts/2020/2020-003_simplest_way_to_create_an_arm_chroot/">[3]</a> for a detailed description of this approach.
</p>
<p>Either way, from the chroot it should be possible to run <i>pacman</i> and install more packages, compile large libraries etc. Since the executables are for the ARM architecture, the translation to x86 needs to be performed by <a class="mw-selflink selflink">QEMU</a>.
</p>
<p>Install <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> on the x86_64 machine/host, and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static-binfmt">qemu-user-static-binfmt</a></span> to register the qemu binaries to binfmt service.
</p>
<p><i>qemu-user-static</i> is used to allow the execution of compiled programs from other architectures. This is similar to what is provided by <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span>, but the "static" variant is required for chroot. Examples:
</p>
<pre>qemu-arm-static path_to_sdcard/usr/bin/ls
qemu-aarch64-static path_to_sdcard/usr/bin/ls
</pre>
<p>These two lines execute the <code>ls</code> command compiled for 32-bit ARM and 64-bit ARM respectively. Note that this will not work without chrooting, because it will look for libraries not present in the host system.
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> allows automatically prefixing the ARM exectuable with <code>qemu-arm-static</code> or <code>qemu-aarch64-static</code>.
</p>
<p>Make sure that the ARM executable support is active:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ ls /proc/sys/fs/binfmt_misc</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">qemu-aarch64  qemu-arm	  qemu-cris  qemu-microblaze  qemu-mipsel  qemu-ppc64	    qemu-riscv64  qemu-sh4    qemu-sparc	qemu-sparc64  status
qemu-alpha    qemu-armeb  qemu-m68k  qemu-mips	      qemu-ppc	   qemu-ppc64abi32  qemu-s390x	  qemu-sh4eb  qemu-sparc32plus	register
</pre>
<p>Each executable must be listed.
</p>
<p>If it is not active, <a href="../en/Help:Reading.html#Control_of_systemd_units" class="mw-redirect" title="Restart">restart</a> <code>systemd-binfmt.service</code>.
</p>
<p>Mount the SD card to <code>/mnt/sdcard</code> (the device name may be different).
</p>
<pre># mount --mkdir /dev/mmcblk0p2 /mnt/sdcard
</pre>
<p>Mount boot partition if needed (again, use the suitable device name):
</p>
<pre># mount /dev/mmcblk0p1 /mnt/sdcard/boot
</pre>
<p>Finally <i>chroot</i> into the SD card root as described in <a href="../en/Chroot.html#Using_chroot" class="mw-redirect" title="Change root">Change root#Using chroot</a>:
</p>
<pre># chroot /mnt/sdcard /bin/bash
</pre>
<p>Alternatively, you can use <i>arch-chroot</i> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=arch-install-scripts">arch-install-scripts</a></span>, as it will provide an easier way to get network support:
</p>
<pre># arch-chroot /mnt/sdcard /bin/bash
</pre>
<p>You can also use <a href="../en/Systemd-nspawn.html" title="Systemd-nspawn">systemd-nspawn</a> to chroot into the ARM environment:
</p>
<pre># systemd-nspawn -D /mnt/sdcard -M myARMMachine --bind-ro=/etc/resolv.conf
</pre>
<p><code>--bind-ro=/etc/resolv.conf</code> is optional and gives a working network DNS inside the chroot
</p>
<h4><span class="mw-headline" id="sudo_in_chroot">sudo in chroot</span></h4>
<p>If you install <a href="../en/Sudo.html" title="Sudo">sudo</a> in the chroot and receive the following error when trying to use it:
</p>
<pre>sudo: effective uid is not 0, is /usr/bin/sudo on a file system with the 'nosuid' option set or an NFS file system without root privileges?
</pre>
<p>then you may need to modify the binfmt flags, for example for <code>aarch64</code>:
</p>
<pre># cp /usr/lib/binfmt.d/qemu-aarch64-static.conf /etc/binfmt.d/
# vi /etc/binfmt.d/qemu-aarch64-static.conf
</pre>
<p>and add a <code>C</code> at the end of this file:
</p>
<pre>:qemu-aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-aarch64-static:FPC
</pre>
<p>Then <a href="../en/Help:Reading.html#Control_of_systemd_units" class="mw-redirect" title="Restart">restart</a> <code>systemd-binfmt.service</code> and check that the changes have taken effect (note the <code>C</code> on the <code>flags</code> line):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cat /proc/sys/fs/binfmt_misc/qemu-aarch64</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">enabled
interpreter /usr/bin/qemu-aarch64-static
flags: POCF
offset 0
magic 7f454c460201010000000000000000000200b700
mask ffffffffffffff00fffffffffffffffffeffffff
</pre>
<p>See the "flags" section of the <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/binfmt-misc.html">kernel binfmt documentation</a> for more information.
</p>
<h3><span class="mw-headline" id="Not_grabbing_mouse_input">Not grabbing mouse input</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-edit-clear.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b></p>
<div>
<b>Reason:</b> It is not explained what the option actually does. Is it causing or avoiding the side effect? (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<p>Tablet mode has side effect of not grabbing mouse input in QEMU window:
</p>
<pre>-usb -device usb-tablet
</pre>
<p>It works with several <code>-vga</code> backends one of which is virtio.
</p>
<h2><span class="mw-headline" id="Troubleshooting">Troubleshooting</span></h2>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Merge-arrows-2.svg" decoding="async" width="36" height="40" class="mw-file-element"></span></span><b>This article or section is a candidate for merging with <a href="/index.php?title=QEMU/Troubleshooting&amp;action=edit&amp;redlink=1" class="new" title="QEMU/Troubleshooting (page does not exist)">QEMU/Troubleshooting</a>.</b></p>
<div>
<b>Notes:</b> This section is long enough to be split into a dedicated subpage. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:QEMU.html">Talk:QEMU</a>)</div>
</div>
<h3><span class="mw-headline" id="Mouse_cursor_is_jittery_or_erratic">Mouse cursor is jittery or erratic</span></h3>
<p>If the cursor jumps around the screen uncontrollably, entering this on the terminal before starting QEMU might help:
</p>
<pre>$ export SDL_VIDEO_X11_DGAMOUSE=0
</pre>
<p>If this helps, you can add this to your <code>~/.bashrc</code> file.
</p>
<h3><span class="mw-headline" id="No_visible_Cursor">No visible Cursor</span></h3>
<p>Add <code>-display default,show-cursor=on</code> to QEMU's options to see a mouse cursor.
</p>
<p>If that still does not work, make sure you have set your display device appropriately, for example: <code>-vga qxl</code>.
</p>
<p>Another option to try is <code>-usb -device usb-tablet</code> as mentioned in <a href="#Mouse_integration">#Mouse integration</a>. This overrides the default PS/2 mouse emulation and synchronizes pointer location between host and guest as an added bonus.
</p>
<h3><span class="mw-headline" id="Two_different_mouse_cursors_are_visible">Two different mouse cursors are visible</span></h3>
<p>Apply the tip <a href="#Mouse_integration">#Mouse integration</a>.
</p>
<h3><span class="mw-headline" id="Keyboard_issues_when_using_VNC">Keyboard issues when using VNC</span></h3>
<p>When using VNC, you might experience keyboard problems described (in gory details) <a rel="nofollow" class="external text" href="https://www.berrange.com/posts/2010/07/04/more-than-you-or-i-ever-wanted-to-know-about-virtual-keyboard-handling/">here</a>. The solution is <i>not</i> to use the <code>-k</code> option on QEMU, and to use <code>gvncviewer</code> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gtk-vnc">gtk-vnc</a></span>. See also <a rel="nofollow" class="external text" href="https://www.mail-archive.com/libvir-list@redhat.com/msg13340.html">this</a> message posted on libvirt's mailing list.
</p>
<h3><span class="mw-headline" id="Keyboard_seems_broken_or_the_arrow_keys_do_not_work">Keyboard seems broken or the arrow keys do not work</span></h3>
<p>Should you find that some of your keys do not work or "press" the wrong key (in particular, the arrow keys), you likely need to specify your keyboard layout as an option. The keyboard layouts can be found in <code>/usr/share/qemu/keymaps/</code>.
</p>
<pre>$ qemu-system-x86_64 -k <i>keymap</i> <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="Could_not_read_keymap_file">Could not read keymap file</span></h3>
<pre>qemu-system-x86_64: -display vnc=0.0.0.0:0: could not read keymap file: 'en'
</pre>
<p>is caused by an invalid <i>keymap</i> passed to the <code>-k</code> argument. For example, <code>en</code> is invalid, but <code>en-us</code> is valid - see <code>/usr/share/qemu/keymaps/</code>.
</p>
<h3><span class="mw-headline" id="Guest_display_stretches_on_window_resize">Guest display stretches on window resize</span></h3>
<p>To restore default window size, press <code>Ctrl+Alt+u</code>.
</p>
<h3>
<span id="ioctl.28KVM_CREATE_VM.29_failed:_16_Device_or_resource_busy"></span><span class="mw-headline" id="ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy">ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</span>
</h3>
<p>If an error message like this is printed when starting QEMU with <code>-enable-kvm</code> option:
</p>
<pre>ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy
failed to initialize KVM: Device or resource busy
</pre>
<p>that means another <a href="../en/Category:Hypervisors.html" class="mw-redirect" title="Hypervisor">hypervisor</a> is currently running. It is not recommended or possible to run several hypervisors in parallel.
</p>
<h3><span class="mw-headline" id="libgfapi_error_message">libgfapi error message</span></h3>
<p>The error message displayed at startup:
</p>
<pre>Failed to open module: libgfapi.so.0: cannot open shared object file: No such file or directory
</pre>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">Install</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=glusterfs">glusterfs</a></span> or ignore the error message as GlusterFS is a optional dependency.
</p>
<h3><span class="mw-headline" id="Kernel_panic_on_LIVE-environments">Kernel panic on LIVE-environments</span></h3>
<p>If you start a live-environment (or better: booting a system) you may encounter this:
</p>
<pre>[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown block(0,0)
</pre>
<p>or some other boot hindering process (e.g. cannot unpack initramfs, cant start service foo).
Try starting the virtual machine with the <code>-m VALUE</code> switch and an appropriate amount of RAM, if the ram is to low you will probably encounter similar issues as above/without the memory-switch.
</p>
<h3><span class="mw-headline" id="Windows_7_guest_suffers_low-quality_sound">Windows 7 guest suffers low-quality sound</span></h3>
<p>Using the <code>hda</code> audio driver for Windows 7 guest may result in low-quality sound. Changing the audio driver to <code>ac97</code> by passing the <code>-soundhw ac97</code> arguments to QEMU and installing the AC97 driver from <a rel="nofollow" class="external text" href="https://www.realtek.com/en/component/zoo/category/pc-audio-codecs-ac-97-audio-codecs-software">Realtek AC'97 Audio Codecs</a> in the guest may solve the problem. See <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=1176761#c16">Red Hat Bugzilla – Bug 1176761</a> for more information.
</p>
<h3><span class="mw-headline" id="Could_not_access_KVM_kernel_module:_Permission_denied">Could not access KVM kernel module: Permission denied</span></h3>
<p>If you encounter the following error:
</p>
<pre>libvirtError: internal error: process exited while connecting to monitor: Could not access KVM kernel module: Permission denied failed to initialize KVM: Permission denied
</pre>
<p>Systemd 234 assigns a dynamic ID for the <code>kvm</code> group (see <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/54943">FS#54943</a>). To avoid this error, you need edit the file <code>/etc/libvirt/qemu.conf</code> and change the line with <code>group = "78"</code> to <code>group = "kvm"</code>.
</p>
<h3>
<span id=".22System_Thread_Exception_Not_Handled.22_when_booting_a_Windows_virtual_machine"></span><span class="mw-headline" id='"System_Thread_Exception_Not_Handled"_when_booting_a_Windows_virtual_machine'>"System Thread Exception Not Handled" when booting a Windows virtual machine</span>
</h3>
<p>Windows 8 or Windows 10 guests may raise a generic compatibility exception at boot, namely "System Thread Exception Not Handled", which tends to be caused by legacy drivers acting strangely on real machines. On KVM machines this issue can generally be solved by setting the CPU model to <code>core2duo</code>.
</p>
<h3>
<span id="Certain_Windows_games.2Fapplications_crashing.2Fcausing_a_bluescreen"></span><span class="mw-headline" id="Certain_Windows_games/applications_crashing/causing_a_bluescreen">Certain Windows games/applications crashing/causing a bluescreen</span>
</h3>
<p>Occasionally, applications running in the virtual machine may crash unexpectedly, whereas they would run normally on a physical machine. If, while running <code>dmesg -wH</code> as root, you encounter an error mentioning <code>MSR</code>, the reason for those crashes is that KVM injects a <a href="https://en.wikipedia.org/wiki/General_protection_fault" class="extiw" title="wikipedia:General protection fault">General protection fault</a> (GPF) when the guest tries to access unsupported <a href="https://en.wikipedia.org/wiki/Model-specific_register" class="extiw" title="wikipedia:Model-specific register">Model-specific registers</a> (MSRs) - this often results in guest applications/OS crashing. A number of those issues can be solved by passing the <code>ignore_msrs=1</code> option to the KVM module, which will ignore unimplemented MSRs.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/modprobe.d/kvm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
options kvm ignore_msrs=1
...</pre>
<p>Cases where adding this option might help:
</p>
<ul>
<li>GeForce Experience complaining about an unsupported CPU being present.</li>
<li>StarCraft 2 and L.A. Noire reliably blue-screening Windows 10 with <code>KMODE_EXCEPTION_NOT_HANDLED</code>. The blue screen information does not identify a driver file in these cases.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> While this is normally safe and some applications might not work without this, silently ignoring unknown MSR accesses could potentially break other software within the virtual machine or other virtual machine.</div>
<h3><span class="mw-headline" id="High_interrupt_latency_and_microstuttering">High interrupt latency and microstuttering</span></h3>
<p>This problem manifests itself as small pauses (stutters) and is particularly noticeable in graphics-intensive applications, such as games.
</p>
<ul>
<li>One of the causes is CPU power saving features, which are controlled by <a href="../en/CPU_frequency_scaling.html" title="CPU frequency scaling">CPU frequency scaling</a>. Change this to <code>performance</code> for all processor cores.</li>
<li>Another possible cause is PS/2 inputs. Switch from PS/2 to Virtio inputs, see <a href="../en/PCI_passthrough_via_OVMF.html#Passing_keyboard/mouse_via_Evdev" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Passing keyboard/mouse via Evdev</a>.</li>
</ul>
<h3><span class="mw-headline" id="QXL_video_causes_low_resolution">QXL video causes low resolution</span></h3>
<p>QEMU 4.1.0 introduced a regression where QXL video can fall back to low resolutions, when being displayed through spice. <a rel="nofollow" class="external autonumber" href="https://bugs.launchpad.net/qemu/+bug/1843151">[4]</a> For example, when KMS starts, text resolution may become as low as 4x10 characters. When trying to increase GUI resolution, it may go to the lowest supported resolution.
</p>
<p>As a workaround, create your device in this form:
</p>
<pre>-device qxl-vga,max_outputs=1...
</pre>
<h3><span class="mw-headline" id="Virtual_machine_not_booting_when_using_a_Secure_Boot_enabled_OVMF">Virtual machine not booting when using a Secure Boot enabled OVMF</span></h3>
<p><code>OVMF_CODE.secboot.4m.fd</code> and <code>OVMF_CODE.secboot.fd</code> files from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=edk2-ovmf">edk2-ovmf</a></span> are built with <a href="https://en.wikipedia.org/wiki/System_Management_Mode" class="extiw" title="wikipedia:System Management Mode">SMM</a> support. If S3 support is not disabled in the virtual machine, then the virtual machine might not boot at all.
</p>
<p>Add the <code>-global ICH9-LPC.disable_s3=1</code> option to the <i>qemu</i> command.
</p>
<p>See <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/59465">FS#59465</a> and <a rel="nofollow" class="external free" href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/README">https://github.com/tianocore/edk2/blob/master/OvmfPkg/README</a> for more details and the required options to use Secure Boot in QEMU.
</p>
<h3><span class="mw-headline" id="Virtual_machine_not_booting_into_Arch_ISO">Virtual machine not booting into Arch ISO</span></h3>
<p>When trying to boot the virtual machine for the first time from an Arch ISO image, the boot process hangs. Adding <code>console=ttyS0</code> to kernel boot options by pressing <code>e</code> in the boot menu you will get more boot messages and the following error:
</p>
<pre>:: Mounting '/dev/disk/by-label/ARCH_202204' to '/run/archiso/bootmnt'
Waiting 30 seconds for device /dev/disk/by-label/ARCH_202204 ...
ERROR: '/dev/disk/by-label/ARCH_202204' device did not show up after 30 seconds...
   Falling back to interactive prompt
   You can try to fix the problem manually, log out when you are finished
sh: can't access tty; job control turned off
</pre>
<p>The error message does not give a good clue as to what the real issue is. The problem is with the default 128MB of RAM that QEMU allocates to the virtual machine. Increasing the limit to 1024MB with <code>-m 1024</code> solves the issue and lets the system boot. You can continue installing Arch Linux as usual after that. Once the installation is complete, the memory allocation for the virtual machine can be decreased. The need for 1024MB is due to RAM disk requirements and size of the installation media. See <a rel="nofollow" class="external text" href="https://lists.archlinux.org/archives/list/arch-releng@lists.archlinux.org/message/D5HSGOFTPGYI6IZUEB3ZNAX4D3F3ID37/">this message on the arch-releng mailing list</a> and <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=204023">this forum thread</a>.
</p>
<h3><span class="mw-headline" id="Guest_CPU_interrupts_are_not_firing">Guest CPU interrupts are not firing</span></h3>
<p>If you are writing your own operating system by following the <a rel="nofollow" class="external text" href="https://wiki.osdev.org/">OSDev wiki</a>, or are simply getting stepping through the guest architecture assembly code using QEMU's <code>gdb</code> interface using the <code>-s</code> flag, it is useful to know that many emulators, QEMU included, usually implement some CPU interrupts leaving many hardware interrupts unimplemented. One way to know if your code is firing an interrupt, is by using:
</p>
<pre>-d int
</pre>
<p>to enable showing interrupts/exceptions on stdout.
</p>
<p>To see what other guest debugging features QEMU has to offer, see:
</p>
<pre>qemu-system-x86_64 -d help
</pre>
<p>or replace <code>x86_64</code> for your chosen guest architecture.
</p>
<h3><span class="mw-headline" id="KDE_with_sddm_does_not_start_spice-vdagent_at_login_automatically">KDE with sddm does not start spice-vdagent at login automatically</span></h3>
<p>Remove or comment out <code>X-GNOME-Autostart-Phase=WindowManager</code> from <code>/etc/xdg/autostart/spice-vdagent.desktop</code>. <a rel="nofollow" class="external autonumber" href="https://github.com/systemd/systemd/issues/18791">[5]</a>
</p>
<h3>
<span id="Error_starting_domain:_Requested_operation_is_not_valid:_network_.27default.27_is_not_active"></span><span class="mw-headline" id="Error_starting_domain:_Requested_operation_is_not_valid:_network_'default'_is_not_active">Error starting domain: Requested operation is not valid: network 'default' is not active</span>
</h3>
<p>If for any reason the default network is deactivated, you will not be able to start any guest virtual machines which are configured to use the network. Your first attempt can be simply trying to start the network with virsh.
</p>
<pre># virsh net-start default
</pre>
<p>For additional troubleshooting steps, see <a rel="nofollow" class="external autonumber" href="https://www.xmodulo.com/network-default-is-not-active.html">[6]</a>.
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://qemu.org">Official QEMU website</a></li>
<li><a rel="nofollow" class="external text" href="https://www.linux-kvm.org">Official KVM website</a></li>
<li><a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/6.0/">QEMU Emulator User Documentation</a></li>
<li><a href="https://en.wikibooks.org/wiki/QEMU" class="extiw" title="wikibooks:QEMU">QEMU Wikibook</a></li>
<li>
<a rel="nofollow" class="external text" href="http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu">Hardware virtualization with QEMU</a> by AlienBOB (last updated in 2008)</li>
<li>
<a rel="nofollow" class="external text" href="http://blog.falconindy.com/articles/build-a-virtual-army.html">Building a Virtual Army</a> by Falconindy</li>
<li><a rel="nofollow" class="external text" href="https://git.qemu.org/?p=qemu.git;a=tree;f=docs">Lastest docs</a></li>
<li><a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/">QEMU on Windows</a></li>
<li><a href="https://en.wikipedia.org/wiki/Qemu" class="extiw" title="wikipedia:Qemu">Wikipedia</a></li>
<li><a href="https://wiki.debian.org/QEMU" class="extiw" title="debian:QEMU">Debian Wiki - QEMU</a></li>
<li>
<a rel="nofollow" class="external text" href="https://people.gnome.org/~markmc/qemu-networking.html">QEMU Networking on gnome.org</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2022-09-22 ⓘ]</sup>
</li>
<li><a rel="nofollow" class="external text" href="http://bsdwiki.reedmedia.net/wiki/networking_qemu_virtual_bsd_systems.html">Networking QEMU Virtual BSD Systems</a></li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/hurd/hurd/running/qemu.html">QEMU on gnu.org</a></li>
<li><a rel="nofollow" class="external text" href="https://wiki.freebsd.org/qemu">QEMU on FreeBSD as host</a></li>
<li>
<a rel="nofollow" class="external text" href="https://wiki.mikejung.biz/KVM_/_Xen">KVM/QEMU Virtio Tuning and SSD VM Optimization Guide</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2022-09-22 ⓘ]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virt/part-virt-qemu.html">Managing Virtual Machines with QEMU - openSUSE documentation</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2024-07-30 ⓘ]</sup>
</li>
<li><a rel="nofollow" class="external text" href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaat/liaatkvm.htm">KVM on IBM Knowledge Center</a></li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../en/Category:Emulation.html" title="Category:Emulation">Emulation</a></li>
<li><a href="../en/Category:Hypervisors.html" title="Category:Hypervisors">Hypervisors</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Accuracy.html" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Style.html" title="Category:Pages or sections flagged with Template:Style">Pages or sections flagged with Template:Style</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Out_of_date.html" title="Category:Pages or sections flagged with Template:Out of date">Pages or sections flagged with Template:Out of date</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Merge.html" title="Category:Pages or sections flagged with Template:Merge">Pages or sections flagged with Template:Merge</a></li>
</ul>
</div>
</div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=QEMU&amp;oldid=813446">https://wiki.archlinux.org/index.php?title=QEMU&amp;oldid=813446</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 30 July 2024, at 16:24.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
	<li id="footer-places-archwiki-code-of-conduct"><a href="https://terms.archlinux.org/docs/code-of-conduct/" class="extiw" title="archlinux-service-agreements:code-of-conduct">Code of conduct</a></li>
	<li id="footer-places-archwiki-terms-of-service"><a href="https://terms.archlinux.org/docs/terms-of-service/" class="extiw" title="archlinux-service-agreements:terms-of-service">Terms of service</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul>
		<li>
		<button class="cdx-button cdx-button--icon-only vector-limited-width-toggle" id=""><span class="vector-icon mw-ui-icon-fullScreen mw-ui-icon-wikimedia-fullScreen"></span>

<span>Toggle limited content width</span>
</button>
</li>
	</ul>
</div>
</body>
</html>
