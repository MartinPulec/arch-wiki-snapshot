<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-0 vector-feature-client-preferences-disabled vector-feature-client-prefs-pinned-disabled vector-feature-night-mode-disabled skin-theme-clientpref-day vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>HDMI-CEC - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.42.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-HDMI-CEC rootpage-HDMI-CEC skin-vector-2022 action-view skin--responsive">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" role="navigation" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Features" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Features">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">1</span>Features</div>
		</a>
		
		<ul id="toc-Features-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Hardware_setup" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Hardware_setup">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">2</span>Hardware setup</div>
		</a>
		
			<button aria-controls="toc-Hardware_setup-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Hardware setup subsection</span>
			</button>
		
		<ul id="toc-Hardware_setup-sublist" class="vector-toc-list">
			<li id="toc-Native_CEC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Native_CEC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.1</span>Native CEC</div>
			</a>
			
			<ul id="toc-Native_CEC-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Tunneling_over_DisplayPort" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Tunneling_over_DisplayPort">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.2</span>Tunneling over DisplayPort</div>
			</a>
			
			<ul id="toc-Tunneling_over_DisplayPort-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-CEC_adapter" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#CEC_adapter">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.3</span>CEC adapter</div>
			</a>
			
			<ul id="toc-CEC_adapter-sublist" class="vector-toc-list">
				<li id="toc-PulseEight_USB_adapter" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#PulseEight_USB_adapter">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.3.1</span>PulseEight USB adapter</div>
			</a>
			
			<ul id="toc-PulseEight_USB_adapter-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Software_setup" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Software_setup">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">3</span>Software setup</div>
		</a>
		
			<button aria-controls="toc-Software_setup-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Software setup subsection</span>
			</button>
		
		<ul id="toc-Software_setup-sublist" class="vector-toc-list">
			<li id="toc-Informing_a_USB_adapter_of_its_physical_address" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Informing_a_USB_adapter_of_its_physical_address">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1</span>Informing a USB adapter of its physical address</div>
			</a>
			
			<ul id="toc-Informing_a_USB_adapter_of_its_physical_address-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Obtaining_a_logical_address" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Obtaining_a_logical_address">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.2</span>Obtaining a logical address</div>
			</a>
			
			<ul id="toc-Obtaining_a_logical_address-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Input-handling_daemons" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Input-handling_daemons">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.3</span>Input-handling daemons</div>
			</a>
			
			<ul id="toc-Input-handling_daemons-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Userspace_tools" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Userspace_tools">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.4</span>Userspace tools</div>
			</a>
			
			<ul id="toc-Userspace_tools-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Uses_for_CEC" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Uses_for_CEC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">4</span>Uses for CEC</div>
		</a>
		
			<button aria-controls="toc-Uses_for_CEC-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Uses for CEC subsection</span>
			</button>
		
		<ul id="toc-Uses_for_CEC-sublist" class="vector-toc-list">
			<li id="toc-Remote_control_pass_through" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Remote_control_pass_through">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.1</span>Remote control pass through</div>
			</a>
			
			<ul id="toc-Remote_control_pass_through-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Wake-on-CEC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Wake-on-CEC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.2</span>Wake-on-CEC</div>
			</a>
			
			<ul id="toc-Wake-on-CEC-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-CEC_traffic_monitoring" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#CEC_traffic_monitoring">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.3</span>CEC traffic monitoring</div>
			</a>
			
			<ul id="toc-CEC_traffic_monitoring-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-See_also" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#See_also">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">5</span>See also</div>
		</a>
		
		<ul id="toc-See_also-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body" role="main" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar">
					<nav role="navigation" aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">HDMI-CEC</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang">
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 1 language">
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-1" aria-hidden="true"><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">1 language</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-pl mw-list-item"><a href="../pl/HDMI-CEC.html" title="HDMI-CEC – polski" lang="pl" hreflang="pl" class="interlanguage-link-target"><span>Polski</span></a></li>
			</ul>
			
		</div>

	</div>
</div>
</header>
				<div class="vector-column-end">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-client-prefs-landmark" aria-label="Appearance">
						</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content">
<div class="mw-content-ltr mw-parser-output" lang="en" dir="ltr">
<p><a href="https://en.wikipedia.org/wiki/Consumer_Electronics_Control" class="extiw" title="wikipedia:Consumer Electronics Control">High-Definition Multimedia Interface - Consumer Electronics Control</a> is an additional low-speed (50 B/s) bus in the HDMI connection that a "network" of HDMI devices can use to communicate with each other. It allows HDMI devices to notify each other that they should be turning on or off, that the TV has switched input or that a remote control button is being pressed, among other things. In PC setups it is usually encountered in an HTPC (home-theater PC) setup.
</p>
<p>For a variety of reasons almost no PC GPU has hardware support for CEC. Video game consoles and set-top boxes usually have to include an external chipset to drive the CEC pin. While there are devices with native CEC support (such as the VideoCore GPU found on a Raspberry Pi), most hardware configurations need additional hardware.
</p>
<meta property="mw:PageProp/toc">
<h2><span class="mw-headline" id="Features">Features</span></h2>
<p>The main purpose of CEC is to grant a television insight and control over the state of the devices plugged into it. As such, it is split into a dozen of "features" that each target specific use cases, and which devices can opt to support or not based on their role as initiator/follower, their capabilities, as well as user configuration.
</p>
<p>The standardized features are:
</p>
<dl>
<dt>One Touch Play</dt>
<dd>Lets a device signal that it wishes to immediately become the active source, which can automatically turn on the TV</dd>
<dt>Routing Control</dt>
<dd>Allows the TV to control HDMI switches and lets devices check what source is currently active</dd>
<dt>Remote Control Passthrough</dt>
<dd>Lets devices send remote control signals to each other, usually from the TV to the active source</dd>
<dt>Deck Control</dt>
<dd>To control a movie/music player and query its playback status</dd>
<dt>Standby/System Standby</dt>
<dd>Lets a device request that another specific device be turned off, or broadcast that all devices on the system should now turn off.</dd>
<dt>Power Status</dt>
<dd>Lets devices be probed to see if they are in standby mode or turned on, or if they are in the process of turning on.</dd>
<dt>System Audio Control</dt>
<dd>Grants control of an AV receiver connected over the TV's Audio Return Channel, allowing the volume to be changed and the receiver to be turned on or off.</dd>
<dt>Tuner Control</dt>
<dd>Lets any device step through the list of TV channels known to a tuner device and query information on the active channel, like the channel number for analog TV or DVB/ATSC/ARIB transport stream information for digital TV</dd>
<dt>One Touch Record</dt>
<dd>Enables a recorder to query what channel the TV is currently showing so that said recorder can tune to the same channel and begin recording, or know that it should record itself or a downstream device if it already is the currently active HDMI source</dd>
<dt>Timer Programming</dt>
<dd>Allows a TV to configure a timer on a recorder to start recording a given source at a specific time</dd>
<dt>OSD display</dt>
<dd>Allows a device to print a message on the TV, between 1 and 13 ASCII characters long</dd>
<dt>Dynamic Auto Lipsync</dt>
<dd>Allows a TV to broadcast changes in presentation latency to the audio sink, which a source that has its own speakers (like a PC) can use for latency compensation with the image</dd>
</dl>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Not listed: Device Menu Control (deprecated in CEC 2.0), OSD name transfer (handled by cec-ctl), System information, Vendor-specific command (no standardized messages), Audio Rate Control (TV-AV only), Audio Return Channel Control (TV-AV only)</div>
<p>For a device like a PC, the most useful one among these is going to be <b>Remote Control Passthrough</b>. <b>System Standby</b> may be useful for HTPCs, but would be of questionable use on more general-purpose machines, which are not usually expected to go to sleep when the screen turns off. <b>Routing Control</b> could be used to wake up the system when the TV attempts to display that input, provided the connected PC has a way to listen to CEC traffic while suspended. <b>System Audio Control</b> would be convenient for some HDMI sound outputs, but does not currently work as a mean of volume control with either <a href="../en/PipeWire.html" title="PipeWire">PipeWire</a> or <a href="../en/PulseAudio.html" title="PulseAudio">PulseAudio</a>.
</p>
<h2><span class="mw-headline" id="Hardware_setup">Hardware setup</span></h2>
<p>The Linux <a href="../en/Kernel.html" title="Kernel">Kernel</a> already has a built-in subsystem to automatically respond to queries and handle CEC events, but the hardware may need to be configured first in order to work.
</p>
<h3><span class="mw-headline" id="Native_CEC">Native CEC</span></h3>
<p>Native CEC is <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/media/cec.html#supported-hardware-in-mainline">mostly encountered</a> in ARM devices. In x86 world the easiest option is <a href="#Tunneling_over_DisplayPort">tunneling over DisplayPort</a>, otherwise only some <a href="../en/Chrome_OS_devices.html" title="Chrome OS devices">Chrome OS</a> devices and <a rel="nofollow" class="external text" href="https://www.seco.com">SECO</a> <a rel="nofollow" class="external text" href="https://www.udoo.org">UDOO</a> single-board computers offer CEC.
</p>
<h3><span class="mw-headline" id="Tunneling_over_DisplayPort">Tunneling over DisplayPort</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> This is confirmed to work with at least the <a href="../en/Intel_graphics.html" class="mw-redirect" title="I915">i915</a>, <a href="../en/Nouveau.html" title="Nouveau">nouveau</a> and <a href="../en/AMDGPU.html" title="AMDGPU">amdgpu</a> drivers.</div>
<p>The DisplayPort 1.3 standard (introduced in 2014) allows DisplayPort-to-HDMI adapters to use the auxiliary channel to forward CEC signals both ways. This is the sort of feature that adapters do not usually support unless mentioned, and is not commonly found, but it can counter-intuitively be cheaper and easier to use CEC tunneling over DisplayPort than a USB-CEC adapter. The kernel documentation page for the CEC submodule has <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/media/cec.html#displayport-to-hdmi-adapters-with-working-cec">a list of adapters</a> which have been confirmed to work.
</p>
<p>The list is not exhaustive, however, and it is often more useful to know the name of the chipset being used by the adapter than the model of the adapter itself. For instance, the <a href="../en/Framework_Laptop_13.html" class="mw-redirect" title="Framework Laptop">Framework</a> HDMI module card is not explicitly advertised as supporting HDMI-CEC, but the <a rel="nofollow" class="external text" href="https://www.paradetech.com/products/ps186/">Parade PS186 chipset</a> inside of it does, and the card itself is detected by cec-ctl and works as expected. On the other hand, the <a rel="nofollow" class="external text" href="https://www.connect.synaptics.com/spyder">Synaptics "Spyder" VMM7100</a> which is used by several DisplayPost-to-HDMI-2.1 adapters like the Club3D CAC-1088, only does signal processing and seemingly does not support CEC-over-AUX. This is unlike the Club3D CAC-1080, a very similar HDMI 2.0 adapter based on the <a rel="nofollow" class="external text" href="https://hd-plc.megachips.com/mcdp2900-displayport1-4-to-hdmi2-0-converter/">Megachips MCDP2900 chipset</a>, which *does* support CEC.
</p>
<h3><span class="mw-headline" id="CEC_adapter">CEC adapter</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> If you are looking to use HDMI-CEC with <a href="../en/Kodi.html" title="Kodi">Kodi</a>, know that it has <a href="../en/Kodi.html#HDMI-CEC" title="Kodi">built-in support for both Pulse-Eight and Raspberry Pi modes of CEC control</a> and is incompatible with the following configuration.</div>
<h4><span class="mw-headline" id="PulseEight_USB_adapter">PulseEight USB adapter</span></h4>
<p>The <a rel="nofollow" class="external text" href="https://www.pulse-eight.com/p/104/usb-hdmi-cec-adapter">PulseEight USB-CEC adapter</a> works by passively extending all the pins of the HDMI connector on from the "PC side" connector to the "TV side" connector, save for the CEC pin, which is intercepted. The data going through that pin is instead exposed over a USB serial interface to let a PC control and monitor CEC traffic. The <a href="../en/Serial_input_device_to_kernel_input.html" title="Serial input device to kernel input">serial device</a> needs to have its line discipline (a flag to signal to the kernel that a TTY is of a specific known type and requires a driver to work) configured manually before the kernel takes over and acknowledges it as a CEC adapter. This cannot be done automatically <a rel="nofollow" class="external text" href="https://lwn.net/Articles/700489/">due to limitations around serial device APIs</a>, so it is currently best achieved with a <a href="../en/Udev.html#About_udev_rules" class="mw-redirect" title="Udev rule">udev rule</a> paired with a <a href="../en/Systemd.html" title="Systemd">systemd unit</a> (as udev rules cannot launch long-running or forking processes) to run <code>inputattach --pulse8-cec ...</code> when the device is plugged.
</p>
<p>This serial interface appears as device node <code>/dev/ttyACM<i>X</i></code>, and the <i>inputattach</i> utility is needed to set the line discipline and let the kernel drivers take over to create the <code>/dev/cec<i>X</i></code> device that will be needed later. This requires the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=linuxconsole">linuxconsole</a></span> package.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Do not modify <code>@$devnode</code> in the following rule, it is a udev string substitution.</div>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/pulse8-cec-autoattach.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="tty" ACTION=="add" ATTRS{manufacturer}=="Pulse-Eight" ATTRS{product}=="CEC Adapter" TAG+="systemd" ENV{SYSTEMD_WANTS}="pulse8-cec-attach@$devnode.service"</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/pulse8-cec-attach@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
# Should be called as "pulse8-cec-attach@-dev-ttyACM0.service" or similar
Description=Configure USB Pulse-Eight serial device at %I
ConditionPathExists=%I

[Service]
Type=forking
# inputattach is built without systemd daemon support by default, so systemd will have to guess the PID.
# <a rel="nofollow" class="external free" href="https://sourceforge.net/p/linuxconsole/code/ci/a3366c0d5f82485e6aae7b005ec7a2d9a93bf458/tree/utils/inputattach.c#l1233">https://sourceforge.net/p/linuxconsole/code/ci/a3366c0d5f82485e6aae7b005ec7a2d9a93bf458/tree/utils/inputattach.c#l1233</a>

ExecStart=/usr/bin/inputattach --daemon --pulse8-cec %I</pre>
<p>However, USB device connections <a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/persist.html">are usually reset when the system wakes up from sleep</a> (<a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/power-management.html">a step known as reset-resume</a>) , meaning the serial connection will be lost if the computer is ever suspended, on top of serial connections usually hanging up on resume anyway. This means the above rule has to be triggered again somehow.
</p>
<p>Unfortunately, the <code>cdc_acm</code> driver in charge of the <code>ttyACM*</code> object that the above rule reacts to does not raise any uevent about the connection being reset and the line discipline being lost, and the rule cannot be hooked on the USB device directly. Instead, the most reliable way to get the used rule above to trigger again at the right time is to delete and recreate the <code>ttyACM*</code> object <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/abi-stable.html#abi-sys-bus-usb-devices-bconfigurationvalue">by forcing the USB device to be reconfigured</a> when it resets. In order to react to this and ensure the connection is reopened, udev can keep track of when the USB device is reset and enumerated, as evidenced by the <code>DEVNUM</code> property being zeroed and later restored, and touching the <code>bConfigurationValue</code> sysfs attribute.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/pulse8-cec-autoattach.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="tty" ACTION=="add" ATTRS{manufacturer}=="Pulse-Eight" ATTRS{product}=="CEC Adapter" TAG+="systemd" ENV{SYSTEMD_WANTS}="pulse8-cec-attach@$devnode.service"

# Force device to be reconfigured when reset after suspend, otherwise the ttyACM link is lost but udev will not notice.
# A usb_dev_uevent with DEVNUM=000 is a sign that the device is being reset before enumeration.
# Re-configuring causes ttyACM to be removed and re-added instead.
SUBSYSTEM=="usb" ACTION=="change" ATTR{manufacturer}=="Pulse-Eight" ATTR{product}=="CEC Adapter" ENV{DEVNUM}=="000" ATTR{bConfigurationValue}=="1" ATTR{bConfigurationValue}="1"</pre>
<p>This essentially acts as if the USB adapter had been unplugged and re-plugged immediately upon coming out of sleep, ensuring the <code>SUBSYSTEM=="tty" ACTION=="add"</code> rule from before gets to run again. This ensures that the systemd service will be restarted as soon as the device is back to a usable state.
</p>
<h2><span class="mw-headline" id="Software_setup">Software setup</span></h2>
<p>Now that the CEC subsystem has something to bind on and that <code>/dev/cec0</code> has been created, it is now possible to configure the PC so other CEC devices know about it. When using the command-line, CEC devices are normally controlled via <code>cec-ctl</code>, which is part of <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=v4l-utils">v4l-utils</a></span>.
</p>
<h3><span class="mw-headline" id="Informing_a_USB_adapter_of_its_physical_address">Informing a USB adapter of its physical address</span></h3>
<p>One thing to be aware of is that the CEC pin alone does not have enough information on its own to send a valid CEC message. A CEC adapter that only monitors pin 13 (CEC) cannot know its "physical address", which is a 16 bit value representing its position in the "tree" of HDMI devices in terms of port number. 
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<p>The TV is the HDMI root and always has address <code>0.0.0.0</code>. A device plugged directly into the TV's port HDMI2 will have address <code>2.0.0.0</code>. A device plugged into port 6 of an AV receiver, which is itself plugged into the TV's HDMI3 port will be <code>3.6.0.0</code>.
</p>
</div>
<p>The adapter needs to be aware of this physical address in order to complete the <i>logical address</i> allocation procedure, which is detailed in the next section. The physical address is communicated over pin 16 (DDC/EDID), so configuring the CEC subsystem includes specifying which display output port is supposed to be associated with with that CEC object, in order for the physical address to be extracted from the display's EDID.
</p>
<p>One way to find the name of the active connectors is to use <code>xrandr --query</code> (which also works on Wayland):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ xrandr --query </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Screen 0: minimum 16 x 16, current 3840 x 2160, maximum 32767 x 32767
DP-1 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 600mm x 340mm
   3840x2160     59.98*+
   2048x1536     59.95  
   ...
HDMI-A-1 connected 3840x2160+0+0 (normal left inverted right x axis y axis) 1440mm x 810mm
   3840x2160     59.98*+
   2048x1536     59.95  
   ...
</pre>
<p>Once the correct port has been identified (for example <code>HDMI-A-1</code>), then the sysfs port name can be found by using <code>ls -1d /sys/class/drm/card*-HDMI-A-1</code> (such as <code>card1-HDMI-A-1</code>). In this case, the corresponding display's EDID data would be kept at <code>/sys/class/drm/card1-HDMI-A-1/edid</code>.
</p>
<p>The physical address can be previewed like this:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ edid-decode --physical-address /sys/class/drm/card1-DP-3/edid</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">4.0.0.0</pre>
<p>Given how CEC configuration must be performed every time the <code>cec</code> device node is re-created, this is best handled with another udev rule that fires when the <code>cec</code> object appears.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Be sure to replace <code>card1-HDMI-A-1</code> in the following rule by your connector name.</div>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/cec-configure-autostart.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="cec" KERNEL=="cec0" ACTION=="add" TAG+="systemd" ENV{SYSTEMD_WANTS}="cec0-configure@card1-HDMI-A-1.service"</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/cec0-configure@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
# Should be called as "cec0-configure@card1-HDMI-A-1.service" or similar
Description=Configure CEC adapter cec0 assuming it runs on output %i
AssertPathExists=/sys/class/drm/%i/edid
BindsTo=dev-cec0.device

[Service]  
Type=exec  
# --phys-addr-from-edid-poll checks EDID every tenth of a second
# <a rel="nofollow" class="external free" href="https://git.linuxtv.org/v4l-utils.git/tree/utils/cec-ctl/cec-ctl.cpp?id=0a195181d771090f3c99d4a6ddb8151352509061#n1977">https://git.linuxtv.org/v4l-utils.git/tree/utils/cec-ctl/cec-ctl.cpp?id=0a195181d771090f3c99d4a6ddb8151352509061#n1977</a>
# Use `Type=oneshot` if using `--phys-addr-from-edid` instead
ExecStart=/usr/bin/cec-ctl --device=0 "--osd-name=%H" --playback "--phys-addr-from-edid-poll=/sys/class/drm/%i/edid"</pre>
<p>See the next section for more details.
</p>
<h3><span class="mw-headline" id="Obtaining_a_logical_address">Obtaining a logical address</span></h3>
<p>Because the bandwidth is so limited, instead of a 16 bit physical address, the CEC protocol uses a shorter 4 bit logical address to mark the origin and destination of each message.  Without a logical address, a device can only receive and send broadcast messages. This identifies devices as "Tuner #3" or "Playback Device #1", with a finite number of each. These roles are intended to relate to the <a href="#Features">CEC features</a> mentioned earlier, namely:
</p>
<dl>
<dt>Tuner (4 max)</dt>
<dd>Should support the "Tuner Control" feature.</dd>
<dt>Recorder (2 max)</dt>
<dd>Only type that can use "One Touch Record"; TVs are supposed to ignore related messages coming from other addresses</dd>
<dt>Playback device (3 max)</dt>
<dd>General purpose video source. Computers and video game consoles are considered "Playback devices"</dd>
<dt>Backup (2 max)</dt>
<dd>Can be used if address allocation fails because too many devices of one type are present</dd>
</dl>
<p>The remaining 4 addresses are reserved for the TV itself, the Audio System, a vague "Specific use device" (possibly a second TV) and the default broadcast/unregistered address. HDMI switches are "transparent" and don't have their own addresses.
</p>
<p>Unlike the last times, the required call to cec-ctl is short-lived enough to work directly as part of a udev rule. If you have already created a systemd unit for physical address configuration earlier, this rule would be redundant and can be ignored.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/cec-configure-autostart.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="cec" KERNEL=="cec0" ACTION=="add" RUN+="/usr/bin/cec-ctl '--device=$devpath' '--osd-name=14_CHARS_MAX' --playback"</pre>
<p>The above udev rule (and previous systemd unit) uses <code>--playback</code> to configure a Playback device. It is, however, generally OK to set the device class to Tuner (<code>--tuner</code>) or Recorder (<code>--record</code>), whether because there are no more unused playback addresses, or simply to have the PC stand out in the list on TVs that visually set apart each device class in their input menus. The rule also uses  <code>--osd-name=14_CHARS_MAX</code> to configure the advertised source name to be used in TV menus. As the example name implies, it is limited to 14 ASCII characters only.
</p>
<h3><span class="mw-headline" id="Input-handling_daemons">Input-handling daemons</span></h3>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/cecdaemon-git/">cecdaemon-git</a></span><sup><small>AUR</small></sup>
</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/libcec-daemon-git/">libcec-daemon-git</a></span><sup><small>AUR</small></sup>
</li>
</ul>
<h3><span class="mw-headline" id="Userspace_tools">Userspace tools</span></h3>
<p>User access to <code>/dev/cec*</code> devices can be granted by enrolling users into the <code>video</code> <a href="../en/Users_and_groups.html#Group_management" class="mw-redirect" title="User group">user group</a>. The basic tool for controlling CEC devices is <code>cec-ctl</code> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=v4l-utils">v4l-utils</a></span>. A similar one is <code>cec-client</code> from <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libcec">libcec</a></span>, for which there are also Python bindings available in <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/python-cec/">python-cec</a></span><sup><small>AUR</small></sup>.
</p>
<h2><span class="mw-headline" id="Uses_for_CEC">Uses for CEC</span></h2>
<h3><span class="mw-headline" id="Remote_control_pass_through">Remote control pass through</span></h3>
<p>With the <code>cec0</code> object now configured, the Linux CEC subsystem should also have created a matching object in <code>/sys/class/rc</code>, which acts as an input device that <a rel="nofollow" class="external text" href="https://github.com/torvalds/linux/blob/master/drivers/media/rc/keymaps/rc-cec.c">converts UI Command Code signals into the equivalent keypresses</a>.
</p>
<ul>
<li>The "Power" signal, which is not usually on the remote itself but can be sent via menus, is mapped by default to bring up the "Close session" confirmation screen in KDE, and to immediately suspend the system in GNOME, just like the suspend button on a keyboard.
<ul><li>For waking up afterwards, see <a href="#Wake-on-CEC">#Wake-on-CEC</a>
</li></ul>
</li>
<li>The arrow buttons are mapped to the arrow navigation keys and will work everywhere.</li>
<li>The "Back" and "Select" navigation buttons are not mapped to the "Escape" and "Enter" keys, but to the "OK" and "EXIT" media buttons, which are only recognized by some media players.</li>
<li>"Play", "Pause" and "Stop" work the same as media keys and are recognized everywhere, possibly even when the player is not focused depending on DE configuration.
<ul><li>"Rewind", "Fast-forward", "Next track" and "Previous track" are usually ignored, but VLC and Totem acknowledge them</li></ul>
</li>
<li>"Dot" in the number buttons cluster is recognized as the numpad "." key</li>
<li>Various other keys like "Menu", "Setup", "Audio" and "Record" do nothing by default but can be assigned as valid keyboard shortcuts by most applications.</li>
<li>The 4 coloured function buttons, the number buttons and the channel +/- buttons, among others, are not picked up as keyboard or media keys by applications, though the evdev key events they raise could still be used by applications that specifically check for them.</li>
<li>Volume control is usually intercepted by the TV instead of passed on to the source, but is handled as normal volume keys in cases where it is passed through.</li>
</ul>
<h3><span class="mw-headline" id="Wake-on-CEC">Wake-on-CEC</span></h3>
<p>HDMI devices are usually notified by the television when they become the active source, using the Routing Control feature. This can be used to wake up suspended devices, although this runs into a problem when it comes to computers. Since CEC support is achieved through the Linux kernel or a userspace library, and not handled by the motherboard itself, there is nothing listening to CEC traffic while the computer is suspended.
</p>
<p>One of the benefits of the Pulse-Eight adapter, compared to DisplayPort-to-HDMI adapters, is that it can remain powered and active even while its host system is in standby. Once it has been informed of its physical and logical address, if it detects that its USB host is gone, it will continue to operate in "autonomous mode" so long as it remains powered. While in this state, it will keep doing the following:
</p>
<ul>
<li>Reply to system information inquiries (on-screen name, logical address, current power status, etc.)</li>
<li>Respond to any "Power" remote signals or <code>&lt;Set Stream Path&gt;</code> messages with itself as the destination by sending a power switch event to the PC to wake it up</li>
</ul>
<p>The Pulse-Eight USB adapter can do that because it registers as a USB keyboard alongside its serial interface. DisplayPost-to-HDMI adapters (including USB-C adapters which use the DisplayPort alt mode) do not have this kind of side-channel, and as a result cannot wake the host like this.
</p>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-view-fullscreen.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs expansion.</b></p>
<div>
<b>Reason:</b> From my tests, the Pulse-Eight adapter stops responding after the host has been suspended for more than 30 minutes or so. It's not clear whether this is some sort of malfunction of the adapter causing the TV to stop recognizing it, or if my motherboard just powers down the USB ports after a while. This should be clarified. (Discuss in <a rel="nofollow" class="external text" href="../en/Talk:HDMI-CEC.html">Talk:HDMI-CEC</a>)</div>
</div>
<p>Devices with native CEC support, like the Raspberry Pi, don't usually have a suspend mode. While the Pi itself can be powered down, it will not listen to the CEC pin while in this state, and <a rel="nofollow" class="external text" href="https://forum.kodi.tv/showthread.php?tid=174315&amp;pid=2651811#pid2651811">requires external circuitry</a> to be powered on in this way.
</p>
<h3><span class="mw-headline" id="CEC_traffic_monitoring">CEC traffic monitoring</span></h3>
<p>An interesting thing that can be done with a device that supports CEC is to just tap the CEC line to see what other devices are saying. Since the CEC line is <i>physically</i> interconnected between all devices (even those that do not support CEC), all messages sent by any device are visible by all other devices, no matter their position. In order to log these messages with <code>cec-ctl</code>, all that is needed is to run the following:
</p>
<pre>sudo cec-ctl -d0 --monitor-all --ignore=all,poll</pre>
<p>One specific message that can usually be left out is the polling message. CEC allows devices to actively poll each other by sending messages with a source and destination address, but no payload. If the message is not acknowledged, then it is expected that the device at this logical address is no longer powered and the address is now free. Some televisions will try polling their downstream devices rather frequently to check their status, so using <code>--ignore=all,poll</code> (to ignore all poll messages) or <code>--ignore=0,poll</code> (to only ignore poll messages from the TV) can help reduce noise in the logs.
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/media/cec.html">Kernel documentation for the CEC subsystem</a></li>
<li>
<a rel="nofollow" class="external text" href="https://elinux.org/CEC_(Consumer_Electronics_Control)_over_HDMI">CEC (Consumer Electronics Control) over HDMI</a>, in Embedded Linux Wiki (eLinux.org)</li>
<li>
<a rel="nofollow" class="external text" href="https://www.youtube.com/watch?v=Q6S2FabX2WA">HDMI CEC: What? Why? How?</a>, by Hans Verkuil, who wrote most of the CEC subsystem</li>
<li>
<a rel="nofollow" class="external text" href="https://www.cec-o-matic.com/">CEC-O-Matic</a>, which allows to create raw CEC messages and gives an overview of what makes up a valid CEC frame</li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../en/Category:Display_control.html" title="Category:Display control">Display control</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li></ul>
</div>
</div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=HDMI-CEC&amp;oldid=812771">https://wiki.archlinux.org/index.php?title=HDMI-CEC&amp;oldid=812771</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 23 July 2024, at 04:50.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
	<li id="footer-places-archwiki-code-of-conduct"><a href="https://terms.archlinux.org/docs/code-of-conduct/" class="extiw" title="archlinux-service-agreements:code-of-conduct">Code of conduct</a></li>
	<li id="footer-places-archwiki-terms-of-service"><a href="https://terms.archlinux.org/docs/terms-of-service/" class="extiw" title="archlinux-service-agreements:terms-of-service">Terms of service</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul>
		<li>
		<button class="cdx-button cdx-button--icon-only vector-limited-width-toggle" id=""><span class="vector-icon mw-ui-icon-fullScreen mw-ui-icon-wikimedia-fullScreen"></span>

<span>Toggle limited content width</span>
</button>
</li>
	</ul>
</div>
</body>
</html>
