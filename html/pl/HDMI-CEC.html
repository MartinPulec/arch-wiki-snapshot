<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-zebra-design-disabled vector-feature-custom-font-size-clientpref-disabled vector-feature-client-preferences-disabled vector-feature-typography-survey-disabled vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>HDMI-CEC (Polski) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.41.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-HDMI-CEC_Polski rootpage-HDMI-CEC_Polski skin-vector-2022 action-view skin--responsive">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-main-menu-container">
		</div>
	<input type="checkbox" id="vector-toc-collapsed-checkbox" class="vector-menu-checkbox">
			<nav id="mw-panel-toc" role="navigation" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark vector-sticky-pinned-container">
				<div id="vector-toc-pinned-container" class="vector-pinned-container">
				<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Funkcje" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Funkcje">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">1</span>Funkcje</div>
		</a>
		
		<ul id="toc-Funkcje-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Konfiguracja_sprzętowa_CEC" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Konfiguracja_sprz%C4%99towa_CEC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">2</span>Konfiguracja sprzętowa CEC</div>
		</a>
		
			<button aria-controls="toc-Konfiguracja_sprzętowa_CEC-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Konfiguracja sprzętowa CEC subsection</span>
			</button>
		
		<ul id="toc-Konfiguracja_sprzętowa_CEC-sublist" class="vector-toc-list">
			<li id="toc-Natywne_CEC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Natywne_CEC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.1</span>Natywne CEC</div>
			</a>
			
			<ul id="toc-Natywne_CEC-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Adapter_CEC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Adapter_CEC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.2</span>Adapter CEC</div>
			</a>
			
			<ul id="toc-Adapter_CEC-sublist" class="vector-toc-list">
				<li id="toc-Adapter_USB_PulseEight" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Adapter_USB_PulseEight">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.2.1</span>Adapter USB PulseEight</div>
			</a>
			
			<ul id="toc-Adapter_USB_PulseEight-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Tunelowanie_przez_DisplayPort" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Tunelowanie_przez_DisplayPort">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">2.3</span>Tunelowanie przez DisplayPort</div>
			</a>
			
			<ul id="toc-Tunelowanie_przez_DisplayPort-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Konfiguracja_podsystemu_CEC" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Konfiguracja_podsystemu_CEC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">3</span>Konfiguracja podsystemu CEC</div>
		</a>
		
		<ul id="toc-Konfiguracja_podsystemu_CEC-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Zobacz_także" class="vector-toc-list-item vector-toc-level-1 vector-toc-list-item-expanded">
		<a class="vector-toc-link" href="#Zobacz_tak%C5%BCe">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">4</span>Zobacz także</div>
		</a>
		
		<ul id="toc-Zobacz_także-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

				</div>
	</nav>
		
		<div class="mw-content-container">
			<main id="content" class="mw-body" role="main" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar">
					<label id="vector-toc-collapsed-button" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet vector-button-flush-left cdx-button--icon-only" for="vector-toc-collapsed-checkbox" role="button" aria-controls="vector-toc" tabindex="0" title="Table of Contents">
						<span class="vector-icon mw-ui-icon-wikimedia-listBullet"></span>
						<span>Toggle the table of contents</span>
					</label>
					<nav role="navigation" aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">HDMI-CEC (Polski)</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang">
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 1 language">
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-1" aria-hidden="true"><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">1 language</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-en mw-list-item"><a href="../en/HDMI-CEC.html" title="HDMI-CEC – English" lang="en" hreflang="en" class="interlanguage-link-target"><span>English</span></a></li>
			</ul>
			
		</div>

	</div>
</div>
</header>
				<div class="vector-column-end">
					<nav class="vector-page-tools-landmark vector-sticky-pinned-container" aria-label="Page tools">
						<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
			
						</div>
	</nav>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="pl" dir="ltr">
<div class="mw-parser-output">
<p>HDMI-CEC (<i>Consumer Electronics Control</i>) to magistrala o niskiej prędkości transmisji (50 bajtów na sekundę) na złączu HDMI, która służy do komunikacji pomiędzy urządzeniami HDMI w "sieci". Głównie pozwala urządzeniom HDMI na powiadamianie siebie nawzajem, że powinny się włączyć/wyłączyć, że telewizor zmienił źródło odtwarzania albo, że przycisk na pilocie został wciśnięty poza innymi czynnościami. Na komputerach osobistych HDMI-CEC najbardziej przydaje się w konfiguracji HTPC (PC jako kino domowe).
</p>
<p>Z różnych powodów prawie żadna karta graficzna (dla komputerów osobistych) nie wspiera CEC. Konsole gier wideo i dekodery zwykle zawierają zewnętrzny chipset, który obsługuje pin CEC. Podczas gdy istnieją urządzenia posiadające natywne wsparcie dla CEC (takie jak karta GPU VideoCore, która znajduje się w Raspberry Pi), większość konfiguracji potrzebowałyby adaptera USB CEC, aby móc działać. 
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Jeśli chcesz używać HDMI-CEC z <a href="../en/Kodi.html" title="Kodi">Kodi</a>, wiedz, że ma ono <a href="../en/Kodi.html#HDMI-CEC" title="Kodi">wbudowane wsparcie dla trybów sterowania CEC zarówno Pulse-Eight, jak i Raspberry Pi</a> i jest niekompatybilne z poniższą konfiguracją.</div>
<meta property="mw:PageProp/toc">
<h2><span class="mw-headline" id="Funkcje">Funkcje</span></h2>
<p>Głównym celem CEC jest pozwolenie telewizorowi na pozyskiwanie informacji z urządzeń podłączeń do niego i kontrolę nad nimi. W związku z tym jest on podzielony na tuzin "funkcji", z których każda jest ukierunkowana na określone przypadki użycia i które urządzenia mogą zdecydować się na obsługę lub nie w oparciu o ich rolę jako inicjatora / obserwatora, ich możliwości, a także konfigurację użytkownika.
</p>
<p>Standardowe funkcje to:
</p>
<dl>
<dt>Odtwarzanie Jednym Dotykiem (<i>One Touch Play</i>)</dt>
<dd>Pozwala urządzeniowi zasygnalizować, że chce ono natychmiastowo być aktywnym źródłem odtwarzania, co może automatycznie włączyć telewizor</dd>
<dt>Kontrola Trasowania (<i>Routing Control</i>)</dt>
<dd>Pozwala telewizorowi na kontrolę przekaźników HDMI oraz pozwala urządzeniom na sprawdzenie, które źródło jest aktualnie aktywne</dd>
<dt>Przejście Pilota (<i>Remote Control Passthrough</i>)</dt>
<dd>Pozwala urządzeniom na wysyłanie do siebie sygnałów z pilota, zazwyczaj z telewizora do aktywnego źródła</dd>
<dt>Kontrola Decku (<i>Deck Control</i>)</dt>
<dd>Służy do sterowania odtwarzaczem filmów/muzyki i do sprawdzania statusu odtwarzania</dd>
<dt>Czuwanie/Systemowe Czuwanie (<i>Standby/System Standby</i>)</dt>
<dd>Pozwala urządzeniowi wysłać żądanie o to, aby inne, specyficzne urządzenie zostało wyłączone, albo rozgłosić, że wszystkie urządzenie w systemie mają zostać wyłączone</dd>
<dt>Stan Zasilania (<i>Power Status</i>)</dt>
<dd>Pozwala sprawdzić czy dane urządzenie jest w trybie czuwania, jest włączone, albo czy jest w trakcie włączania.</dd>
<dt>Systemowe Sterowanie Dźwiękiem (<i>System Audio Control</i>)</dt>
<dd>Przyznaje kontrolę nad amplitunerem AV podłączonym przez kanał zwrotny audio telewizora, umożliwiając zmianę głośności oraz włączanie i wyłączanie amplitunera.</dd>
<dt>Sterowanie Tunerem (<i>Tuner Control</i>)</dt>
<dd>Umożliwia dowolnemu urządzeniu przeglądanie listy kanałów telewizyjnych znanych tunerowi i wyszukiwanie informacji o aktywnym kanale, takich jak numer kanału dla telewizji analogowej lub informacje o strumieniu transportowym DVB/ATSC/ARIB dla telewizji cyfrowej.</dd>
<dt>Nagrywanie Jednym Dotknięciem (<i>One Touch Record</i>)</dt>
<dd>Umożliwia nagrywarce sprawdzenie, jaki kanał jest aktualnie wyświetlany w telewizorze, dzięki czemu nagrywarka może dostroić się do tego samego kanału i rozpocząć nagrywanie lub dowiedzieć się, że powinna nagrywać siebie lub inne urządzenie, jeśli jest ono już aktualnie aktywnym źródłem HDMI</dd>
<dt>Programowanie Timera (<i>Timer Programming</i>)</dt>
<dd>Umożliwia telewizorowi skonfigurowanie timera na nagrywarce, aby rozpocząć nagrywanie danego źródła o określonej godzinie.</dd>
<dt>Wyświetlacz OSD (<i>OSD display</i>)</dt>
<dd>Umożliwia urządzeniu wydrukowanie na telewizorze komunikatu o długości od 1 do 13 znaków ASCII</dd>
<dt>Dynamiczny Auto-Lipsync (<i>Dynamic Auto Lipsync</i>)</dt>
<dd>Umożliwia telewizorowi transmitowanie zmian w opóźnieniu prezentacji do odbiornika audio, które źródło posiadające własne głośniki (np. komputer) może wykorzystać do kompensacji opóźnienia z obrazem</dd>
</dl>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Nie wymienione: Device Menu Control (przestarzałe w CEC 2.0), OSD name transfer (obsługiwane przez cec-ctl), System information, Vendor-specific command (brak standardowych komunikatów), Audio Rate Control (tylko TV-AV), Audio Return Channel Control (tylko TV-AV).</div>
<p>W przypadku urządzeń takich jak komputery PC, najbardziej użytecznym z nich będzie <b>Przejście Pilota</b>. <b>Systemowe Czuwanie</b> może być przydatne dla komputerów HTPC, ale byłoby wątpliwe w przypadku bardziej uniwersalnych maszyn, które zwykle nie powinny przechodzić w stan uśpienia po wyłączeniu ekranu. <b>Kontrola Trasowania</b> może być używana do wybudzania systemu, gdy telewizor próbuje wyświetlić to wejście, pod warunkiem, że podłączony komputer ma możliwość słuchania ruchu CEC podczas zawieszenia. <b>Systemowe Sterowanie Dźwiękiem</b> byłoby wygodne dla niektórych wyjść dźwiękowych HDMI, ale obecnie nie działa jako środek kontroli głośności z <a href="../en/PipeWire.html" title="PipeWire">PipeWire</a> lub <a href="../en/PulseAudio.html" title="PulseAudio">PulseAudio</a>.
</p>
<h2>
<span id="Konfiguracja_sprz.C4.99towa_CEC"></span><span class="mw-headline" id="Konfiguracja_sprzętowa_CEC">Konfiguracja sprzętowa CEC</span>
</h2>
<p>Jądro Linux ma już wbudowany podsystem do automatycznego odpowiadania na zapytania i obsługi zdarzeń CEC, ale sprzęt może wymagać wcześniejszej konfiguracji, aby działał.
</p>
<h3><span class="mw-headline" id="Natywne_CEC">Natywne CEC</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-view-fullscreen.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs expansion.</b></p>
<div>
<b>Reason:</b> Ktoś z odpowiednim sprzętem powinien to napisać, jeśli w ogóle jest coś do zrobienia. (Discuss in <a rel="nofollow" class="external text" href="../pl/Talk:HDMI-CEC.html">Talk:HDMI-CEC (Polski)</a>)</div>
</div>
<h3><span class="mw-headline" id="Adapter_CEC">Adapter CEC</span></h3>
<h4><span class="mw-headline" id="Adapter_USB_PulseEight">Adapter USB PulseEight</span></h4>
<p>Adapter <a rel="nofollow" class="external text" href="https://www.pulse-eight.com/p/104/usb-hdmi-cec-adapter">PulseEight USB-CEC</a> działa poprzez pasywne przedłużenie wszystkich pinów złącza HDMI od złącza "po stronie komputera" do złącza "po stronie telewizora", z wyjątkiem pinu CEC, który jest przechwytywany. Dane przechodzące przez ten pin są zamiast tego ujawniane przez interfejs szeregowy USB, aby umożliwić komputerowi kontrolowanie i monitorowanie ruchu CEC. <a href="../en/Serial_input_device_to_kernel_input.html" title="Serial input device to kernel input">Szeregowe urządzenie wejściowe</a> musi mieć swoją dyscyplinę linii (flagę sygnalizującą jądru, że TTY jest określonego znanego typu i wymaga sterownika do działania) skonfigurowaną ręcznie, zanim jądro przejmie i uzna ją za adapter CEC. Nie można tego zrobić automatycznie <a rel="nofollow" class="external text" href="https://lwn.net/Articles/700489/">z powodu ograniczeń związanych z interfejsami API urządzeń szeregowych</a>, więc obecnie najlepiej jest to osiągnąć za pomocą reguły <a href="../en/Udev.html" title="Udev">udev</a> sparowanej z jednostką <a href="../en/Systemd.html" title="Systemd">systemd</a> (ponieważ reguły udev nie mogą uruchamiać długo działających lub rozwidlających się procesów), aby uruchomić <code>inputattach --pulse8-cec ...</code>, gdy urządzenie jest podłączone.
</p>
<p>Ten interfejs szeregowy pojawia się jako węzeł urządzenia <code>/dev/ttyACM<i>X</i></code>, a narzędzie <i>inputattach</i> jest potrzebne do ustawienia dyscypliny linii i umożliwienia sterownikom jądra przejęcia tworzenia urządzenia <code>/dev/cec<i>X</i></code>, które będzie potrzebne później. Wymaga to pakietu <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=linuxconsole">linuxconsole</a></span>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Nie modyfikuj <code>@$devnode</code> w poniższej regule, jest to podstawienie ciągu udev.</div>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/pulse8-cec-autoattach.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="tty" ACTION=="add" ATTRS{manufacturer}=="Pulse-Eight" ATTRS{product}=="CEC Adapter" TAG+="systemd" ENV{SYSTEMD_WANTS}="pulse8-cec-attach@$devnode.service"</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/pulse8-cec-attach@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
# Powinien być nazwany "pulse8-cec-attach@-dev-ttyACM0.service" lub podobnie
Description=Skonfiguruj urządzenie szeregowe USB Pulse-Eight na %I
ConditionPathExists=%I

[Service]
Type=forking
# inputattach domyślnie jest budowany bez wsparcia dla daemona systemd, więc systemd będzie musiało zgadywać PID.
# <a rel="nofollow" class="external free" href="https://sourceforge.net/p/linuxconsole/code/ci/a3366c0d5f82485e6aae7b005ec7a2d9a93bf458/tree/utils/inputattach.c#l1233">https://sourceforge.net/p/linuxconsole/code/ci/a3366c0d5f82485e6aae7b005ec7a2d9a93bf458/tree/utils/inputattach.c#l1233</a>

ExecStart=/usr/bin/inputattach --daemon --pulse8-cec %I</pre>
<p>Jednak połączenia urządzeń USB <a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/persist.html">są zwykle resetowane po wybudzeniu systemu ze stanu uśpienia</a> (<a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/power-management.html">krok znany jako reset-resume</a>), co oznacza, że połączenie szeregowe zostanie utracone, jeśli komputer zostanie kiedykolwiek zawieszony, oprócz połączeń szeregowych zwykle zawieszających się po wznowieniu. Oznacza to, że powyższa reguła musi zostać w jakiś sposób ponownie uruchomiona.
</p>
<p>Niestety, sterownik <code>cdc_acm</code> odpowiedzialny za obiekt <code>ttyACM*</code>, na który reaguje powyższa reguła, nie podnosi żadnego zdarzenia ue o zresetowaniu połączenia i utracie dyscypliny linii, a reguły nie można podłączyć bezpośrednio do urządzenia USB. Zamiast tego najbardziej niezawodnym sposobem na ponowne uruchomienie powyższej reguły we właściwym czasie jest usunięcie i ponowne utworzenie obiektu <code>ttyACM*</code> <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/abi-stable.html#abi-sys-bus-usb-devices-bconfigurationvalue">poprzez wymuszenie rekonfiguracji urządzenia USB</a> po jego zresetowaniu. Aby zareagować na to i zapewnić ponowne otwarcie połączenia, udev może śledzić, kiedy urządzenie USB jest resetowane i wyliczane, o czym świadczy właściwość <code>DEVNUM</code>, która jest zerowana, a następnie przywracana, i dotyka atrybutu <code>bConfigurationValue</code> sysfs.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/pulse8-cec-autoattach.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="tty" ACTION=="add" ATTRS{manufacturer}=="Pulse-Eight" ATTRS{product}=="CEC Adapter" TAG+="systemd" ENV{SYSTEMD_WANTS}="pulse8-cec-attach@$devnode.service"

# Wymusza ponowną konfigurację urządzenia podczas resetowania po zawieszeniu, w przeciwnym razie łącze ttyACM zostanie utracone, ale udev tego nie zauważy.
# Zdarzenie usb_dev_uevent z DEVNUM=000 to znak, że urządzenie jest resetowane przed wyliczeniem.
# Ponowna konfiguracja powoduje usunięcie i ponowne dodanie ttyACM.
SUBSYSTEM=="usb" ACTION=="change" ATTR{manufacturer}=="Pulse-Eight" ATTR{product}=="CEC Adapter" ENV{DEVNUM}=="000" ATTR{bConfigurationValue}=="1" ATTR{bConfigurationValue}="1"</pre>
<p>Zasadniczo działa to tak, jakby adapter USB został odłączony i ponownie podłączony natychmiast po wyjściu ze stanu uśpienia, zapewniając, że reguła <code>SUBSYSTEM=="tty" ACTION=="add"</code> sprzed uruchomienia zostanie ponownie uruchomiona. Gwarantuje to, że usługa systemd zostanie ponownie uruchomiona, gdy tylko urządzenie powróci do stanu używalności.
</p>
<h3><span class="mw-headline" id="Tunelowanie_przez_DisplayPort">Tunelowanie przez DisplayPort</span></h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-view-fullscreen.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs expansion.</b></p>
<div>
<b>Reason:</b> Ktoś z odpowiednim sprzętem powinien to napisać. (Discuss in <a rel="nofollow" class="external text" href="../pl/Talk:HDMI-CEC.html">Talk:HDMI-CEC (Polski)</a>)</div>
</div>
<p>Standard DisplayPort 1.3 umożliwia adapterom DisplayPort-HDMI wykorzystanie kanału pomocniczego do przesyłania sygnałów CEC. Jest to rodzaj funkcji, której adaptery zwykle nie obsługują, chyba że o tym wspomniano, i nie jest powszechnie spotykana, ale wbrew intuicji korzystanie z tunelowania CEC przez DisplayPort może być tańsze i łatwiejsze niż praca z adapterem CEC. Strona dokumentacji jądra dla podmodułu CEC zawiera <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/media/cec.html#displayport-to-hdmi-adapters-with-working-cec">listę takich adapterów, których działanie zostało potwierdzone</a>.
</p>
<h2><span class="mw-headline" id="Konfiguracja_podsystemu_CEC">Konfiguracja podsystemu CEC</span></h2>
<p>Teraz, gdy podsystem CEC ma coś do powiązania i utworzono <code>/dev/cec0</code>, możliwe jest skonfigurowanie komputera tak, aby inne urządzenia CEC wiedziały o nim. Podczas korzystania z wiersza poleceń, urządzenia CEC są zwykle kontrolowane przez <code>cec-ctl</code>, który jest częścią <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=v4l-utils">v4l-utils</a></span>.
Należy pamiętać, że sam pin CEC nie ma wystarczającej ilości informacji, aby wysłać prawidłową wiadomość CEC. Adapter CEC, który monitoruje tylko pin 13 (CEC), nie może znać swojego "adresu fizycznego" (jego pozycji pod względem numerów portów w "drzewie" urządzeń HDMI, takich jak <code>3.1.0.0</code>), którego musi być świadomy, aby zakończyć procedurę przydzielania adresu logicznego. Bez adresu logicznego urządzenie może jedynie odbierać i wysyłać wiadomości rozgłoszeniowe. Adres fizyczny jest przekazywany przez pin 16 (DDC/EDID), więc konfiguracja podsystemu CEC obejmuje określenie, który port wyjściowy wyświetlacza ma być powiązany z tym obiektem CEC, aby adres fizyczny mógł zostać wyodrębniony z EDID wyświetlacza.
</p>
<p>Jednym ze sposobów na znalezienie nazwy aktywnych konektorów jest użycie <code>xrandr --query</code> (które działa również na Waylandzie):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ xrandr --query </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Screen 0: minimum 16 x 16, current 3840 x 2160, maximum 32767 x 32767
DP-1 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 600mm x 340mm
   3840x2160     59.98*+
   2048x1536     59.95  
   ...
HDMI-A-1 connected 3840x2160+0+0 (normal left inverted right x axis y axis) 1440mm x 810mm
   3840x2160     59.98*+
   2048x1536     59.95  
   ...
</pre>
<p>Po zidentyfikowaniu właściwego portu (na przykład <code>HDMI-A-1</code>), nazwę portu sysfs można znaleźć za pomocą <code>ls -1d /sys/class/drm/card*-HDMI-A-1</code> (np. <code>card1-HDMI-A-1</code>). W takim przypadku dane EDID odpowiedniego wyświetlacza będą przechowywane w <code>/sys/class/drm/card1-HDMI-A-1/edid</code>.
</p>
<p>Biorąc pod uwagę, że konfiguracja CEC musi być wykonywana za każdym razem, gdy węzeł urządzenia <code>cec</code> jest ponownie tworzony, najlepiej jest to obsłużyć za pomocą innej reguły udev, która uruchamia się, gdy pojawia się obiekt <code>cec</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Pamiętaj, aby zastąpić <code>card1-HDMI-A-1</code> w poniższej regule nazwą złącza.</div>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/cec-configure-autostart.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="cec" KERNEL=="cec0" ACTION=="add" TAG+="systemd" ENV{SYSTEMD_WANTS}="cec0-configure@card1-HDMI-A-1.service"</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/cec0-configure@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
# Should be called as "cec0-configure@card1-HDMI-A-1.service" or similar
Description=Configure CEC adapter cec0 assuming it runs on output %i
AssertPathExists=/sys/class/drm/%i/edid
BindsTo=dev-cec0.device

[Service]  
Type=exec  
# --phys-addr-from-edid-poll sprawdza EDID co jedną dziesiątą sekundy
# <a rel="nofollow" class="external free" href="https://git.linuxtv.org/v4l-utils.git/tree/utils/cec-ctl/cec-ctl.cpp?id=0a195181d771090f3c99d4a6ddb8151352509061#n1977">https://git.linuxtv.org/v4l-utils.git/tree/utils/cec-ctl/cec-ctl.cpp?id=0a195181d771090f3c99d4a6ddb8151352509061#n1977</a>
# Użyj `Type=oneshot` jeśli zamiast tego używasz `--phys-addr-from-edid`.
ExecStart=/usr/bin/cec-ctl --device=0 "--osd-name=%H" --playback "--phys-addr-from-edid-poll=/sys/class/drm/%i/edid"</pre>
<p>Istnieją trzy klasy urządzeń, które źródło HDMI może próbować reklamować jako "urządzenie nagrywające" (maks. 3), "tuner" (maks. 4) i "urządzenie odtwarzające" (maks. 3). Jest to ważne, ponieważ urządzenia HDMI nie używają swojego adresu fizycznego podczas komunikacji między sobą za pośrednictwem CEC, ale 4-bitowego "adresu logicznego", który identyfikuje urządzenia jako "Tuner #3" lub "Urządzenie odtwarzające #1", z określoną liczbą każdego z nich. Jeśli przydzielenie adresu nie powiedzie się z powodu obecności zbyt wielu urządzeń jednego typu, można zamiast tego przypisać rolę "Backup" (maksymalnie 2). Role te mają odnosić się do <a href="#Funkcje">funkcji CEC</a> wspomnianych wcześniej, a mianowicie:
</p>
<ul>
<li>"Tuner" powinien obsługiwać "Sterowanie Tunerem".</li>
<li>"Urządzenie nagrywające" to jedyny typ, który może korzystać z funkcji Nagrywanie Jednym Dotknięciem, ponieważ telewizory mają ignorować powiązane wiadomości pochodzące z innych adresów</li>
<li>"Urządzenie odtwarzające" dotyczy źródeł wideo ogólnego przeznaczenia. Komputery, podobnie jak konsole do gier wideo, są uważane za "urządzenia odtwarzające".</li>
</ul>
<p>Powyższa jednostka <code>cec0-configure@.service</code> używa <code>--playback</code> do konfiguracji urządzenia odtwarzającego. Ogólnie rzecz biorąc, dobrze jest jednak ustawić klasę urządzenia na Tuner (<code>--tuner</code>) lub urządzenie nagrywające (<code>--record</code>), czy to dlatego, że nie ma już nieużywanych adresów odtwarzania, czy po prostu dlatego, by komputer wyróżniał się na liście w telewizorach, które wizualnie rozróżniają każdą klasę urządzenia w menu wejściowym.
</p>
<h2>
<span id="Zobacz_tak.C5.BCe"></span><span class="mw-headline" id="Zobacz_także">Zobacz także</span>
</h2>
<ul>
<li>"<a rel="nofollow" class="external text" href="https://www.youtube.com/watch?v=Q6S2FabX2WA">HDMI CEC: What? Why? How?</a>" autorstwa Hansa Verkuila, który napisał większość podsystemu CEC</li>
<li>
<a rel="nofollow" class="external text" href="https://www.cec-o-matic.com/">CEC-O-Matic</a>, który umożliwia tworzenie nieprzetworzonych komunikatów CEC i daje przegląd tego, co składa się na prawidłową ramkę CEC</li>
<li><a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/media/cec.html">Dokumentacja podsystemu CEC</a></li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../pl/Category:Hardware.html" title="Category:Hardware (Polski)">Hardware (Polski)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li></ul>
</div>
</div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=HDMI-CEC_(Polski)&amp;oldid=798691">https://wiki.archlinux.org/index.php?title=HDMI-CEC_(Polski)&amp;oldid=798691</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 28 January 2024, at 15:08.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul>
		<li>
		
		<button class="cdx-button cdx-button--icon-only vector-limited-width-toggle" id=""><span class="vector-icon mw-ui-icon-fullScreen mw-ui-icon-wikimedia-fullScreen"></span>

<span>Toggle limited content width</span>
</button>
</li>
	</ul>
</div>
</body>
</html>
