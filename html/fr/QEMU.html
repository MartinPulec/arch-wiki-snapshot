<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-0 vector-feature-client-preferences-disabled vector-feature-client-prefs-pinned-disabled vector-feature-night-mode-disabled skin-theme-clientpref-day vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>QEMU (Français) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.42.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-QEMU_Français rootpage-QEMU_Français skin-vector-2022 action-view skin--responsive">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" role="navigation" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Installation" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Installation">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">1</span>Installation</div>
		</a>
		
			<button aria-controls="toc-Installation-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Installation subsection</span>
			</button>
		
		<ul id="toc-Installation-sublist" class="vector-toc-list">
			<li id="toc-Variantes_de_QEMU" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Variantes_de_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">1.1</span>Variantes de QEMU</div>
			</a>
			
			<ul id="toc-Variantes_de_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Détails_sur_les_paquets_offerts_dans_Arch_Linux" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9tails_sur_les_paquets_offerts_dans_Arch_Linux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">1.2</span>Détails sur les paquets offerts dans Arch Linux</div>
			</a>
			
			<ul id="toc-Détails_sur_les_paquets_offerts_dans_Arch_Linux-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Interfaces_graphiques_pour_QEMU" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Interfaces_graphiques_pour_QEMU">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">2</span>Interfaces graphiques pour QEMU</div>
		</a>
		
		<ul id="toc-Interfaces_graphiques_pour_QEMU-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Créer_un_nouveau_système_virtualisé" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Cr%C3%A9er_un_nouveau_syst%C3%A8me_virtualis%C3%A9">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">3</span>Créer un nouveau système virtualisé</div>
		</a>
		
			<button aria-controls="toc-Créer_un_nouveau_système_virtualisé-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Créer un nouveau système virtualisé subsection</span>
			</button>
		
		<ul id="toc-Créer_un_nouveau_système_virtualisé-sublist" class="vector-toc-list">
			<li id="toc-Création_d'une_image_de_disque_dur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Cr%C3%A9ation_d'une_image_de_disque_dur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1</span>Création d'une image de disque dur</div>
			</a>
			
			<ul id="toc-Création_d'une_image_de_disque_dur-sublist" class="vector-toc-list">
				<li id="toc-Images_de_stockage_superposées" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Images_de_stockage_superpos%C3%A9es">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.1</span>Images de stockage superposées</div>
			</a>
			
			<ul id="toc-Images_de_stockage_superposées-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Redimensionnement_d'une_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Redimensionnement_d'une_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.2</span>Redimensionnement d'une image</div>
			</a>
			
			<ul id="toc-Redimensionnement_d'une_image-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Convertir_une_image" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Convertir_une_image">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.1.3</span>Convertir une image</div>
			</a>
			
			<ul id="toc-Convertir_une_image-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Préparation_du_support_d'installation" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pr%C3%A9paration_du_support_d'installation">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.2</span>Préparation du support d'installation</div>
			</a>
			
			<ul id="toc-Préparation_du_support_d'installation-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Installation_du_système_d'exploitation" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Installation_du_syst%C3%A8me_d'exploitation">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">3.3</span>Installation du système d'exploitation</div>
			</a>
			
			<ul id="toc-Installation_du_système_d'exploitation-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Exécution_du_système_virtualisé" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Ex%C3%A9cution_du_syst%C3%A8me_virtualis%C3%A9">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">4</span>Exécution du système virtualisé</div>
		</a>
		
			<button aria-controls="toc-Exécution_du_système_virtualisé-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Exécution du système virtualisé subsection</span>
			</button>
		
		<ul id="toc-Exécution_du_système_virtualisé-sublist" class="vector-toc-list">
			<li id="toc-Activation_de_KVM" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Activation_de_KVM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.1</span>Activation de KVM</div>
			</a>
			
			<ul id="toc-Activation_de_KVM-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Activation_du_support_IOMMU_(Intel_VT-d/AMD-Vi)" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Activation_du_support_IOMMU_(Intel_VT-d/AMD-Vi)">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">4.2</span>Activation du support IOMMU (Intel VT-d/AMD-Vi)</div>
			</a>
			
			<ul id="toc-Activation_du_support_IOMMU_(Intel_VT-d/AMD-Vi)-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Partage_des_données_entre_l'hôte_et_l'invité" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Partage_des_donn%C3%A9es_entre_l'h%C3%B4te_et_l'invit%C3%A9">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">5</span>Partage des données entre l'hôte et l'invité</div>
		</a>
		
			<button aria-controls="toc-Partage_des_données_entre_l'hôte_et_l'invité-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Partage des données entre l'hôte et l'invité subsection</span>
			</button>
		
		<ul id="toc-Partage_des_données_entre_l'hôte_et_l'invité-sublist" class="vector-toc-list">
			<li id="toc-Réseau" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#R%C3%A9seau">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.1</span>Réseau</div>
			</a>
			
			<ul id="toc-Réseau-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-La_redirection_de_port_de_QEMU" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#La_redirection_de_port_de_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.2</span>La redirection de port de QEMU</div>
			</a>
			
			<ul id="toc-La_redirection_de_port_de_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Le_serveur_SMB_intégré_de_QEMU" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Le_serveur_SMB_int%C3%A9gr%C3%A9_de_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.3</span>Le serveur SMB intégré de QEMU</div>
			</a>
			
			<ul id="toc-Le_serveur_SMB_intégré_de_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Utiliser_le_passage_de_système_de_fichiers_et_VirtFS" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Utiliser_le_passage_de_syst%C3%A8me_de_fichiers_et_VirtFS">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.4</span>Utiliser le passage de système de fichiers et VirtFS</div>
			</a>
			
			<ul id="toc-Utiliser_le_passage_de_système_de_fichiers_et_VirtFS-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Partage_de_fichiers_avec_virtiofsd" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Partage_de_fichiers_avec_virtiofsd">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.5</span>Partage de fichiers avec virtiofsd</div>
			</a>
			
			<ul id="toc-Partage_de_fichiers_avec_virtiofsd-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Montage_d'une_partition_de_l'invité_sur_l'hôte" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Montage_d'une_partition_de_l'invit%C3%A9_sur_l'h%C3%B4te">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6</span>Montage d'une partition de l'invité sur l'hôte</div>
			</a>
			
			<ul id="toc-Montage_d'une_partition_de_l'invité_sur_l'hôte-sublist" class="vector-toc-list">
				<li id="toc-Montage_d'une_partition_à_partir_d'une_image_brute" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Montage_d'une_partition_%C3%A0_partir_d'une_image_brute">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1</span>Montage d'une partition à partir d'une image brute</div>
			</a>
			
			<ul id="toc-Montage_d'une_partition_à_partir_d'une_image_brute-sublist" class="vector-toc-list">
				<li id="toc-En_spécifiant_manuellement_le_décalage_des_octets" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#En_sp%C3%A9cifiant_manuellement_le_d%C3%A9calage_des_octets">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.1</span>En spécifiant manuellement le décalage des octets</div>
			</a>
			
			<ul id="toc-En_spécifiant_manuellement_le_décalage_des_octets-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Avec_le_module_loop_autodétectant_les_partitions" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Avec_le_module_loop_autod%C3%A9tectant_les_partitions">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.2</span>Avec le module loop autodétectant les partitions</div>
			</a>
			
			<ul id="toc-Avec_le_module_loop_autodétectant_les_partitions-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Avec_kpartx" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Avec_kpartx">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.1.3</span>Avec kpartx</div>
			</a>
			
			<ul id="toc-Avec_kpartx-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Montage_d'une_partition_à_partir_d'une_image_qcow2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Montage_d'une_partition_%C3%A0_partir_d'une_image_qcow2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.6.2</span>Montage d'une partition à partir d'une image qcow2</div>
			</a>
			
			<ul id="toc-Montage_d'une_partition_à_partir_d'une_image_qcow2-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Utilisation_de_n'importe_quelle_partition_réelle_comme_partition_primaire_unique_d'une_image_de_disque_dur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Utilisation_de_n'importe_quelle_partition_r%C3%A9elle_comme_partition_primaire_unique_d'une_image_de_disque_dur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7</span>Utilisation de n'importe quelle partition réelle comme partition primaire unique d'une image de disque dur</div>
			</a>
			
			<ul id="toc-Utilisation_de_n'importe_quelle_partition_réelle_comme_partition_primaire_unique_d'une_image_de_disque_dur-sublist" class="vector-toc-list">
				<li id="toc-Spécifier_le_noyau_et_l'initrd_manuellement" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Sp%C3%A9cifier_le_noyau_et_l'initrd_manuellement">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.1</span>Spécifier le noyau et l'initrd manuellement</div>
			</a>
			
			<ul id="toc-Spécifier_le_noyau_et_l'initrd_manuellement-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Simulation_d'un_disque_virtuel_avec_MBR" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Simulation_d'un_disque_virtuel_avec_MBR">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2</span>Simulation d'un disque virtuel avec MBR</div>
			</a>
			
			<ul id="toc-Simulation_d'un_disque_virtuel_avec_MBR-sublist" class="vector-toc-list">
				<li id="toc-Utilisation_du_device-mapper" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Utilisation_du_device-mapper">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.1</span>Utilisation du device-mapper</div>
			</a>
			
			<ul id="toc-Utilisation_du_device-mapper-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Utilisation_d'un_RAID_linéaire" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Utilisation_d'un_RAID_lin%C3%A9aire">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.2</span>Utilisation d'un RAID linéaire</div>
			</a>
			
			<ul id="toc-Utilisation_d'un_RAID_linéaire-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Utilisation_d'un_périphérique_de_bloc_en_réseau" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Utilisation_d'un_p%C3%A9riph%C3%A9rique_de_bloc_en_r%C3%A9seau">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.7.2.3</span>Utilisation d'un périphérique de bloc en réseau</div>
			</a>
			
			<ul id="toc-Utilisation_d'un_périphérique_de_bloc_en_réseau-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Utilisation_d'un_périphérique_de_disque_physique_entier_à_l'intérieur_de_la_VM" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Utilisation_d'un_p%C3%A9riph%C3%A9rique_de_disque_physique_entier_%C3%A0_l'int%C3%A9rieur_de_la_VM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8</span>Utilisation d'un périphérique de disque physique entier à l'intérieur de la VM</div>
			</a>
			
			<ul id="toc-Utilisation_d'un_périphérique_de_disque_physique_entier_à_l'intérieur_de_la_VM-sublist" class="vector-toc-list">
				<li id="toc-prérequis_pour_le_démarrage_de_la_VM_Windows" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#pr%C3%A9requis_pour_le_d%C3%A9marrage_de_la_VM_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.1</span>prérequis pour le démarrage de la VM Windows</div>
			</a>
			
			<ul id="toc-prérequis_pour_le_démarrage_de_la_VM_Windows-sublist" class="vector-toc-list">
				<li id="toc-configurer_les_pilotes_de_l'interface_disque_de_windows" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#configurer_les_pilotes_de_l'interface_disque_de_windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.1.1</span>configurer les pilotes de l'interface disque de windows</div>
			</a>
			
			<ul id="toc-configurer_les_pilotes_de_l'interface_disque_de_windows-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-trouver_le_chemin_unique_de_votre_disque" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#trouver_le_chemin_unique_de_votre_disque">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.2</span>trouver le chemin unique de votre disque</div>
			</a>
			
			<ul id="toc-trouver_le_chemin_unique_de_votre_disque-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-ajouter_le_disque_dans_la_CLI_QEMU" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#ajouter_le_disque_dans_la_CLI_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.3</span>ajouter le disque dans la CLI QEMU</div>
			</a>
			
			<ul id="toc-ajouter_le_disque_dans_la_CLI_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-ajouter_le_disque_dans_libvirt" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#ajouter_le_disque_dans_libvirt">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.4</span>ajouter le disque dans libvirt</div>
			</a>
			
			<ul id="toc-ajouter_le_disque_dans_libvirt-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-ajouter_le_disque_dans_virt-manager" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#ajouter_le_disque_dans_virt-manager">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">5.8.5</span>ajouter le disque dans virt-manager</div>
			</a>
			
			<ul id="toc-ajouter_le_disque_dans_virt-manager-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Mise_en_réseau" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Mise_en_r%C3%A9seau">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">6</span>Mise en réseau</div>
		</a>
		
			<button aria-controls="toc-Mise_en_réseau-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Mise en réseau subsection</span>
			</button>
		
		<ul id="toc-Mise_en_réseau-sublist" class="vector-toc-list">
			<li id="toc-Mise_en_garde_concernant_l'adresse_au_niveau_du_lien" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mise_en_garde_concernant_l'adresse_au_niveau_du_lien">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.1</span>Mise en garde concernant l'adresse au niveau du lien</div>
			</a>
			
			<ul id="toc-Mise_en_garde_concernant_l'adresse_au_niveau_du_lien-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Mise_en_réseau_en_mode_utilisateur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mise_en_r%C3%A9seau_en_mode_utilisateur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.2</span>Mise en réseau en mode utilisateur</div>
			</a>
			
			<ul id="toc-Mise_en_réseau_en_mode_utilisateur-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Mise_en_réseau_avec_tap_pour_QEMU" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mise_en_r%C3%A9seau_avec_tap_pour_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3</span>Mise en réseau avec tap pour QEMU</div>
			</a>
			
			<ul id="toc-Mise_en_réseau_avec_tap_pour_QEMU-sublist" class="vector-toc-list">
				<li id="toc-Mise_en_réseau_uniquement_avec_l'hôte" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Mise_en_r%C3%A9seau_uniquement_avec_l'h%C3%B4te">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.1</span>Mise en réseau uniquement avec l'hôte</div>
			</a>
			
			<ul id="toc-Mise_en_réseau_uniquement_avec_l'hôte-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Réseau_interne" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#R%C3%A9seau_interne">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.2</span>Réseau interne</div>
			</a>
			
			<ul id="toc-Réseau_interne-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Réseau_ponté_utilisant_qemu-bridge-helper" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#R%C3%A9seau_pont%C3%A9_utilisant_qemu-bridge-helper">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.3</span>Réseau ponté utilisant qemu-bridge-helper</div>
			</a>
			
			<ul id="toc-Réseau_ponté_utilisant_qemu-bridge-helper-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Créer_un_pont_manuellement" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Cr%C3%A9er_un_pont_manuellement">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.4</span>Créer un pont manuellement</div>
			</a>
			
			<ul id="toc-Créer_un_pont_manuellement-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Partage_de_réseau_entre_un_périphérique_physique_et_un_périphérique_Tap_via_iptables" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Partage_de_r%C3%A9seau_entre_un_p%C3%A9riph%C3%A9rique_physique_et_un_p%C3%A9riph%C3%A9rique_Tap_via_iptables">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.3.5</span>Partage de réseau entre un périphérique physique et un périphérique Tap via iptables</div>
			</a>
			
			<ul id="toc-Partage_de_réseau_entre_un_périphérique_physique_et_un_périphérique_Tap_via_iptables-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Mise_en_réseau_avec_VDE2" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Mise_en_r%C3%A9seau_avec_VDE2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4</span>Mise en réseau avec VDE2</div>
			</a>
			
			<ul id="toc-Mise_en_réseau_avec_VDE2-sublist" class="vector-toc-list">
				<li id="toc-Qu'est-ce_que_VDE_?" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Qu'est-ce_que_VDE_?">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.1</span>Qu'est-ce que VDE ?</div>
			</a>
			
			<ul id="toc-Qu'est-ce_que_VDE_?-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Notions_de_base" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Notions_de_base">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.2</span>Notions de base</div>
			</a>
			
			<ul id="toc-Notions_de_base-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Scripts_de_démarrage" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Scripts_de_d%C3%A9marrage">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.3</span>Scripts de démarrage</div>
			</a>
			
			<ul id="toc-Scripts_de_démarrage-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Méthode_alternative" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#M%C3%A9thode_alternative">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.4.4</span>Méthode alternative</div>
			</a>
			
			<ul id="toc-Méthode_alternative-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Pont_VDE2" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pont_VDE2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5</span>Pont VDE2</div>
			</a>
			
			<ul id="toc-Pont_VDE2-sublist" class="vector-toc-list">
				<li id="toc-Notions_de_base_2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Notions_de_base_2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5.1</span>Notions de base</div>
			</a>
			
			<ul id="toc-Notions_de_base_2-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Scripts_de_démarrage_2" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Scripts_de_d%C3%A9marrage_2">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.5.2</span>Scripts de démarrage</div>
			</a>
			
			<ul id="toc-Scripts_de_démarrage_2-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Configuration_abrégée" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Configuration_abr%C3%A9g%C3%A9e">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">6.6</span>Configuration abrégée</div>
			</a>
			
			<ul id="toc-Configuration_abrégée-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Carte_graphique" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Carte_graphique">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">7</span>Carte graphique</div>
		</a>
		
			<button aria-controls="toc-Carte_graphique-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Carte graphique subsection</span>
			</button>
		
		<ul id="toc-Carte_graphique-sublist" class="vector-toc-list">
			<li id="toc-std" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#std">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.1</span>std</div>
			</a>
			
			<ul id="toc-std-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-qxl" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#qxl">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.2</span>qxl</div>
			</a>
			
			<ul id="toc-qxl-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-vmware" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#vmware">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.3</span>vmware</div>
			</a>
			
			<ul id="toc-vmware-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-virtio" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#virtio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.4</span>virtio</div>
			</a>
			
			<ul id="toc-virtio-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-cirrus" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#cirrus">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.5</span>cirrus</div>
			</a>
			
			<ul id="toc-cirrus-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-none" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#none">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">7.6</span>none</div>
			</a>
			
			<ul id="toc-none-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-SPICE" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#SPICE">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">8</span>SPICE</div>
		</a>
		
			<button aria-controls="toc-SPICE-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle SPICE subsection</span>
			</button>
		
		<ul id="toc-SPICE-sublist" class="vector-toc-list">
			<li id="toc-Activation_du_support_SPICE_sur_l'hôte" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Activation_du_support_SPICE_sur_l'h%C3%B4te">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.1</span>Activation du support SPICE sur l'hôte</div>
			</a>
			
			<ul id="toc-Activation_du_support_SPICE_sur_l'hôte-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Se_connecter_à_l'invité_avec_un_client_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Se_connecter_%C3%A0_l'invit%C3%A9_avec_un_client_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2</span>Se connecter à l'invité avec un client SPICE</div>
			</a>
			
			<ul id="toc-Se_connecter_à_l'invité_avec_un_client_SPICE-sublist" class="vector-toc-list">
				<li id="toc-Exécution_manuelle_d'un_client_SPICE" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Ex%C3%A9cution_manuelle_d'un_client_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2.1</span>Exécution manuelle d'un client SPICE</div>
			</a>
			
			<ul id="toc-Exécution_manuelle_d'un_client_SPICE-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Exécuter_un_client_SPICE_avec_QEMU" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Ex%C3%A9cuter_un_client_SPICE_avec_QEMU">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.2.2</span>Exécuter un client SPICE avec QEMU</div>
			</a>
			
			<ul id="toc-Exécuter_un_client_SPICE_avec_QEMU-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Activation_du_support_SPICE_sur_l'invité" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Activation_du_support_SPICE_sur_l'invit%C3%A9">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.3</span>Activation du support SPICE sur l'invité</div>
			</a>
			
			<ul id="toc-Activation_du_support_SPICE_sur_l'invité-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Authentification_par_mot_de_passe_avec_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Authentification_par_mot_de_passe_avec_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.4</span>Authentification par mot de passe avec SPICE</div>
			</a>
			
			<ul id="toc-Authentification_par_mot_de_passe_avec_SPICE-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Communication_chiffrée_TLS_avec_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Communication_chiffr%C3%A9e_TLS_avec_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">8.5</span>Communication chiffrée TLS avec SPICE</div>
			</a>
			
			<ul id="toc-Communication_chiffrée_TLS_avec_SPICE-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-VNC" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#VNC">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">9</span>VNC</div>
		</a>
		
			<button aria-controls="toc-VNC-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle VNC subsection</span>
			</button>
		
		<ul id="toc-VNC-sublist" class="vector-toc-list">
			<li id="toc-Authentification_par_mot_de_passe_de_base" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Authentification_par_mot_de_passe_de_base">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">9.1</span>Authentification par mot de passe de base</div>
			</a>
			
			<ul id="toc-Authentification_par_mot_de_passe_de_base-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Audio" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Audio">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">10</span>Audio</div>
		</a>
		
			<button aria-controls="toc-Audio-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Audio subsection</span>
			</button>
		
		<ul id="toc-Audio-sublist" class="vector-toc-list">
			<li id="toc-Créer_un_backend_audio" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Cr%C3%A9er_un_backend_audio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.1</span>Créer un backend audio</div>
			</a>
			
			<ul id="toc-Créer_un_backend_audio-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Utiliser_le_backend_audio" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Utiliser_le_backend_audio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2</span>Utiliser le backend audio</div>
			</a>
			
			<ul id="toc-Utiliser_le_backend_audio-sublist" class="vector-toc-list">
				<li id="toc-Intel_HD_Audio" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Intel_HD_Audio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2.1</span>Intel HD Audio</div>
			</a>
			
			<ul id="toc-Intel_HD_Audio-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Intel_82801AA_AC97" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Intel_82801AA_AC97">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">10.2.2</span>Intel 82801AA AC97</div>
			</a>
			
			<ul id="toc-Intel_82801AA_AC97-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Installation_des_pilotes_virtio" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Installation_des_pilotes_virtio">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">11</span>Installation des pilotes virtio</div>
		</a>
		
			<button aria-controls="toc-Installation_des_pilotes_virtio-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Installation des pilotes virtio subsection</span>
			</button>
		
		<ul id="toc-Installation_des_pilotes_virtio-sublist" class="vector-toc-list">
			<li id="toc-Préparer_un_invité_Arch_Linux" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pr%C3%A9parer_un_invit%C3%A9_Arch_Linux">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.1</span>Préparer un invité Arch Linux</div>
			</a>
			
			<ul id="toc-Préparer_un_invité_Arch_Linux-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Préparation_d'un_invité_Windows" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pr%C3%A9paration_d'un_invit%C3%A9_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2</span>Préparation d'un invité Windows</div>
			</a>
			
			<ul id="toc-Préparation_d'un_invité_Windows-sublist" class="vector-toc-list">
				<li id="toc-Pilotes_Virtio_pour_Windows" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Pilotes_Virtio_pour_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.1</span>Pilotes Virtio pour Windows</div>
			</a>
			
			<ul id="toc-Pilotes_Virtio_pour_Windows-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pilotes_de_périphérique_de_bloc" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Pilotes_de_p%C3%A9riph%C3%A9rique_de_bloc">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2</span>Pilotes de périphérique de bloc</div>
			</a>
			
			<ul id="toc-Pilotes_de_périphérique_de_bloc-sublist" class="vector-toc-list">
				<li id="toc-Nouvelle_installation_de_Windows" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Nouvelle_installation_de_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2.1</span>Nouvelle installation de Windows</div>
			</a>
			
			<ul id="toc-Nouvelle_installation_de_Windows-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Modifier_une_VM_Windows_existante_pour_utiliser_virtio" class="vector-toc-list-item vector-toc-level-4">
			<a class="vector-toc-link" href="#Modifier_une_VM_Windows_existante_pour_utiliser_virtio">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.2.2</span>Modifier une VM Windows existante pour utiliser virtio</div>
			</a>
			
			<ul id="toc-Modifier_une_VM_Windows_existante_pour_utiliser_virtio-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Pilotes_réseau" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Pilotes_r%C3%A9seau">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.3</span>Pilotes réseau</div>
			</a>
			
			<ul id="toc-Pilotes_réseau-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pilote_de_ballon" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Pilote_de_ballon">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.2.4</span>Pilote de ballon</div>
			</a>
			
			<ul id="toc-Pilote_de_ballon-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Préparer_un_invité_FreeBSD" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pr%C3%A9parer_un_invit%C3%A9_FreeBSD">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">11.3</span>Préparer un invité FreeBSD</div>
			</a>
			
			<ul id="toc-Préparer_un_invité_FreeBSD-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Moniteur_de_QEMU" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Moniteur_de_QEMU">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">12</span>Moniteur de QEMU</div>
		</a>
		
			<button aria-controls="toc-Moniteur_de_QEMU-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Moniteur de QEMU subsection</span>
			</button>
		
		<ul id="toc-Moniteur_de_QEMU-sublist" class="vector-toc-list">
			<li id="toc-Accès_à_la_console_de_surveillance" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Acc%C3%A8s_%C3%A0_la_console_de_surveillance">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1</span>Accès à la console de surveillance</div>
			</a>
			
			<ul id="toc-Accès_à_la_console_de_surveillance-sublist" class="vector-toc-list">
				<li id="toc-Vue_graphique" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Vue_graphique">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.1</span>Vue graphique</div>
			</a>
			
			<ul id="toc-Vue_graphique-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Telnet" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Telnet">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.2</span>Telnet</div>
			</a>
			
			<ul id="toc-Telnet-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Socket_UNIX" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Socket_UNIX">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.3</span>Socket UNIX</div>
			</a>
			
			<ul id="toc-Socket_UNIX-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-TCP" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#TCP">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.4</span>TCP</div>
			</a>
			
			<ul id="toc-TCP-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-E/S_standard" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#E/S_standard">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.1.5</span>E/S standard</div>
			</a>
			
			<ul id="toc-E/S_standard-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Envoyer_les_frappes_du_clavier_à_la_machine_virtuelle_en_utilisant_la_console_du_moniteur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Envoyer_les_frappes_du_clavier_%C3%A0_la_machine_virtuelle_en_utilisant_la_console_du_moniteur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.2</span>Envoyer les frappes du clavier à la machine virtuelle en utilisant la console du moniteur</div>
			</a>
			
			<ul id="toc-Envoyer_les_frappes_du_clavier_à_la_machine_virtuelle_en_utilisant_la_console_du_moniteur-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Création_et_gestion_des_snapshots_via_la_console_du_moniteur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Cr%C3%A9ation_et_gestion_des_snapshots_via_la_console_du_moniteur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.3</span>Création et gestion des snapshots via la console du moniteur</div>
			</a>
			
			<ul id="toc-Création_et_gestion_des_snapshots_via_la_console_du_moniteur-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Exécuter_la_machine_virtuelle_en_mode_immuable" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Ex%C3%A9cuter_la_machine_virtuelle_en_mode_immuable">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.4</span>Exécuter la machine virtuelle en mode immuable</div>
			</a>
			
			<ul id="toc-Exécuter_la_machine_virtuelle_en_mode_immuable-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Options_de_pause_et_d'alimentation_via_la_console_du_moniteur" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Options_de_pause_et_d'alimentation_via_la_console_du_moniteur">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.5</span>Options de pause et d'alimentation via la console du moniteur</div>
			</a>
			
			<ul id="toc-Options_de_pause_et_d'alimentation_via_la_console_du_moniteur-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Prendre_des_captures_d'écran_de_la_machine_virtuelle" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Prendre_des_captures_d'%C3%A9cran_de_la_machine_virtuelle">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">12.6</span>Prendre des captures d'écran de la machine virtuelle</div>
			</a>
			
			<ul id="toc-Prendre_des_captures_d'écran_de_la_machine_virtuelle-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Protocole_machine_QEMU" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Protocole_machine_QEMU">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">13</span>Protocole machine QEMU</div>
		</a>
		
			<button aria-controls="toc-Protocole_machine_QEMU-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Protocole machine QEMU subsection</span>
			</button>
		
		<ul id="toc-Protocole_machine_QEMU-sublist" class="vector-toc-list">
			<li id="toc-Démarrer_QMP" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9marrer_QMP">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.1</span>Démarrer QMP</div>
			</a>
			
			<ul id="toc-Démarrer_QMP-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Fusion_en_direct_de_l'image_enfant_dans_l'image_parent" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Fusion_en_direct_de_l'image_enfant_dans_l'image_parent">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.2</span>Fusion en direct de l'image enfant dans l'image parent</div>
			</a>
			
			<ul id="toc-Fusion_en_direct_de_l'image_enfant_dans_l'image_parent-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Création_en_direct_d'un_nouvel_instantané" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Cr%C3%A9ation_en_direct_d'un_nouvel_instantan%C3%A9">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">13.3</span>Création en direct d'un nouvel instantané</div>
			</a>
			
			<ul id="toc-Création_en_direct_d'un_nouvel_instantané-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Trucs_et_astuces" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Trucs_et_astuces">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">14</span>Trucs et astuces</div>
		</a>
		
			<button aria-controls="toc-Trucs_et_astuces-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Trucs et astuces subsection</span>
			</button>
		
		<ul id="toc-Trucs_et_astuces-sublist" class="vector-toc-list">
			<li id="toc-Améliorer_les_performances_de_la_machine_virtuelle" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Am%C3%A9liorer_les_performances_de_la_machine_virtuelle">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.1</span>Améliorer les performances de la machine virtuelle</div>
			</a>
			
			<ul id="toc-Améliorer_les_performances_de_la_machine_virtuelle-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Démarrer_des_machines_virtuelles_QEMU_au_démarrage" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9marrer_des_machines_virtuelles_QEMU_au_d%C3%A9marrage">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2</span>Démarrer des machines virtuelles QEMU au démarrage</div>
			</a>
			
			<ul id="toc-Démarrer_des_machines_virtuelles_QEMU_au_démarrage-sublist" class="vector-toc-list">
				<li id="toc-Avec_libvirt" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Avec_libvirt">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2.1</span>Avec libvirt</div>
			</a>
			
			<ul id="toc-Avec_libvirt-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Avec_le_service_systemd" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Avec_le_service_systemd">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.2.2</span>Avec le service systemd</div>
			</a>
			
			<ul id="toc-Avec_le_service_systemd-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Intégration_de_la_souris" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Int%C3%A9gration_de_la_souris">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.3</span>Intégration de la souris</div>
			</a>
			
			<ul id="toc-Intégration_de_la_souris-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pass-through_host_USB_device" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pass-through_host_USB_device">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.4</span>Pass-through host USB device</div>
			</a>
			
			<ul id="toc-Pass-through_host_USB_device-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Redirection_USB_avec_SPICE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Redirection_USB_avec_SPICE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.5</span>Redirection USB avec SPICE</div>
			</a>
			
			<ul id="toc-Redirection_USB_avec_SPICE-sublist" class="vector-toc-list">
				<li id="toc-Redirection_USB_automatique_avec_udev" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Redirection_USB_automatique_avec_udev">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.5.1</span>Redirection USB automatique avec udev</div>
			</a>
			
			<ul id="toc-Redirection_USB_automatique_avec_udev-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Activation_de_KSM" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Activation_de_KSM">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.6</span>Activation de KSM</div>
			</a>
			
			<ul id="toc-Activation_de_KSM-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Prise_en_charge_de_plusieurs_moniteurs" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Prise_en_charge_de_plusieurs_moniteurs">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.7</span>Prise en charge de plusieurs moniteurs</div>
			</a>
			
			<ul id="toc-Prise_en_charge_de_plusieurs_moniteurs-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Résolution_d'affichage_personnalisée" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#R%C3%A9solution_d'affichage_personnalis%C3%A9e">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.8</span>Résolution d'affichage personnalisée</div>
			</a>
			
			<ul id="toc-Résolution_d'affichage_personnalisée-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Copier_et_coller" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Copier_et_coller">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.9</span>Copier et coller</div>
			</a>
			
			<ul id="toc-Copier_et_coller-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Notes_spécifiques_à_Windows" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Notes_sp%C3%A9cifiques_%C3%A0_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10</span>Notes spécifiques à Windows</div>
			</a>
			
			<ul id="toc-Notes_spécifiques_à_Windows-sublist" class="vector-toc-list">
				<li id="toc-Démarrage_rapide" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#D%C3%A9marrage_rapide">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10.1</span>Démarrage rapide</div>
			</a>
			
			<ul id="toc-Démarrage_rapide-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Protocole_de_bureau_à_distance" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Protocole_de_bureau_%C3%A0_distance">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.10.2</span>Protocole de bureau à distance</div>
			</a>
			
			<ul id="toc-Protocole_de_bureau_à_distance-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Cloner_un_système_Linux_installé_sur_un_équipement_physique" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Cloner_un_syst%C3%A8me_Linux_install%C3%A9_sur_un_%C3%A9quipement_physique">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.11</span>Cloner un système Linux installé sur un équipement physique</div>
			</a>
			
			<ul id="toc-Cloner_un_système_Linux_installé_sur_un_équipement_physique-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Chrooter_dans_l'environnement_arm/arm64_à_partir_de_x86_64" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Chrooter_dans_l'environnement_arm/arm64_%C3%A0_partir_de_x86_64">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.12</span>Chrooter dans l'environnement arm/arm64 à partir de x86_64</div>
			</a>
			
			<ul id="toc-Chrooter_dans_l'environnement_arm/arm64_à_partir_de_x86_64-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Ne_pas_saisir_l'entrée_de_la_souris" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Ne_pas_saisir_l'entr%C3%A9e_de_la_souris">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">14.13</span>Ne pas saisir l'entrée de la souris</div>
			</a>
			
			<ul id="toc-Ne_pas_saisir_l'entrée_de_la_souris-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Dépannage" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#D%C3%A9pannage">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">15</span>Dépannage</div>
		</a>
		
			<button aria-controls="toc-Dépannage-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon vector-icon--x-small mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Dépannage subsection</span>
			</button>
		
		<ul id="toc-Dépannage-sublist" class="vector-toc-list">
			<li id="toc-Le_curseur_de_la_souris_est_instable_ou_erratique" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Le_curseur_de_la_souris_est_instable_ou_erratique">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.1</span>Le curseur de la souris est instable ou erratique</div>
			</a>
			
			<ul id="toc-Le_curseur_de_la_souris_est_instable_ou_erratique-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Pas_de_curseur_visible" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Pas_de_curseur_visible">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.2</span>Pas de curseur visible</div>
			</a>
			
			<ul id="toc-Pas_de_curseur_visible-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Deux_curseurs_de_souris_différents_sont_visibles" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Deux_curseurs_de_souris_diff%C3%A9rents_sont_visibles">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.3</span>Deux curseurs de souris différents sont visibles</div>
			</a>
			
			<ul id="toc-Deux_curseurs_de_souris_différents_sont_visibles-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Problèmes_de_clavier_lors_de_l'utilisation_de_VNC" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Probl%C3%A8mes_de_clavier_lors_de_l'utilisation_de_VNC">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.4</span>Problèmes de clavier lors de l'utilisation de VNC</div>
			</a>
			
			<ul id="toc-Problèmes_de_clavier_lors_de_l'utilisation_de_VNC-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Le_clavier_semble_cassé_ou_les_touches_fléchées_ne_fonctionnent_pas" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Le_clavier_semble_cass%C3%A9_ou_les_touches_fl%C3%A9ch%C3%A9es_ne_fonctionnent_pas">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.5</span>Le clavier semble cassé ou les touches fléchées ne fonctionnent pas</div>
			</a>
			
			<ul id="toc-Le_clavier_semble_cassé_ou_les_touches_fléchées_ne_fonctionnent_pas-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Impossible_de_lire_le_fichier_keymap" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Impossible_de_lire_le_fichier_keymap">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.6</span>Impossible de lire le fichier keymap</div>
			</a>
			
			<ul id="toc-Impossible_de_lire_le_fichier_keymap-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-L'affichage_invité_s'étire_lors_du_redimensionnement_de_la_fenêtre" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#L'affichage_invit%C3%A9_s'%C3%A9tire_lors_du_redimensionnement_de_la_fen%C3%AAtre">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.7</span>L'affichage invité s'étire lors du redimensionnement de la fenêtre</div>
			</a>
			
			<ul id="toc-L'affichage_invité_s'étire_lors_du_redimensionnement_de_la_fenêtre-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-ioctl(KVM_CREATE_VM)_failed_:_16_Device_or_resource_busy" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#ioctl(KVM_CREATE_VM)_failed_:_16_Device_or_resource_busy">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.8</span>ioctl(KVM_CREATE_VM) failed : 16 Device or resource busy</div>
			</a>
			
			<ul id="toc-ioctl(KVM_CREATE_VM)_failed_:_16_Device_or_resource_busy-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-message_d'erreur_libgfapi" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#message_d'erreur_libgfapi">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.9</span>message d'erreur libgfapi</div>
			</a>
			
			<ul id="toc-message_d'erreur_libgfapi-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Panique_du_noyau_sur_les_environnements_LIVE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Panique_du_noyau_sur_les_environnements_LIVE">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.10</span>Panique du noyau sur les environnements LIVE</div>
			</a>
			
			<ul id="toc-Panique_du_noyau_sur_les_environnements_LIVE-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-L'invité_Windows_7_souffre_d'un_son_de_mauvaise_qualité" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#L'invit%C3%A9_Windows_7_souffre_d'un_son_de_mauvaise_qualit%C3%A9">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.11</span>L'invité Windows 7 souffre d'un son de mauvaise qualité</div>
			</a>
			
			<ul id="toc-L'invité_Windows_7_souffre_d'un_son_de_mauvaise_qualité-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Impossible_d'accéder_au_module_du_noyau_KVM_:_Permission_refusée" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Impossible_d'acc%C3%A9der_au_module_du_noyau_KVM_:_Permission_refus%C3%A9e">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.12</span>Impossible d'accéder au module du noyau KVM : Permission refusée</div>
			</a>
			
			<ul id="toc-Impossible_d'accéder_au_module_du_noyau_KVM_:_Permission_refusée-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-&quot;System_Thread_Exception_Not_Handled&quot;_lors_du_démarrage_d'une_VM_Windows" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#&quot;System_Thread_Exception_Not_Handled&quot;_lors_du_d%C3%A9marrage_d'une_VM_Windows">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.13</span>"System Thread Exception Not Handled" lors du démarrage d'une VM Windows</div>
			</a>
			
			<ul id="toc-&quot;System_Thread_Exception_Not_Handled&quot;_lors_du_démarrage_d'une_VM_Windows-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Certains_jeux/applications_Windows_se_plantent/provoquent_un_écran_bleu" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Certains_jeux/applications_Windows_se_plantent/provoquent_un_%C3%A9cran_bleu">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.14</span>Certains jeux/applications Windows se plantent/provoquent un écran bleu</div>
			</a>
			
			<ul id="toc-Certains_jeux/applications_Windows_se_plantent/provoquent_un_écran_bleu-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Les_applications_dans_la_VM_subissent_des_retards_importants_ou_prennent_beaucoup_de_temps_à_démarrer" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Les_applications_dans_la_VM_subissent_des_retards_importants_ou_prennent_beaucoup_de_temps_%C3%A0_d%C3%A9marrer">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.15</span>Les applications dans la VM subissent des retards importants ou prennent beaucoup de temps à démarrer</div>
			</a>
			
			<ul id="toc-Les_applications_dans_la_VM_subissent_des_retards_importants_ou_prennent_beaucoup_de_temps_à_démarrer-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Latence_élevée_des_interruptions_et_microstuttering" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Latence_%C3%A9lev%C3%A9e_des_interruptions_et_microstuttering">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.16</span>Latence élevée des interruptions et microstuttering</div>
			</a>
			
			<ul id="toc-Latence_élevée_des_interruptions_et_microstuttering-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-La_vidéo_QXL_cause_une_basse_résolution" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#La_vid%C3%A9o_QXL_cause_une_basse_r%C3%A9solution">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.17</span>La vidéo QXL cause une basse résolution</div>
			</a>
			
			<ul id="toc-La_vidéo_QXL_cause_une_basse_résolution-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Hang_pendant_VM_initramfs" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Hang_pendant_VM_initramfs">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.18</span>Hang pendant VM initramfs</div>
			</a>
			
			<ul id="toc-Hang_pendant_VM_initramfs-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-La_VM_ne_démarre_pas_lorsqu'on_utilise_un_OVMF_activé_par_Secure_Boot" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#La_VM_ne_d%C3%A9marre_pas_lorsqu'on_utilise_un_OVMF_activ%C3%A9_par_Secure_Boot">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.19</span>La VM ne démarre pas lorsqu'on utilise un OVMF activé par Secure Boot</div>
			</a>
			
			<ul id="toc-La_VM_ne_démarre_pas_lorsqu'on_utilise_un_OVMF_activé_par_Secure_Boot-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Les_interruptions_du_CPU_invité_ne_se_déclenchent_pas" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Les_interruptions_du_CPU_invit%C3%A9_ne_se_d%C3%A9clenchent_pas">
				<div class="vector-toc-text">
				<span class="vector-toc-numb">15.20</span>Les interruptions du CPU invité ne se déclenchent pas</div>
			</a>
			
			<ul id="toc-Les_interruptions_du_CPU_invité_ne_se_déclenchent_pas-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Voir_aussi" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Voir_aussi">
			<div class="vector-toc-text">
			<span class="vector-toc-numb">16</span>Voir aussi</div>
		</a>
		
		<ul id="toc-Voir_aussi-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body" role="main" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar">
					<nav role="navigation" aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">QEMU (Français)</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang">
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 5 languages">
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-5" aria-hidden="true"><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">5 languages</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-de mw-list-item"><a href="https://wiki.archlinux.de/title/QEMU" title="QEMU – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li>
<li class="interlanguage-link interwiki-en mw-list-item"><a href="../en/QEMU.html" title="QEMU – English" lang="en" hreflang="en" class="interlanguage-link-target"><span>English</span></a></li>
<li class="interlanguage-link interwiki-es mw-list-item"><a href="../es/QEMU.html" title="QEMU – español" lang="es" hreflang="es" class="interlanguage-link-target"><span>Español</span></a></li>
<li class="interlanguage-link interwiki-ja mw-list-item"><a href="https://wiki.archlinux.jp/index.php/QEMU" title="QEMU – 日本語" lang="ja" hreflang="ja" class="interlanguage-link-target"><span>日本語</span></a></li>
<li class="interlanguage-link interwiki-zh-hans mw-list-item"><a href="https://wiki.archlinuxcn.org/wiki/QEMU" title="QEMU – 中文（简体）" lang="zh-Hans" hreflang="zh-Hans" class="interlanguage-link-target"><span>中文（简体）</span></a></li>
			</ul>
			
		</div>

	</div>
</div>
</header>
				<div class="vector-column-end">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-client-prefs-landmark" aria-label="Appearance">
						</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content">
<div class="mw-content-ltr mw-parser-output" lang="fr" dir="ltr">
<div class="archwiki-template-box archwiki-template-box-note">
<strong>État de la traduction:</strong> Cet article est la version francophone de <a href="../en/QEMU.html" title="QEMU">QEMU</a>. Date de la dernière traduction: 2022-03-10. Vous pouvez aider à synchroniser la traduction s'il y a eu des <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=QEMU&amp;diff=0&amp;oldid=722359">changements</a> dans la version anglaise.</div>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><a href="../File:Tango-preferences-desktop-locale.svg" class="mw-file-description"><img src="../File:Tango-preferences-desktop-locale.svg" decoding="async" width="48" height="48" class="mw-file-element"></a></span><b>Cet article ou section a besoin d'être <a href="../en/ArchWiki:Contributing.html#Translating" title="ArchWiki:Contributing">traduit(e)</a>.</b></p>
<div>
<b>Notes:</b> J'ai procédé à la traduction de cette page, mais je ne suis pas familier avec le sujet traité : n'hésitez pas à consulter <a href="../en/QEMU.html" title="QEMU">la page anglaise</a> en cas de doute sur le sens d'une phrase et à rectifier mes erreurs lorsque vous les rencontrerez. (Discuss in <a rel="nofollow" class="external text" href="../fr/Talk:QEMU.html">Talk:QEMU (Français)#</a>)</div>
</div>
<div class="archwiki-template-meta-related-articles">
<p>Related articles</p>
<ul>
<li><a href="../en/Category:Hypervisors.html" title="Category:Hypervisors">Category:Hypervisors</a></li>
<li><a href="../en/Libvirt.html" title="Libvirt">Libvirt</a></li>
<li><a href="../en/QEMU/Guest_graphics_acceleration.html" title="QEMU/Guest graphics acceleration">QEMU/Guest graphics acceleration</a></li>
<li><a href="../en/PCI_passthrough_via_OVMF.html" title="PCI passthrough via OVMF">PCI passthrough via OVMF</a></li>
</ul>
</div>
<p>Selon la page <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Main_Page">QEMU about page</a>, "QEMU est un émulateur et un virtualiseur de machine générique et open source".
</p>
<p>Lorsqu'il est utilisé comme émulateur de machine, QEMU peut exécuter des systèmes d'exploitation et des programmes conçus pour une machine (par exemple, une carte ARM) sur une autre machine (par exemple, votre PC x86). En utilisant une traduction dynamique, il obtient de très bonnes performances.
</p>
<p>QEMU peut utiliser d'autres hyperviseurs comme <a href="../en/Xen.html" title="Xen">Xen</a> ou <a href="../en/KVM.html" title="KVM">KVM</a> pour utiliser des extensions de CPU (<a href="https://en.wikipedia.org/wiki/Hardware-assisted_virtualization" class="extiw" title="wikipedia:Hardware-assisted virtualization">HVM</a>) pour la virtualisation. Lorsqu'il est utilisé comme virtualiseur, QEMU atteint des performances proches de celles d'un système natif en exécutant le code invité directement sur le CPU hôte.
</p>
<meta property="mw:PageProp/toc">
<h2><span class="mw-headline" id="Installation">Installation</span></h2>
<p><a href="../fr/Help:Reading.html#Installation_de_paquets" class="mw-redirect" title="Installez">Installez</a> le paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-desktop">qemu-desktop</a></span> (ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-base">qemu-base</a></span> pour la version sans interface graphique) et les paquets optionnels suivants pour vos besoins :
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span> - support d'architectures supplémentaires</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span> - Prise en charge des blocs <a href="../en/Glusterfs.html" title="Glusterfs">Glusterfs</a>.</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> - Prise en charge des blocs <a href="../en/ISCSI.html" title="ISCSI">iSCSI</a>.</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=samba">samba</a></span> - Prise en charge du serveur <a href="../en/Samba.html" class="mw-redirect" title="Samba (Français)">SMB/CIFS</a>.</li>
</ul>
<p>Alternativement, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> existe en tant que variante usermode et statique.
</p>
<h3><span class="mw-headline" id="Variantes_de_QEMU">Variantes de QEMU</span></h3>
<p>QEMU est proposé en plusieurs variantes adaptées à différents cas d'utilisation.
</p>
<p>En première classification, QEMU est proposé en modes d'émulation «full-system» et «usermode» :
</p>
<dl>
<dt>Émulation «full-system»</dt>
<dd>Dans ce mode, QEMU émule un système complet, comprenant un ou plusieurs processeurs et divers périphériques. Il est plus précis mais plus lent, et ne nécessite pas que le système d'exploitation émulé soit Linux.</dd>
<dd>Les commandes QEMU pour l'émulation d'un système complet sont nommées <code>qemu-system-<i>target_architecture</i></code>, par exemple <code>qemu-system-x86_64</code> pour l'émulation de processeurs intel 64 bits, <code>qemu-system-i386</code> pour les processeurs intel 32 bits, <code>qemu-system-arm</code> pour ARM (32 bits), <code>qemu-system-aarch64</code> pour ARM64, etc.</dd>
<dd>Si l'architecture cible correspond au CPU hôte, ce mode peut encore bénéficier d'une accélération significative en utilisant un hyperviseur comme <a href="#Activation_de_KVM">#Activation de KVM</a>|KVM]] ou Xen.</dd>
<dt><a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/user/main.html">Émulation en mode utilisateur</a></dt>
<dd>Dans ce mode, QEMU est capable d'invoquer un exécutable Linux compilé pour une architecture (potentiellement) différente en exploitant les ressources du système hôte. Il peut y avoir des problèmes de compatibilité, par exemple certaines fonctionnalités peuvent ne pas être implémentées, les exécutables liés dynamiquement ne fonctionneront pas (consultez <a href="#Chrooter_dans_l'environnement_arm/arm64_%C3%A0_partir_de_x86_64">#Chrooter dans l'environnement arm/arm64 à partir de x86_64</a> pour résoudre ce problème) et seul Linux est pris en charge (bien que <a rel="nofollow" class="external text" href="https://wiki.winehq.org/Emulation">Wine peut être utilisé</a> pour exécuter des exécutables Windows).</dd>
<dd>Les commandes QEMU pour l'émulation du mode utilisateur sont nommées <code>qemu-<i>target_architecture</i></code>, par exemple <code>qemu-x86_64</code> pour émuler les CPU intel 64 bits.</dd>
</dl>
<p>QEMU est proposé dans des variantes liées dynamiquement et statiquement :
</p>
<dl>
<dt>Liée dynamiquement (par défaut)</dt>
<dd>les commandes <code>qemu-*</code> dépendent des bibliothèques du système d'exploitation hôte, les exécutables sont donc plus petits.</dd>
<dt>Liée de manière statique</dt>
<dd>Les commandes <code>qemu-*</code> peuvent être copiées sur tout système Linux ayant la même architecture.</dd>
</dl>
<p>Dans le cas d'Arch Linux, l'émulation complète du système est offerte comme :
</p>
<dl>
<dt>Non-headless (par défaut)</dt>
<dd>Cette variante active les fonctionnalités de l'interface graphique qui nécessitent des dépendances supplémentaires (comme SDL ou GTK).</dd>
<dt>Headless</dt>
<dd>Il s'agit d'une variante plus légère qui ne nécessite pas d'interface graphique (elle est adaptée, par exemple, aux serveurs).</dd>
</dl>
<p>Notez que les versions headless et non-headless installent des commandes avec le même nom (par exemple <code>qemu-system-x86_64</code>) et ne peuvent donc pas être installées toutes les deux en même temps.
</p>
<h3>
<span id="D.C3.A9tails_sur_les_paquets_offerts_dans_Arch_Linux"></span><span class="mw-headline" id="Détails_sur_les_paquets_offerts_dans_Arch_Linux">Détails sur les paquets offerts dans Arch Linux</span>
</h3>
<ul>
<li>Le paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-desktop">qemu-desktop</a></span> fournit les émulateurs d'architecture <code>x86_64</code> pour l'émulation du système complet (<code>qemu-system-x86_64</code>). Le paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span> fournit la variante usermode de l'architecture <code>x86_64</code> (<code>qemu-x86_64</code>) et, pour les autres architectures prises en charge, il inclut les variantes full-system et usermode (par exemple, <code>qemu-system-arm</code> et <code>qemu-arm</code>).</li>
<li>Les versions «headless» (sans affichage) de ces paquets (uniquement applicables à l'émulation full-system) sont <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-base">qemu-base</a></span> (<code>x86_64</code> uniquement) et <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span> (le reste des architectures).</li>
<li>L'émulation du système complet peut être étendue avec certains modules QEMU présents dans des paquets séparés : <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> et <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span>.</li>
<li>Le paquet AUR non officiel <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> fournit un mode utilisateur et une variante statique pour toutes les architectures cibles prises en charge par QEMU. Les commandes QEMU installées sont nommées <code>qemu-<i>target_architecture</i>-static</code>, par exemple, <code>qemu-x86_64-static</code> pour les CPU intel 64 bits.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> À l'heure actuelle, Arch ne propose pas de mode système complet et de variante liée statiquement (ni officiellement ni via AUR), car cela n'est généralement pas nécessaire.</div>
<h2><span class="mw-headline" id="Interfaces_graphiques_pour_QEMU">Interfaces graphiques pour QEMU</span></h2>
<p>Contrairement à d'autres programmes de virtualisation tels que <a href="../en/VirtualBox.html" class="mw-redirect" title="VirtualBox (Français)">VirtualBox</a> et <a href="../en/VMware.html" title="VMware">VMware</a>, QEMU ne fournit pas d'interface graphique pour gérer les machines virtuelles (autre que la fenêtre qui apparaît lors de l'exécution d'une machine virtuelle), ni de moyen de créer des machines virtuelles persistantes avec des paramètres enregistrés. Tous les paramètres permettant d'exécuter une machine virtuelle doivent être spécifiés sur la ligne de commande à chaque lancement, à moins que vous n'ayez créé un script personnalisé pour démarrer votre ou vos machines virtuelles.
</p>
<p><a href="../en/Libvirt.html" title="Libvirt">Libvirt</a> fournit un moyen pratique de gérer les machines virtuelles QEMU. Consultez <a href="../en/Libvirt.html#Client" title="Libvirt">liste des clients libvirt</a> pour connaître les interfaces disponibles.
</p>
<p>Autres interfaces graphiques pour QEMU :
</p>
<ul><li>
<b>AQEMU</b> — QEMU GUI écrite en Qt5.</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://github.com/tobimensch/aqemu">https://github.com/tobimensch/aqemu</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/aqemu/">aqemu</a></span><sup><small>AUR</small></sup>
</dd></dl>
<h2>
<span id="Cr.C3.A9er_un_nouveau_syst.C3.A8me_virtualis.C3.A9"></span><span class="mw-headline" id="Créer_un_nouveau_système_virtualisé">Créer un nouveau système virtualisé</span>
</h2>
<h3>
<span id="Cr.C3.A9ation_d.27une_image_de_disque_dur"></span><span class="mw-headline" id="Création_d'une_image_de_disque_dur">Création d'une image de disque dur</span>
</h3>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Inaccurate.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>The factual accuracy of this article or section is disputed.</b></p>
<div>
<b>Reason:</b> Si je comprends bien la page de manuel, le format brut n'alloue la taille complète que si le système de fichiers ne prend pas en charge les "trous" ou si on lui demande explicitement de préallouer. Consultez la page man qemu-img dans la section Notes. (Discuss in <a href="../en/Talk:QEMU.html" title="Talk:QEMU">Talk:QEMU</a>)</div>
</div> 
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Consultez <a href="https://en.wikibooks.org/wiki/QEMU/Images" class="extiw" title="wikibooks:QEMU/Images">Wikibooks:QEMU/Images</a> pour plus d'informations sur les images QEMU.</div>
<p>Pour exécuter QEMU, vous aurez besoin d'une image de disque dur, à moins que vous ne démarriez un système «live» à partir d'un CD-ROM ou du réseau (et non pour installer un système d'exploitation sur une image de disque dur). Une image de disque dur est un fichier qui stocke le contenu du disque dur émulé.
</p>
<p>Une image de disque dur peut être <i>brute</i>, c'est-à-dire qu'elle est littéralement identique, octet par octet, à ce que consulte l'invité, et elle utilisera toujours la pleine capacité du disque dur de l'invité sur l'hôte. Cette méthode fournit le moins de surcharge d'E/S, mais peut gaspiller beaucoup d'espace, car l'espace non utilisé sur l'invité ne peut pas être utilisé sur l'hôte.
</p>
<p>Alternativement, l'image du disque dur peut être dans un format tel que <i>qcow2</i> qui n'alloue de l'espace au fichier image que lorsque le système d'exploitation invité écrit réellement dans ces secteurs sur son disque dur virtuel. L'image apparaît comme étant de taille complète pour le système d'exploitation invité, même si elle n'occupe qu'une très petite quantité d'espace sur le système hôte. Ce format d'image prend également en charge la fonctionnalité d'instantané de QEMU (consultez <a href="#Cr%C3%A9ation_et_gestion_des_snapshots_via_la_console_du_moniteur">#Création et gestion des snapshots via la console du moniteur</a> pour plus de détails). Cependant, l'utilisation de ce format au lieu de <i>raw</i> affectera probablement les performances.
</p>
<p>QEMU fournit la commande <code>qemu-img</code> pour créer des images de disque dur. Par exemple, pour créer une image de 4 Gio au format <i>raw</i> :
</p>
<pre>$ qemu-img create -f raw <i>image_file</i> 4G
</pre>
<p>Vous pouvez utiliser <code>-f qcow2</code> pour créer un disque <i>qcow2</i> à la place.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Vous pouvez aussi simplement créer une image <i>brute</i> en créant un fichier de la taille requise à l'aide de <code>dd</code> ou <code>fallocate</code>.</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Si vous stockez les images du disque dur sur un système de fichiers <a href="../en/Btrfs.html" title="Btrfs">Btrfs</a>, vous devriez envisager de désactiver <a href="../en/Btrfs.html#Copy-on-Write_(CoW)" title="Btrfs">Copy-on-Write</a> pour le répertoire avant de créer des images.</div>
<h4>
<span id="Images_de_stockage_superpos.C3.A9es"></span><span class="mw-headline" id="Images_de_stockage_superposées">Images de stockage superposées</span>
</h4>
<p>Vous pouvez créer une image de stockage une seule fois (l'image "backing") et faire en sorte que QEMU conserve les mutations de cette image dans une image de recouvrement. Cela vous permet de revenir à un état antérieur de cette image de stockage. Vous pouvez revenir en arrière en créant une nouvelle image de recouvrement au moment où vous souhaitez revenir en arrière, basée sur l'image de sauvegarde originale.
</p>
<p>Pour créer une image superposée, lancez une commande comme :
</p>
<pre>$ qemu-img create -o backing_file=<i>img1.raw</i>,backing_fmt=<i>raw</i> -f <i>qcow2</i> <i>img1.cow</i>
</pre>
<p>Après cela, vous pouvez exécuter votre VM QEMU comme d'habitude (consultez <a href="#Ex%C3%A9cution_du_syst%C3%A8me_virtualis%C3%A9">#Exécution du système virtualisé</a>) :
</p>
<pre>$ qemu-system-x86_64 <i>img1.cow</i>
</pre>
<p>L'image de sauvegarde sera alors laissée intacte et les mutations vers ce stockage seront enregistrées dans le fichier de l'image de recouvrement.
</p>
<p>Lorsque le chemin vers l'image de sauvegarde change, une réparation est nécessaire.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Le chemin absolu du système de fichiers de l'image de sauvegarde est enregistré dans le fichier (binaire) de l'image superposée. La modification du chemin d'accès à l'image de sauvegarde nécessite un certain effort.</div>
<p>Assurez-vous que le chemin de l'image de sauvegarde d'origine mène toujours à cette image. Si nécessaire, créez un lien symbolique entre le chemin d'origine et le nouveau chemin. Ensuite, lancez une commande comme :
</p>
<pre>$ qemu-img rebase -b <i>/new/img1.raw</i> <i>/new/img1.cow</i>
</pre>
<p>Si vous le souhaitez, vous pouvez également effectuer un rebasement "non sécurisé" où l'ancien chemin vers l'image de sauvegarde n'est pas vérifié :
</p>
<pre>$ qemu-img rebase -u -b <i>/nouvelle/img1.raw</i> <i>/nouvelle/img1.cow</i>
</pre>
<h4>
<span id="Redimensionnement_d.27une_image"></span><span class="mw-headline" id="Redimensionnement_d'une_image">Redimensionnement d'une image</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Le redimensionnement d'une image contenant un système de fichiers de démarrage NTFS peut rendre le système d'exploitation qui y est installé non amorçable. Il est recommandé de créer d'abord une sauvegarde.</div>
<p>L'exécutable <code>qemu-img</code> possède l'option <code>resize</code>, qui permet de redimensionner facilement une image de disque dur. Elle fonctionne à la fois pour <i>raw</i> et <i>qcow2</i>. Par exemple, pour augmenter l'espace de l'image de 10 Gio, exécutez :
</p>
<pre>$ qemu-img resize <i>disk_image</i> +10G
</pre>
<p>Après avoir agrandi l'image disque, vous devez utiliser le système de fichiers et les outils de partitionnement dans la machine virtuelle pour commencer à utiliser le nouvel espace. Lors du rétrécissement d'une image disque, vous devez '<i>d'abord réduire les tailles des systèmes de fichiers et des partitions alloués</i> à l'aide des outils de système de fichiers et de partitionnement dans la machine virtuelle, puis rétrécir l'image disque en conséquence, sinon le rétrécissement de l'image disque entraînera une perte de données ! Pour un Windows virtualisé, ouvrez le panneau de contrôle "créer et formater les partitions du disque dur".
</p>
<h4><span class="mw-headline" id="Convertir_une_image">Convertir une image</span></h4>
<p>Vous pouvez convertir une image dans d'autres formats en utilisant <code>qemu-img convert</code>. Cet exemple montre comment convertir une image <i>raw</i> en <i>qcow2</i> :
</p>
<pre>$ qemu-img convert -f raw -O qcow2 <i>input</i>.img <i>output</i>.qcow2
</pre>
<p>Ceci ne supprimera pas le fichier d'entrée original.
</p>
<h3>
<span id="Pr.C3.A9paration_du_support_d.27installation"></span><span class="mw-headline" id="Préparation_du_support_d'installation">Préparation du support d'installation</span>
</h3>
<p>Pour installer un système d'exploitation dans votre image disque, vous avez besoin du support d'installation (par exemple, un disque optique, une clé USB ou une image ISO) pour le système d'exploitation. Le support d'installation ne doit pas être monté car QEMU accède directement au support.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Si vous utilisez un disque optique, c'est une bonne idée de commencer par vider le support dans un fichier car cela améliore les performances et ne nécessite pas d'accès direct aux périphériques (c'est-à-dire que vous pouvez exécuter QEMU en tant qu'utilisateur normal sans avoir à modifier les autorisations d'accès sur le fichier de périphérique du support). Par exemple, si le nœud de périphérique CD-ROM est nommé <code>/dev/cdrom</code>, vous pouvez le vider dans un fichier avec la commande : <pre>$ dd if=/dev/cdrom of=<i>cd_image.iso</i> bs=4k</pre>
</div>
<h3>
<span id="Installation_du_syst.C3.A8me_d.27exploitation"></span><span class="mw-headline" id="Installation_du_système_d'exploitation">Installation du système d'exploitation</span>
</h3>
<p>C'est la première fois que vous devrez démarrer l'émulateur. Pour installer le système d'exploitation sur l'image disque, vous devez attacher l'image disque et le média d'installation à la machine virtuelle, et la faire démarrer à partir du média d'installation.
</p>
<p>Par exemple, sur les invités i386, pour installer à partir d'un fichier ISO amorçable comme CD-ROM et une image disque brute :
</p>
<pre>$ qemu-system-x86_64 -cdrom <i>iso_image</i> -boot order=d -drive file=<i>disk_image</i>,format=raw
</pre>
<p>Consultez <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> pour plus d'informations sur le chargement d'autres types de supports (tels que des disquettes, des images de disques ou des lecteurs physiques) et <a href="#Ex%C3%A9cution_du_syst%C3%A8me_virtualis%C3%A9">#Exécution du système virtualisé</a> pour d'autres options utiles.
</p>
<p>Une fois l'installation du système d'exploitation terminée, l'image QEMU peut être démarrée directement (consultez <a href="#Ex%C3%A9cution_du_syst%C3%A8me_virtualis%C3%A9">#Exécution du système virtualisé</a>).
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Par défaut, seul 128 Mio de mémoire est attribuée à la machine. La quantité de mémoire peut être ajustée avec le paramètre <code>-m</code>, par exemple <code>-m 512M</code> ou <code>-m 2G</code>.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> 
<ul>
<li>Au lieu de spécifier <code>-boot order=x</code>, certains utilisateurs peuvent se sentir plus à l'aise en utilisant un menu de démarrage : <code>-boot menu=on</code>, au moins pendant la configuration et l'expérimentation.</li>
<li>Lorsque QEMU est exécuté en mode sans affichage, il démarre un serveur VNC local sur le port 5900 par défaut. Vous pouvez utiliser <a href="../en/TigerVNC.html" title="TigerVNC">TigerVNC</a> pour vous connecter à l'OS invité : <code>vncviewer :5900</code>
</li>
<li>Si vous devez remplacer des disquettes ou des CD dans le cadre du processus d'installation, vous pouvez utiliser le moniteur de machine QEMU (appuyez sur <code>Ctrl+Alt+2</code> dans la fenêtre de la machine virtuelle) pour supprimer et attacher des périphériques de stockage à une machine virtuelle. Tapez <code>info block</code> pour consulter les périphériques de bloc, et utilisez la commande <code>change</code> pour échanger un périphérique. Appuyez sur <code>Ctrl+Alt+1</code> pour revenir à la machine virtuelle.</li>
</ul>
</div>
<h2>
<span id="Ex.C3.A9cution_du_syst.C3.A8me_virtualis.C3.A9"></span><span class="mw-headline" id="Exécution_du_système_virtualisé">Exécution du système virtualisé</span>
</h2>
<p>Les binaires <code>qemu-system-*</code> (par exemple <code>qemu-system-i386</code> ou <code>qemu-system-x86_64</code>, selon l'architecture de l'invité) sont utilisés pour exécuter l'invité virtualisé. L'utilisation est la suivante :
</p>
<pre>$ qemu-system-x86_64 <i>options</i> <i>disk_image</i>
</pre>
<p>Les options sont les mêmes pour tous les binaires <code>qemu-system-*</code>, consultez <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> pour la documentation de toutes les options.
</p>
<p>Par défaut, QEMU affichera la sortie vidéo de la machine virtuelle dans une fenêtre. Une chose à garder à l'esprit : lorsque vous cliquez dans la fenêtre de QEMU, le pointeur de la souris est saisi. Pour le relâcher, appuyez sur <code>Ctrl+Alt+g</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> QEMU ne doit jamais être lancé en tant que root. Si vous devez le lancer dans un script en tant que root, vous devez utiliser l'option <code>-runas</code> pour que QEMU abandonne les privilèges de root.</div>
<h3><span class="mw-headline" id="Activation_de_KVM">Activation de KVM</span></h3>
<p>La virtualisation complète KVM (<i>Kernel-based Virtual Machine</i>) doit être prise en charge par votre noyau Linux et votre matériel, et les <a href="../fr/Kernel_module.html" title="Kernel module (Français)">modules du noyau</a> nécessaires doivent être chargés. Consultez <a href="../en/KVM.html" title="KVM">KVM</a> pour plus d'informations.
</p>
<p>Pour démarrer QEMU en mode KVM, ajoutez <code>-enable-kvm</code> aux options de démarrage supplémentaires. Pour vérifier si KVM est activé pour une VM en cours d'exécution, entrez dans le <a href="#Moniteur_de_QEMU">#Moniteur de QEMU</a> et tapez <code>info kvm</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>L'argument <code>accel=kvm</code> de l'option <code>-machine</code> est équivalent à l'option <code>-enable-kvm</code> ou <code>-accel kvm</code>}.</li>
<li>Le modèle de CPU <code>host</code> nécessite KVM</li>
<li>Si vous démarrez votre VM avec un outil GUI et que les performances sont très mauvaises, vous devez vérifier la prise en charge KVM, car QEMU peut se rabattre sur l'émulation logicielle.</li>
<li>KVM doit être activé afin de démarrer Windows 7 et Windows 8 correctement sans <i>écran bleu</i>.</li>
</ul>
</div>
<h3>
<span id="Activation_du_support_IOMMU_.28Intel_VT-d.2FAMD-Vi.29"></span><span class="mw-headline" id="Activation_du_support_IOMMU_(Intel_VT-d/AMD-Vi)">Activation du support IOMMU (Intel VT-d/AMD-Vi)</span>
</h3>
<p>Activez d'abord IOMMU, consultez <a href="../en/PCI_passthrough_via_OVMF.html#Setting_up_IOMMU" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Setting up IOMMU</a>.
</p>
<p>Ajoutez <code>-device intel-iommu</code> pour créer le périphérique IOMMU :
</p>
<pre>$ qemu-system-x86_64 <b>-enable-kvm -machine q35 -device intel-iommu</b> -cpu host ...
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
Sur les systèmes basés sur un CPU Intel, la création d'un périphérique IOMMU dans un invité QEMU avec <code>-device intel-iommu</code> désactivera le passage PCI avec une erreur du type : <pre>Device at bus pcie.0 addr 09.0 requires iommu notifier which is currently not supported by intel-iommu emulation</pre> Bien que l'ajout du paramètre du noyau <code>intel_iommu=on</code> soit toujours nécessaire pour le remappage des E/S (par exemple, <a href="../en/PCI_passthrough_via_OVMF.html#Isolating_the_GPU" title="PCI passthrough via OVMF">PCI passthrough with vfio-pci</a>), <code>-device intel-iommu</code> ne doit pas être défini si le PCI passthrough est requis.
</div>
<h2>
<span id="Partage_des_donn.C3.A9es_entre_l.27h.C3.B4te_et_l.27invit.C3.A9"></span><span class="mw-headline" id="Partage_des_données_entre_l'hôte_et_l'invité">Partage des données entre l'hôte et l'invité</span>
</h2>
<h3>
<span id="R.C3.A9seau"></span><span class="mw-headline" id="Réseau">Réseau</span>
</h3>
<p>Les données peuvent être partagées entre le système d'exploitation hôte et le système d'exploitation invité en utilisant n'importe quel protocole réseau capable de transférer des fichiers, comme <a href="../en/NFS.html" class="mw-redirect" title="NFS (Français)">NFS</a>, <a href="../en/Samba.html" class="mw-redirect" title="Samba (Français)">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_block_device" class="extiw" title="wikipedia:Network block device">NBD</a>, HTTP, <a href="../en/Very_Secure_FTP_Daemon.html" title="Very Secure FTP Daemon">FTP</a>, ou <a href="../fr/Secure_Shell.html" title="Secure Shell (Français)">SSH</a>, à condition que vous ayez configuré le réseau de manière appropriée et activé les services adéquats.
</p>
<p>La mise en réseau en mode utilisateur par défaut permet à l'invité d'accéder au système d'exploitation hôte à l'adresse IP 10.0.2.2. Tous les serveurs que vous exécutez sur votre système d'exploitation hôte, comme un serveur SSH ou un serveur SMB, seront accessibles à cette adresse IP. Ainsi, sur les invités, vous pouvez monter des répertoires exportés sur l'hôte via <a href="../en/Samba.html" class="mw-redirect" title="Samba (Français)">SMB</a> ou <a href="../en/NFS.html" class="mw-redirect" title="NFS (Français)">NFS</a>, ou vous pouvez accéder au serveur HTTP de l'hôte, etc.
Il ne sera pas possible pour le système d'exploitation hôte d'accéder aux serveurs fonctionnant sur le système d'exploitation invité, mais cela peut être fait avec d'autres configurations réseau (consultez <a href="#Mise_en_r%C3%A9seau_avec_tap_pour_QEMU">#Mise en réseau avec tap pour QEMU</a>).
</p>
<h3><span class="mw-headline" id="La_redirection_de_port_de_QEMU">La redirection de port de QEMU</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> La redirection de port de QEMU est uniquement IPv4. La redirection de port IPv6 n'est pas implémentée et les derniers correctifs ont été proposés en 2018.<a rel="nofollow" class="external autonumber" href="https://lore.kernel.org/qemu-devel/1540512223-21199-1-git-send-email-max7255@yandex-team.ru/T/#u">[1]</a>
</div>
<p>QEMU peut transférer des ports de l'hôte vers l'invité pour permettre, par exemple, la connexion de l'hôte à un serveur SSH fonctionnant sur l'invité.
</p>
<p>Par exemple, pour lier le port 60022 sur l'hôte avec le port 22 (SSH) sur l'invité, démarrez QEMU avec une commande comme :
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::60022-:22
</pre>
<p>Assurez-vous que le sshd fonctionne sur l'invité et connectez-vous avec :
</p>
<pre>$ ssh <i>guest-user</i>@127.0.0.1 -p 60022
</pre>
<p>Vous pouvez utiliser <a href="../fr/SSHFS.html" title="SSHFS (Français)">SSHFS</a> pour monter le système de fichiers de l'invité sur l'hôte pour un accès partagé en lecture et en écriture.
</p>
<p>Pour transférer plusieurs ports, il suffit de répéter le <code>hostfwd</code> dans l'argument <code>-nic</code>, par exemple pour le port VNC :
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::5900-:5900
</pre>
<h3>
<span id="Le_serveur_SMB_int.C3.A9gr.C3.A9_de_QEMU"></span><span class="mw-headline" id="Le_serveur_SMB_intégré_de_QEMU">Le serveur SMB intégré de QEMU</span>
</h3>
<p>La documentation de QEMU indique qu'il dispose d'un serveur SMB "intégré", mais en fait il ne fait que démarrer <a href="../en/Samba.html" class="mw-redirect" title="Samba (Français)">Samba</a> sur l'hôte avec un fichier <code>smb.conf</code> généré automatiquement et situé dans <code>/tmp/qemu-smb.<i>random_string</i></code> et le rend accessible à l'invité à une adresse IP différente (10.0.2.4 par défaut). Cela ne fonctionne que pour les réseaux d'utilisateurs, et est utile lorsque vous ne voulez pas démarrer le service <a href="../en/Samba.html" class="mw-redirect" title="Samba (Français)">Samba</a> normal sur l'hôte, auquel l'invité peut également accéder si vous avez configuré des partages sur celui-ci.
</p>
<p>Un seul répertoire peut être défini comme partagé avec l'option <code>smb=</code>, mais ajouter d'autres répertoires (même lorsque la machine virtuelle est en cours d'exécution) pourrait être aussi facile que de créer des liens symboliques dans le répertoire partagé si QEMU configurait SMB pour suivre les liens symboliques. Il ne le fait pas, mais la configuration du serveur SMB en cours d'exécution peut être modifiée comme décrit ci-dessous.
</p>
<p><i>Samba</i> doit être installé sur l'hôte. Pour activer cette fonctionnalité, démarrez QEMU avec une commande comme :
</p>
<pre>$ qemu-system-x86_64 -nic user,id=nic0,smb=<i>shared_dir_path'</i> <i>disk_image</i>
</pre>
<p>où <code><i>shared_dir_path</i></code> est un répertoire que vous voulez partager entre l'invité et l'hôte.
</p>
<p>Ensuite, dans l'invité, vous pourrez accéder au répertoire partagé sur l'hôte 10.0.2.4 avec le nom de partage "qemu". Par exemple, dans l'Explorateur Windows, vous accédez à <code>\\\10.0.2.4\qemu</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>Si vous utilisez plusieurs fois les options de partage comme <code>-net user,smb=<i>shared_dir_path1</i> -net user,smb=<i>shared_dir_path2</i></code> ou <code>-net user,smb=<i>shared_dir_path1</i>,smb=<i>shared_dir_path2</i></code> alors il ne partagera que le dernier défini.</li>
<li>Si vous ne pouvez pas accéder au dossier partagé et que le système invité est Windows, vérifiez que le <a rel="nofollow" class="external text" href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">protocole NetBIOS est activé</a><sup title="Last check status: domain name not resolved">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2023-05-06 ⓘ]</sup> et qu'un pare-feu ne bloque pas les <a rel="nofollow" class="external text" href="https://technet.microsoft.com/en-us/library/cc940063.aspx">ports</a> utilisés par le protocole NetBIOS.</li>
<li>Si vous ne pouvez pas accéder au dossier partagé et que le système invité est Windows 10 Entreprise ou Éducation ou Windows Server 2016, <a rel="nofollow" class="external text" href="https://support.microsoft.com/en-us/help/4046019">activer l'accès invité</a>.</li>
<li>Si vous utilisez la <a href="#Mise_en_r%C3%A9seau_avec_tap_pour_QEMU">#Mise en réseau avec tap pour QEMU</a>, utilisez <code>-device virtio-net,netdev=vmnic -netdev user,id=vmnic,smb=<i>shared_dir_path</i></code> pour obtenir SMB.</li>
</ul>
</div>
<p>Une façon de partager plusieurs répertoires et de les ajouter ou de les supprimer pendant l'exécution de la machine virtuelle, consiste à partager un répertoire vide et à créer/supprimer des liens symboliques vers les répertoires du répertoire partagé. Pour que cela fonctionne, la configuration du serveur SMB en cours d'exécution peut être modifiée avec le script suivant, qui permet également l'exécution de fichiers sur l'invité qui ne sont pas définis comme exécutables sur l'hôte :
</p>
<pre>#!/bin/sh
eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print "pid="$1";conf="$6}')
echo "[global]
allow insecure wide links = yes
[qemu]
follow symlinks = yes
wide links = yes
acl allow execute always = yes" &gt;&gt; "$conf"
# in case the change is not detected automatically:
smbcontrol --configfile="$conf" "$pid" reload-config
</pre>
<p>Ceci peut être appliqué au serveur en cours d'exécution démarré par qemu seulement après que l'invité se soit connecté au lecteur réseau pour la première fois. Une alternative à cette méthode est d'ajouter des partages additionnels au fichier de configuration comme ceci :
</p>
<pre>echo "[<i>myshare</i>]
path=<i>another_path</i>
read only=no
guest ok=yes
force user=<i>username</i>" &gt;&gt; $conf
</pre>
<p>Ce partage sera disponible sur l'invité en tant que <code>\10.0.2.4\<i>myshare</i></code>.
</p>
<h3>
<span id="Utiliser_le_passage_de_syst.C3.A8me_de_fichiers_et_VirtFS"></span><span class="mw-headline" id="Utiliser_le_passage_de_système_de_fichiers_et_VirtFS">Utiliser le passage de système de fichiers et VirtFS</span>
</h3>
<p>Consultez la <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Documentation/9psetup">documentation QEMU</a>.
</p>
<h3><span class="mw-headline" id="Partage_de_fichiers_avec_virtiofsd">Partage de fichiers avec virtiofsd</span></h3>
<p>virtiofsd est livré avec le paquet QEMU.  La documentation est disponible <a rel="nofollow" class="external text" href="https://qemu-stsquad.readthedocs.io/en/docs-next/tools/virtiofsd.html">online</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2023-05-06 ⓘ]</sup> ou <code>/usr/share/doc/qemu/tools/virtiofsd.html</code> sur le système de fichiers local avec QEMU installé.
</p>
<p>Ajoutez l'utilisateur qui exécute qemu au groupe 'kvm', car il doit accéder à la socket virtiofsd.  Vous devrez peut-être vous déconnecter pour que le changement prenne effet.
</p>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Inaccurate.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>The factual accuracy of this article or section is disputed.</b></p>
<div>
<b>Reason:</b> L'exécution de services en tant que root n'est pas sécurisée. Aussi, le processus devrait être enveloppé dans un service systemd. (Discuss in <a href="../en/Talk:QEMU.html" title="Talk:QEMU">Talk:QEMU</a>)</div>
</div>
<p>Démarrez virtiofsd en tant que root :
</p>
<pre># /usr/lib/qemu/virtiofsd --socket-path=/var/run/qemu-vm-001.sock -o source=/tmp/vm-001 -o cache=always
</pre>
<p>où
</p>
<ul>
<li>
<code>/var/run/qemu-vm-001.sock</code> est un fichier socket,</li>
<li>
<code>/tmp/vm-001</code> est un répertoire partagé entre l'hôte et le vm invité.</li>
</ul>
<p>Le fichier socket créé a la permission d'accès de root seulement. Donnez au groupe kvm l'accès à ce fichier avec :
</p>
<pre># chgrp kvm qemu-vm-001.sock ; chmod g+rxw qemu-vm-001.sock
</pre>
<p>Ajoutez les options de configuration suivantes lors du démarrage de VM :
</p>
<pre>-objet memory-backend-memfd,id=mem,size=4G,share=on \
-numa node,memdev=mem \
-chardev socket,id=char0,path=/var/run/qemu-vm-001.sock \
-device vhost-user-fs-pci,chardev=char0,tag=myfs
</pre>
<p>où
</p>
<div class="noprint archwiki-template-message">
<p><span class="mw-default-size" typeof="mw:File"><span><img src="../File:Tango-view-fullscreen.svg" decoding="async" width="48" height="48" class="mw-file-element"></span></span><b>This article or section needs expansion.</b></p>
<div>
<b>Reason:</b> Expliquer les options restantes (ou les supprimer si elles ne sont pas nécessaires). (Discuss in <a href="../en/Talk:QEMU.html" title="Talk:QEMU">Talk:QEMU</a>)</div>
</div>
<ul>
<li>
<code>size=4G</code> doit correspondre à la taille spécifiée avec l'option <code>-m 4G</code>,</li>
<li>
<code>/var/run/qemu-vm-001.sock</code> pointe vers le fichier de socket démarré précédemment,</li>
</ul>
<p>Rappelez-vous que l'invité doit être configuré pour permettre le partage.  Pour Windows, il existe <a rel="nofollow" class="external text" href="https://virtio-fs.gitlab.io/howto-windows.html">instructions</a>. Une fois configuré, Windows aura le lecteur Z : mappé automatiquement avec le contenu du répertoire partagé.  
</p>
<p>Votre système invité Windows 10 est correctement configuré s'il possède :
</p>
<ul>
<li>Le service Windows VirtioFSSService,</li>
<li>Le service Windows WinFsp.Launcher,</li>
<li>le pilote de périphérique VirtIO FS sous "Périphériques système" dans le "Gestionnaire de périphériques" de Windows.</li>
</ul>
<p>Si les éléments ci-dessus sont installés et que le lecteur <code>Z:</code> n'est toujours pas listé, essayez de réparer "Virtio-win-guest-tools" dans l'ajout/suppression de programmes de Windows.
</p>
<h3>
<span id="Montage_d.27une_partition_de_l.27invit.C3.A9_sur_l.27h.C3.B4te"></span><span class="mw-headline" id="Montage_d'une_partition_de_l'invité_sur_l'hôte">Montage d'une partition de l'invité sur l'hôte</span>
</h3>
<p>Il peut être utile de monter une image de disque sous le système hôte, cela peut être un moyen de transférer des fichiers dans et hors de l'invité. Cela doit être fait lorsque la machine virtuelle n'est pas en cours d'exécution.
</p>
<p>La procédure pour monter le disque sur l'hôte dépend du type d'image qemu, <i>raw</i> ou <i>qcow2</i>. Nous détaillons par la suite les étapes pour monter un disque dans les deux formats dans <a href="#Montage_d'une_partition_%C3%A0_partir_d'une_image_brute">#Montage d'une partition à partir d'une image brute</a> et <a href="#Montage_d'une_partition_%C3%A0_partir_d'une_image_qcow2">#Montage d'une partition à partir d'une image qcow2</a>. Pour la documentation complète, consultez <a href="https://en.wikibooks.org/wiki/QEMU/Images#Mounting_an_image_on_the_host" class="extiw" title="wikibooks:QEMU/Images">Wikibooks:QEMU/Images#Mounting an image on the host</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Vous devez démonter les partitions avant de relancer la machine virtuelle. Sinon, la corruption des données est très probable.</div>
<h4>
<span id="Montage_d.27une_partition_.C3.A0_partir_d.27une_image_brute"></span><span class="mw-headline" id="Montage_d'une_partition_à_partir_d'une_image_brute">Montage d'une partition à partir d'une image brute</span>
</h4>
<p>Il est possible de monter des partitions qui se trouvent à l'intérieur d'un fichier image disque brut en les configurant comme des périphériques de bouclage.
</p>
<h5>
<span id="En_sp.C3.A9cifiant_manuellement_le_d.C3.A9calage_des_octets"></span><span class="mw-headline" id="En_spécifiant_manuellement_le_décalage_des_octets">En spécifiant manuellement le décalage des octets</span>
</h5>
<p>Une façon de monter une partition d'image disque est de monter l'image disque à un certain décalage en utilisant une commande comme la suivante :
</p>
<pre># mount -o loop,offset=32256 <i>image_de_disque</i> <i>mountpoint</i>
</pre>
<p>L'option <code>offset=32256</code> est en fait passée au programme <code>losetup</code> pour configurer un périphérique de bouclage qui commence à l'octet 32256 du fichier et continue jusqu'à la fin. Ce périphérique de bouclage est ensuite monté. Vous pouvez également utiliser l'option <code>sizelimit</code> pour spécifier la taille exacte de la partition, mais cela n'est généralement pas nécessaire.
</p>
<p>Selon votre image disque, la partition nécessaire peut ne pas commencer à l'offset 32256. Exécutez <code>fdisk -l <i>disk_image</i></code> pour consulter les partitions dans l'image. fdisk donne les décalages de début et de fin en secteurs de 512 octets, donc multipliez par 512 pour obtenir le décalage correct à passer à <code>mount</code>.
</p>
<h5>
<span id="Avec_le_module_loop_autod.C3.A9tectant_les_partitions"></span><span class="mw-headline" id="Avec_le_module_loop_autodétectant_les_partitions">Avec le module loop autodétectant les partitions</span>
</h5>
<p>Le pilote de boucle Linux prend en charge les partitions dans les périphériques de bouclage, mais il est pris en charge par défaut. Pour l'activer, faites ce qui suit :
</p>
<ul>
<li>Débarrassez-vous de tous vos périphériques de bouclage (démontez toutes les images montées, etc.).</li>
<li>
<a href="../en/Kernel_module.html#Manual_module_handling" class="mw-redirect" title="Kernel modules">Déchargez</a> le module noyau <code>loop</code>, et chargez-le avec le paramètre <code>max_part=15</code>. De plus, le nombre maximum de boucles peut être contrôlé avec le paramètre <code>max_loop</code>.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Vous pouvez mettre une entrée dans <code>/etc/modprobe.d</code> pour charger le module loop avec <code>max_part=15</code> à chaque fois, ou vous pouvez mettre <code>loop.max_part=15</code> sur la ligne de commande du noyau, selon que vous avez ou non le module <code>loop.ko</code> intégré dans votre noyau.</div>
<p>Configurez votre image comme un périphérique de bouclage :
</p>
<pre># losetup -f -P <i>disk_image</i>
</pre>
<p>Ensuite, si le périphérique créé était <code>/dev/loop0</code>, des périphériques supplémentaires <code>/dev/loop0pX</code> auront été automatiquement créés, où X est le numéro de la partition. Ces périphériques de bouclage de partition peuvent être montés directement. Par exemple :
</p>
<pre># mount /dev/loop0p1 <i>mountpoint</i>
</pre>
<p>Pour monter l'image disque avec <i>udisksctl</i>, consultez <a href="../en/Udisks.html#Mount_loop_devices" title="Udisks">Udisks#Mount loop devices</a>.
</p>
<h5><span class="mw-headline" id="Avec_kpartx">Avec kpartx</span></h5>
<p><i>kpartx</i> du paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=multipath-tools">multipath-tools</a></span> peut lire une table de partition sur un périphérique et créer un nouveau périphérique pour chaque partition. Par exemple :
</p>
<pre># kpartx -a <i>disk_image</i>
</pre>
<p>Ceci configurera le périphérique de bouclage et créera le(s) périphérique(s) de partition nécessaire(s) dans <code>/dev/mapper/</code>.
</p>
<h4>
<span id="Montage_d.27une_partition_.C3.A0_partir_d.27une_image_qcow2"></span><span class="mw-headline" id="Montage_d'une_partition_à_partir_d'une_image_qcow2">Montage d'une partition à partir d'une image qcow2</span>
</h4>
<p>Nous allons utiliser <code>qemu-nbd</code>, qui permet d'utiliser le protocole NBD (<i>network block device</i>) pour partager l'image disque.
</p>
<p>Tout d'abord, nous devons charger le module <i>nbd</i> :
</p>
<pre># modprobe nbd max_part=16
</pre>
<p>Ensuite, nous pouvons partager le disque et créer les entrées du périphérique :
</p>
<pre># qemu-nbd -c /dev/nbd0 <i>/chemin/vers/image.qcow2</i>
</pre>
<p>Découvrez les partitions :
</p>
<pre># partprobe /dev/nbd0
</pre>
<p><i>fdisk</i> peut être utilisé pour obtenir des informations sur les différentes partitions de <code><i>nbd0</i></code> :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/nbd0</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Disk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xa6a4d542

Device      Boot   Start      End  Sectors  Size Id Type
/dev/nbd0p1 *       2048  1026047  1024000  500M  7 HPFS/NTFS/exFAT
/dev/nbd0p2      1026048 52877311 51851264 24.7G  7 HPFS/NTFS/exFAT</pre>
<p>Ensuite, montez n'importe quelle partition de l'image du disque, par exemple la partition 2 :
</p>
<pre># mount /dev/nbd0<b>p2</b> <i>mountpoint</i>
</pre>
<p>Après l'utilisation, il est important de démonter l'image et d'inverser les étapes précédentes, c'est-à-dire démonter la partition et déconnecter le périphérique nbd :
</p>
<pre># umount <i>mountpoint</i>
# qemu-nbd -d /dev/nbd0
</pre>
<h3>
<span id="Utilisation_de_n.27importe_quelle_partition_r.C3.A9elle_comme_partition_primaire_unique_d.27une_image_de_disque_dur"></span><span class="mw-headline" id="Utilisation_de_n'importe_quelle_partition_réelle_comme_partition_primaire_unique_d'une_image_de_disque_dur">Utilisation de n'importe quelle partition réelle comme partition primaire unique d'une image de disque dur</span>
</h3>
<p>Parfois, vous pouvez souhaiter utiliser l'une de vos partitions système à partir de QEMU. L'utilisation d'une partition brute pour une machine virtuelle améliorera les performances, car les opérations de lecture et d'écriture ne passent pas par la couche du système de fichiers sur l'hôte physique. Une telle partition fournit également un moyen de partager des données entre l'hôte et l'invité.
</p>
<p>Dans Arch Linux, les fichiers de périphérique pour les partitions brutes sont, par défaut, la propriété de <i>root</i> et du groupe <i>disk</i>. Si vous souhaitez qu'un utilisateur non root puisse lire et écrire sur une partition brute, vous devez soit changer le propriétaire du fichier de périphérique de la partition pour cet utilisateur, ajouter cet utilisateur au groupe <i>disk</i>, ou utiliser <a href="../en/Access_Control_Lists.html" class="mw-redirect" title="ACL">ACL</a> pour un contrôle d'accès plus fin.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> 
<ul>
<li>Bien que cela soit possible, il n'est pas recommandé de permettre aux machines virtuelles de modifier des données critiques sur le système hôte, comme la partition racine.</li>
<li>Vous ne devez pas monter un système de fichiers sur une partition en lecture-écriture sur l'hôte et l'invité en même temps. Sinon, il y aura corruption des données.</li>
</ul>
</div>
<p>Après avoir fait cela, vous pouvez attacher la partition à une machine virtuelle QEMU comme un disque virtuel.
</p>
<p>Cependant, les choses sont un peu plus compliquées si vous souhaitez que la machine virtuelle <i>entière</i> soit contenue dans une partition. Dans ce cas, il n'y aura pas de fichier image de disque pour démarrer la machine virtuelle puisque vous ne pouvez pas installer un chargeur d'amorçage sur une partition qui est elle-même formatée comme un système de fichiers et non comme un périphérique partitionné avec un MBR. Une telle machine virtuelle peut être démarrée soit par : <a href="#Sp%C3%A9cifier_le_noyau_et_l'initrd_manuellement">#Spécifier le noyau et l'initrd manuellement</a>, <a href="#Simulation_d'un_disque_virtuel_avec_MBR">#Simulation d'un disque virtuel avec MBR</a>, <a href="#Utilisation_du_device-mapper">#Utilisation du device-mapper</a>, <a href="#Utilisation_d'un_RAID_lin%C3%A9aire">#Utilisation d'un RAID linéaire</a> ou <a href="#Utilisation_d'un_p%C3%A9riph%C3%A9rique_de_bloc_en_r%C3%A9seau">#Utilisation d'un périphérique de bloc en réseau</a>.
</p>
<h4>
<span id="Sp.C3.A9cifier_le_noyau_et_l.27initrd_manuellement"></span><span class="mw-headline" id="Spécifier_le_noyau_et_l'initrd_manuellement">Spécifier le noyau et l'initrd manuellement</span>
</h4>
<p>QEMU prend en charge le chargement direct des <a href="../fr/Kernel.html" title="Kernel (Français)">noyaux Linux</a> et des <a href="../fr/Arch_boot_process.html#Initramfs" title="Arch boot process (Français)">init ramdisks</a>, contournant ainsi les chargeurs d'amorçage tels que <a href="../en/GRUB.html" class="mw-redirect" title="GRUB (Français)">GRUB</a>. Il peut ensuite être lancé avec la partition physique contenant le système de fichiers racine comme disque virtuel, qui ne semblera pas être partitionné. Pour ce faire, il suffit de lancer une commande similaire à la suivante :
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Dans cet exemple, ce sont les images de l'<i>hôte</i> qui sont utilisées, pas celles de l'invité. Si vous souhaitez utiliser les images de l'invité, montez <code>/dev/sda3</code> en lecture seule (pour protéger le système de fichiers de l'hôte) et spécifiez le <code>/full/path/to/images</code> ou utilisez des astuces de kexec dans l'invité pour recharger le noyau de l'invité (prolonge le temps de démarrage). </div>
<pre>$ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3
</pre>
<p>Dans l'exemple ci-dessus, la partition physique utilisée pour le système de fichiers racine de l'invité est <code>/dev/sda3</code> sur l'hôte, mais elle apparaît comme <code>/dev/sda</code> sur l'invité.
</p>
<p>Vous pouvez, bien sûr, spécifier n'importe quel noyau et initrd que vous voulez, et pas seulement ceux qui sont fournis avec Arch Linux.
</p>
<p>Quand il y a plusieurs <a href="../en/Kernel_parameters.html" title="Kernel parameters">paramètres du noyau</a> à passer à l'option <code>-append</code>, ils doivent être cités en utilisant des guillemets simples ou doubles. Par exemple :
</p>
<pre>... -append 'root=/dev/sda1 console=ttyS0
</pre>
<h4>
<span id="Simulation_d.27un_disque_virtuel_avec_MBR"></span><span class="mw-headline" id="Simulation_d'un_disque_virtuel_avec_MBR">Simulation d'un disque virtuel avec MBR</span>
</h4>
<p>Une manière plus compliquée de faire en sorte qu'une machine virtuelle utilise une partition physique, tout en gardant cette partition formatée en tant que système de fichiers et en ne faisant pas simplement en sorte que l'invité partitionne la partition comme s'il s'agissait d'un disque, est de simuler un MBR pour celle-ci afin qu'elle puisse démarrer à l'aide d'un chargeur d'amorçage tel que GRUB.
</p>
<p>Pour ce qui suit, supposons que vous ayez une partition non montée <code>/dev/hda<i>N</i></code> avec un système de fichiers sur laquelle vous souhaitez faire partie d'une image disque QEMU. L'astuce consiste à faire précéder dynamiquement d'un master boot record (MBR) la partition réelle que vous souhaitez intégrer dans une image disque brute QEMU. Plus généralement, la partition peut être n'importe quelle partie d'un disque simulé plus grand, en particulier un périphérique de bloc qui simule le disque physique original mais qui n'expose <code>/dev/hda<i>N</i></code> que la machine virtuelle.
</p>
<p>Un disque virtuel de ce type peut être représenté par un fichier VMDK qui contient des références au MBR et à la partition (une copie de ceux-ci), mais QEMU ne prend pas en charge ce format VMDK. Par exemple, un disque virtuel <a rel="nofollow" class="external text" href="https://www.virtualbox.org/manual/ch09.html#rawdisk">créé par</a>
</p>
<pre>$ VBoxManage internalcommands createrawvmdk -filename <i>/path/to/file.vmdk</i> -rawdisk /dev/hda
</pre>
<p>sera rejetée par QEMU avec le message d'erreur suivant
</p>
<pre>Type d'image non supporté 'partitionedDevice'
</pre>
<p>Notez que <code>VBoxManage</code> crée deux fichiers, <code><i>file.vmdk</i></code> et <code><i>file-pt.vmdk</i></code>, ce dernier étant une copie du MBR, vers lequel pointe le fichier texte <code>file.vmdk</code>. Les opérations de lecture en dehors de la partition cible ou du MBR donneraient des zéros, tandis que les données écrites seraient rejetées.
</p>
<h5><span class="mw-headline" id="Utilisation_du_device-mapper">Utilisation du device-mapper</span></h5>
<p>Une méthode similaire à l'utilisation d'un fichier descripteur VMDK utilise le <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/device-mapper/index.html">device-mapper</a> pour ajouter un périphérique en boucle attaché au fichier MBR à la partition cible. Dans le cas où nous n'avons pas besoin que notre disque virtuel ait la même taille que l'original, nous créons d'abord un fichier pour contenir le MBR :
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=2048
</pre>
<p>Ici, un fichier de 1 Mio (2048 * 512 octets) est créé conformément aux politiques d'alignement des partitions utilisées par les outils modernes de partitionnement de disques. Pour des raisons de compatibilité avec les anciens logiciels de partitionnement, 63 secteurs au lieu de 2048 peuvent être nécessaires. Le MBR ne nécessite qu'un seul bloc de 512 octets, l'espace libre supplémentaire peut être utilisé pour une partition de démarrage du BIOS et, dans le cas d'un schéma de partitionnement hybride, pour une table de partition GUID. Ensuite, nous attachons un périphérique en boucle au fichier MBR :
</p>
<pre># losetup --show -f <i>/path/to/mbr</i> - /dev/loop0
/dev/loop0
</pre>
<p>Dans cet exemple, le périphérique résultant est <code>/dev/loop0</code>. Le mappeur de périphériques est maintenant utilisé pour joindre le MBR et la partition :
</p>
<pre># echo "0 2048 linear /dev/loop0 0
2048 `blockdev --getsz /dev/hda' 'N<i>` linear /dev/hda' 'N</i> 0" | dmsetup create qemu
</pre>
<p>Le résultat <code>/dev/mapper/qemu</code> est ce que nous allons utiliser comme image disque brute QEMU. Des étapes supplémentaires sont nécessaires pour créer une table de partition (consultez la section qui décrit l'utilisation d'un RAID linéaire pour un exemple) et le code du chargeur d'amorçage sur le disque virtuel (qui sera stocké dans <code><i>/path/to/mbr</i></code>).
</p>
<p>La configuration suivante est un exemple où la position de <code>/dev/hda<i>N</i></code> sur le disque virtuel doit être la même que sur le disque physique et le reste du disque est caché, à l'exception du MBR, qui est fourni en copie :
</p>
<pre># dd if=/dev/hda count=1 of=<i>/path/to/mbr</i>
# loop=`losetup --show -f <i>/path/to/mbr</i>`
# start=`blockdev --report /dev/hda<i>N</i> | tail -1 | awk '{print $5}'`
# size=`blockdev --getsz /dev/hda<i>N</i>`
# disksize=`blockdev --getsz /dev/hda`
# echo "0 1 linear $loop 0
1 $((start-1)) zero
$start $size linear /dev/hda<i>N</i> 0
$((start+size)) $((disksize-start-size)) zero" | dmsetup create qemu
</pre>
<p>La table fournie en entrée standard à <code>dmsetup</code> a un format similaire à celui de la table d'un fichier descripteur VMDK produit par <code>VBoxManage</code> et peut également être chargée à partir d'un fichier avec <code>dmsetup create qemu --table <i>table_file</i></code>. Pour la machine virtuelle, seul <code>/dev/hda<i>N</i></code> est accessible, tandis que le reste du disque dur est lu comme des zéros et rejette les données écrites, sauf pour le premier secteur. Nous pouvons imprimer la table pour <code>/dev/mapper/qemu</code> avec <code>dmsetup table qemu</code>. (utilisez <code>udevadm info -rq name /sys/dev/block/<i>major</i>:<i>minor</i></code> pour traduire <code><i>major</i>:<i>minor</i></code> au nom correspondant <code>/dev/<i>blockdevice</i></code>). Utilisez <code>dmsetup remove qemu</code> et <code>losetup -d $loop</code> pour supprimer les périphériques créés.
</p>
<p>Une situation où cet exemple serait utile est une installation existante de Windows XP dans une configuration multi-boot et peut-être un schéma de partitionnement hybride (sur le matériel physique, Windows XP pourrait être le seul système d'exploitation qui utilise la table de partition MBR, tandis que des systèmes d'exploitation plus modernes installés sur le même ordinateur pourraient utiliser la table de partition GUID). Windows XP prend en charge les profils matériels, de sorte que la même installation peut être utilisée alternativement avec différentes configurations matérielles (dans ce cas, bare metal et virtuel), Windows n'ayant besoin d'installer les pilotes pour le matériel nouvellement détecté qu'une seule fois pour chaque profil. Notez que dans cet exemple, le code du chargeur d'amorçage dans le MBR copié doit être mis à jour pour charger directement Windows XP à partir de <code>/dev/hda<i>N</i></code> au lieu d'essayer de lancer le chargeur d'amorçage multi-boot (comme GRUB) présent dans le système d'origine. Alternativement, une copie de la partition de démarrage contenant l'installation du chargeur d'amorçage peut être incluse dans le disque virtuel de la même manière que le MBR.
</p>
<h5>
<span id="Utilisation_d.27un_RAID_lin.C3.A9aire"></span><span class="mw-headline" id="Utilisation_d'un_RAID_linéaire">Utilisation d'un RAID linéaire</span>
</h5>
<p>Vous pouvez également le faire en utilisant un <a href="../en/RAID.html" title="RAID">RAID</a> logiciel en mode linéaire (vous avez besoin du pilote du noyau <code>linear.ko</code>) et d'un périphérique de bouclage : 
</p>
<p>D'abord, vous créez un petit fichier pour contenir le MBR :
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=32
</pre>
<p>Ici, un fichier de 16 Kio (32 * 512 octets) est créé. Il est important de ne pas le rendre trop petit (même si le MBR n'a besoin que d'un seul bloc de 512 octets), car plus il sera petit, plus la taille des morceaux du dispositif RAID logiciel devra être petite, ce qui pourrait avoir un impact sur les performances. Ensuite, vous configurez un périphérique de bouclage vers le fichier MBR :
</p>
<pre># losetup -f <i>/path/to/mbr</i>.
</pre>
<p>Supposons que le périphérique résultant soit <code>/dev/loop0</code>, car nous n'aurions pas déjà utilisé d'autres boucles. L'étape suivante consiste à créer l'image disque MBR + <code>/dev/hda<i>N</i></code> "fusionnée" en utilisant le RAID logiciel :
</p>
<pre># modprobe linear
# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hda<i>N'</i>
</pre>
<p>Le résultat <code>/dev/md0</code> est ce que vous utiliserez comme image disque brute QEMU (n'oubliez pas de définir les permissions pour que l'émulateur puisse y accéder). La dernière étape (et quelque peu délicate) consiste à définir la configuration du disque (géométrie du disque et table des partitions) de sorte que le point de départ de la partition primaire dans le MBR corresponde à celui de <code>/dev/hda<i>N</i></code> à l'intérieur de <code>/dev/md0</code>. (un décalage d'exactement 16 * 512 = 16384 octets dans cet exemple). Faites ceci en utilisant <code>fdisk</code> sur la machine hôte, pas dans l'émulateur : la routine de détection de disque brut par défaut de QEMU résulte souvent en des décalages non arrondissables en kilooctets (comme 31,5 Kio, comme dans la section précédente) qui ne peuvent pas être gérés par le code RAID logiciel. Par conséquent, depuis l'hôte :
</p>
<pre># fdisk /dev/md0
</pre>
<p>Appuyez sur <code>X</code> pour accéder au menu expert. Définissez le nombre de secteurs par piste de sorte que la taille d'un cylindre corresponde à la taille de votre fichier MBR. Pour deux têtes et une taille de secteur de 512, le nombre de secteurs par piste doit être de 16, ce qui donne des cylindres de taille 2x16x512=16k.
</p>
<p>Maintenant, appuyez sur <code>R</code> pour revenir au menu principal.
</p>
<p>Appuyez sur <code>P</code> et vérifiez que la taille du cylindre est maintenant de 16k.
</p>
<p>Maintenant, créez une partition primaire unique correspondant à <code>/dev/hda<i>N</i></code>. Elle doit commencer au cylindre 2 et se terminer à la fin du disque (notez que le nombre de cylindres diffère maintenant de ce qu'il était lorsque vous avez entré fdisk.
</p>
<p>Enfin, écrivez le résultat dans le fichier : vous avez terminé. Vous avez maintenant une partition que vous pouvez monter directement depuis votre hôte, ainsi qu'une partie d'une image disque QEMU :
</p>
<pre>$ qemu-system-x86_64 -hdc /dev/md0 <i>[...]'</i>.
</pre>
<p>Vous pouvez, bien sûr, installer en toute sécurité n'importe quel chargeur d'amorçage sur cette image disque à l'aide de QEMU, à condition que la partition originale <code>/dev/hda<i>N</i></code> contienne les outils nécessaires.
</p>
<h5>
<span id="Utilisation_d.27un_p.C3.A9riph.C3.A9rique_de_bloc_en_r.C3.A9seau"></span><span class="mw-headline" id="Utilisation_d'un_périphérique_de_bloc_en_réseau">Utilisation d'un périphérique de bloc en réseau</span>
</h5>
<p>Avec <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/blockdev/nbd.html">Network Block Device</a>, Linux peut utiliser un serveur distant comme l'un de ses périphériques de bloc. Vous pouvez utiliser <code>nbd-server</code> (du paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nbd">nbd</a></span>) pour créer une enveloppe MBR pour QEMU.
</p>
<p>En supposant que vous avez déjà configuré votre fichier de wrapper MBR comme ci-dessus, renommez-le en <code>wrapper.img.0</code>. Créez ensuite un lien symbolique nommé <code>wrapper.img.1</code> dans le même répertoire, pointant vers votre partition. Ensuite, mettez le script suivant dans le même répertoire :
</p>
<pre>#!/bin/sh
dir="$(realpath "$(dirname "$0")")"
cat &gt;wrapper.conf &lt;&lt;EOF
[generic]
allowlist = true
listenaddr = 127.713705
port = 10809

[wrap]
exportname = $dir/wrapper.img
multifile = true
EOF

nbd-server \
    -C wrapper.conf \
    -p wrapper.pid \
    "$@"
</pre>
<p>Les suffixes <code>.0</code> et <code>.1</code> sont essentiels ; le reste peut être modifié. Après avoir exécuté le script ci-dessus (que vous devrez peut-être faire en tant que root pour vous assurer que nbd-server est capable d'accéder à la partition), vous pouvez lancer QEMU avec :
</p>
<pre>qemu-system-x86_64 -drive file=nbd:127.713705:10809:exportname=wrap [...]".
</pre>
<h3>
<span id="Utilisation_d.27un_p.C3.A9riph.C3.A9rique_de_disque_physique_entier_.C3.A0_l.27int.C3.A9rieur_de_la_VM"></span><span class="mw-headline" id="Utilisation_d'un_périphérique_de_disque_physique_entier_à_l'intérieur_de_la_VM">Utilisation d'un périphérique de disque physique entier à l'intérieur de la VM</span>
</h3>
<p>Vous pouvez avoir un deuxième disque dur avec un système d'exploitation différent (comme Windows) et vous voulez avoir la possibilité de le démarrer dans une VM.
Comme l'accès au disque est brut, le disque fonctionnera très bien à l'intérieur de la VM.
</p>
<h4>
<span id="pr.C3.A9requis_pour_le_d.C3.A9marrage_de_la_VM_Windows"></span><span class="mw-headline" id="prérequis_pour_le_démarrage_de_la_VM_Windows">prérequis pour le démarrage de la VM Windows</span>
</h4>
<p>Assurez-vous d'installer les <a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/">drivers virtio</a> dans le système d'exploitation sur ce disque avant d'essayer de le démarrer dans la VM.
Pour Win 7, utilisez la version <a rel="nofollow" class="external text" href="https://askubuntu.com/questions/1310440/using-virtio-win-drivers-with-win7-sp1-x64">0.1.173-4</a>.
Certains pilotes singuliers de versions plus récentes de virtio peuvent être utilisés sur Win 7 mais vous devrez les installer manuellement via le gestionnaire de périphériques.
Pour Win 10, vous pouvez utiliser la dernière version de virtio.
</p>
<h5>
<span id="configurer_les_pilotes_de_l.27interface_disque_de_windows"></span><span class="mw-headline" id="configurer_les_pilotes_de_l'interface_disque_de_windows">configurer les pilotes de l'interface disque de windows</span>
</h5>
<p>Il se peut que vous obteniez un écran bleu <code>0x0000007B</code> lorsque vous essayez de démarrer la VM. Cela signifie que Windows ne peut pas accéder au lecteur pendant la phase de démarrage précoce parce que le pilote d'interface de disque dont il aurait besoin pour cela n'est pas chargé / est configuré pour démarrer manuellement.
</p>
<p>La solution consiste à <a rel="nofollow" class="external text" href="https://superuser.com/a/1032769">activer ces pilotes pour qu'ils démarrent au démarrage</a>.
</p>
<p>Dans <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</code>, trouvez les dossiers <code>aliide, amdide, atapi, cmdide, iastor (peut ne pas exister), iastorV, intelide, LSI_SAS, msahci, pciide et viaide</code>.
Dans chacun d'entre eux, définissez toutes les valeurs de "start" à 0 afin de les activer au démarrage.
Si votre disque est un disque PCIe NVMe, activez également ce pilote (s'il existe).
</p>
<h4><span class="mw-headline" id="trouver_le_chemin_unique_de_votre_disque">trouver le chemin unique de votre disque</span></h4>
<p>Exécutez <code>ls /dev/disk/by-id/</code>.
Là, vous choisissez l'ID du disque que vous voulez insérer dans la VM, mon ID de disque est <code>ata-TS512GMTS930L_C199211383</code>.
Ajoutez maintenant cet ID à <code>/dev/disk/by-id/</code> pour obtenir <code>/dev/disk/by-id/ata-TS512GMTS930L_C199211383</code>.
C'est le chemin unique vers ce disque.
</p>
<h4><span class="mw-headline" id="ajouter_le_disque_dans_la_CLI_QEMU">ajouter le disque dans la CLI QEMU</span></h4>
<p>Dans la CLI de QEMU, ce serait probablement :
</p>
<p><code>-drive file=/dev/disk/by-id/ata-TS512GMTS930L_C199211383,format=raw,media=disk</code>
</p>
<p>Modifiez simplement "file=" pour qu'il soit le chemin unique de votre disque.
</p>
<h4><span class="mw-headline" id="ajouter_le_disque_dans_libvirt">ajouter le disque dans libvirt</span></h4>
<p>Dans le xml de libvirt, cela se traduit par
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ virsh edit <i>vmname</i></pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
    &lt;disk type="block" device="disk"&gt;
      &lt;driver name="qemu" type="raw" cache="none" io="native"/&gt;
      &lt;source dev="/dev/disk/by-id/ata-TS512GMTS930L_C199211383"/&gt;
      &lt;target dev="sda" bus="sata"/&gt;
      &lt;address type="drive" controller="0" bus="0" target="0" unit="0"/&gt;
    &lt;/disk&gt;
...
</pre>
<p>Modifiez simplement "source dev" pour qu'il soit le chemin unique de votre disque.
</p>
<h4><span class="mw-headline" id="ajouter_le_disque_dans_virt-manager">ajouter le disque dans virt-manager</span></h4>
<p>Lorsque vous créez une VM, sélectionnez "import existing drive" et collez simplement ce chemin unique.
Si vous avez déjà la VM, ajoutez un périphérique, un stockage, puis sélectionnez ou créez un stockage personnalisé.
Collez ensuite le chemin d'accès unique.
</p>
<h2>
<span id="Mise_en_r.C3.A9seau"></span><span class="mw-headline" id="Mise_en_réseau">Mise en réseau</span>
</h2>
<p>Les performances de la mise en réseau virtuelle devraient être meilleures avec les périphériques tap et les ponts qu'avec la mise en réseau en mode utilisateur ou vde car les périphériques tap et les ponts sont implémentés dans le noyau.
</p>
<p>En outre, les performances de mise en réseau peuvent être améliorées en assignant aux machines virtuelles un périphérique réseau <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a> plutôt que l'émulation par défaut d'une carte réseau e1000. Consultez <a href="#Installation_des_pilotes_virtio">#Installation des pilotes virtio</a> pour plus d'informations.
</p>
<h3>
<span id="Mise_en_garde_concernant_l.27adresse_au_niveau_du_lien"></span><span class="mw-headline" id="Mise_en_garde_concernant_l'adresse_au_niveau_du_lien">Mise en garde concernant l'adresse au niveau du lien</span>
</h3>
<p>En donnant l'argument <code>-net nic</code> à QEMU, celui-ci attribuera, par défaut, à une machine virtuelle une interface réseau avec l'adresse de niveau lien <code>52:54:00:12:34:56</code>. Cependant, lors de l'utilisation d'une mise en réseau pontée avec plusieurs machines virtuelles, il est essentiel que chaque machine virtuelle ait une adresse unique de niveau lien (MAC) du côté de la machine virtuelle du périphérique de connexion. Sinon, le pont ne fonctionnera pas correctement, car il recevra des paquets de plusieurs sources ayant la même adresse de niveau de liaison. Ce problème se produit même si les périphériques de dérivation eux-mêmes ont des adresses de niveau de lien uniques car l'adresse de niveau de lien source n'est pas réécrite lorsque les paquets passent par le périphérique de dérivation.
</p>
<p>Assurez-vous que chaque machine virtuelle possède une adresse de niveau lien unique, mais elle doit toujours commencer par <code>52:54:</code>. Utilisez l'option suivante, remplacez <i>X</i> par un chiffre hexadécimal arbitraire :
</p>
<pre>$ qemu-system-x86_64 -net nic,macaddr=52:54:<i>XX:XX:XX:XX</i> -net vde <i>disk_image</i> -net vde <i>disk_image</i>.
</pre>
<p>La génération d'adresses uniques au niveau des liens peut se faire de plusieurs manières :
</p>
<ul>
<li>Spécifier manuellement une adresse unique de niveau lien pour chaque NIC. L'avantage est que le serveur DHCP attribuera la même adresse IP à chaque fois que la machine virtuelle est exécutée, mais cette méthode est inutilisable pour un grand nombre de machines virtuelles.</li>
<li>Générer une adresse aléatoire au niveau du lien à chaque fois que la machine virtuelle est exécutée. La probabilité de collisions est pratiquement nulle, mais l'inconvénient est que le serveur DHCP attribuera une adresse IP différente à chaque fois. Vous pouvez utiliser la commande suivante dans un script pour générer une adresse de niveau lien aléatoire dans une variable <code>macaddr</code> :</li>
</ul>
<pre>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff ))
qemu-system-x86_64 -net nic,macaddr="$macaddr" -net vde <i>disk_image</i></pre>
<ul><li>Utilisez le script suivant <code>qemu-mac-hasher.py</code> pour générer l'adresse de niveau lien à partir du nom de la machine virtuelle en utilisant une fonction de hachage. Étant donné que les noms des machines virtuelles sont uniques, cette méthode combine les avantages des méthodes susmentionnées : elle génère la même adresse de niveau lien à chaque exécution du script, tout en préservant la probabilité pratiquement nulle de collisions.</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">qemu-mac-hasher.py</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/usr/bin/env python
# utilisation : qemu-mac-hasher.py &lt;VMName&gt;

import sys
import zlib

crc = str(hex(zlib.crc32(sys.argv[1].encode("utf-8")))).replace("x", "")[-8 :]
print("52:54:%s%s:%s%s:%s%s:%s%s" % tuple(crc))</pre>
<p>Dans un script, vous pouvez utiliser par exemple :
</p>
<pre>vm_name="<i>Nom de la VM</i>"
qemu-system-x86_64 -name <i>$vm_name</i> -net nic,macaddr=$(qemu-mac-hasher.py <i>$vm_name</i>) -net vde <i>disk_image</i> 
</pre>
<h3>
<span id="Mise_en_r.C3.A9seau_en_mode_utilisateur"></span><span class="mw-headline" id="Mise_en_réseau_en_mode_utilisateur">Mise en réseau en mode utilisateur</span>
</h3>
<p>Par défaut, sans aucun argument <code>-netdev</code>, QEMU utilisera un réseau en mode utilisateur avec un serveur DHCP intégré. Vos machines virtuelles se verront attribuer une adresse IP lorsqu'elles exécuteront leur client DHCP, et elles pourront accéder au réseau de l'hôte physique grâce au masquage d'IP effectué par QEMU.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> ICMPv6 ne fonctionnera pas, car sa prise en charge n'est pas implémentée : <code>Slirp : external icmpv6 not supported yet</code>. Le <a href="../en/Network_configuration.html#Ping" title="Network configuration">ping</a> d'une adresse IPv6 ne fonctionnera pas.</div>
<p>Cette configuration par défaut permet à vos machines virtuelles d'accéder facilement à Internet, à condition que l'hôte y soit connecté, mais les machines virtuelles ne seront pas directement visibles sur le réseau externe, et les machines virtuelles ne pourront pas parler entre elles si vous en démarrez plusieurs simultanément.
</p>
<p>La mise en réseau en mode utilisateur de QEMU peut offrir plus de possibilités, comme des serveurs TFTP ou SMB intégrés, la redirection des ports de l'hôte vers l'invité (par exemple pour permettre des connexions SSH vers l'invité) ou l'attachement des invités à des VLAN afin qu'ils puissent se parler entre eux. Consultez la documentation de QEMU sur l'option <code>-net user</code> pour plus de détails.
</p>
<p>Cependant, la mise en réseau en mode utilisateur a des limites à la fois en termes d'utilité et de performance. Les configurations de réseau plus avancées nécessitent l'utilisation de périphériques de connexion ou d'autres méthodes.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Si le système hôte utilise <a href="../fr/Systemd-networkd.html" title="Systemd-networkd (Français)">systemd-networkd</a>, assurez-vous de faire un lien symbolique au fichier <code>/etc/resolv.conf</code> comme décrit dans <a href="../fr/Systemd-networkd.html#Services_requis_et_configuration" title="Systemd-networkd (Français)">systemd-networkd (Français)#Services requis et configuration</a>, sinon la recherche DNS dans le système invité ne fonctionnera pas.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Pour utiliser le pilote virtio avec une mise en réseau en mode utilisateur, l'option est : <code>-nic user,model=virtio-net-pci</code>.</div>
<h3>
<span id="Mise_en_r.C3.A9seau_avec_tap_pour_QEMU"></span><span class="mw-headline" id="Mise_en_réseau_avec_tap_pour_QEMU">Mise en réseau avec tap pour QEMU</span>
</h3>
<p><a href="https://en.wikipedia.org/wiki/TUN/TAP" class="extiw" title="wikipedia:TUN/TAP">Les périphériques tap</a> sont une fonctionnalité du noyau Linux qui vous permet de créer des interfaces réseau virtuelles qui apparaissent comme des interfaces réseau réelles. Les paquets envoyés à une interface tap sont délivrés à un programme en espace utilisateur, tel que QEMU, qui s'est lié à l'interface.
</p>
<p>QEMU peut utiliser la mise en réseau par tap pour une machine virtuelle afin que les paquets envoyés à l'interface tap soient envoyés à la machine virtuelle et apparaissent comme provenant d'une interface réseau (généralement une interface Ethernet) dans la machine virtuelle. Inversement, tout ce que la machine virtuelle envoie via son interface réseau apparaîtra sur l'interface tap.
</p>
<p>Les périphériques tap sont pris en charge par les pilotes de pontage Linux, il est donc possible de relier les périphériques tap entre eux et éventuellement avec d'autres interfaces hôtes telles que <code>eth0</code>. Ceci est souhaitable si vous voulez que vos machines virtuelles puissent se parler entre elles ou si vous voulez que d'autres machines sur votre LAN puissent parler aux machines virtuelles.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Si vous établissez un pont entre le périphérique de claquage et une interface hôte, telle que <code>eth0</code>, vos machines virtuelles apparaîtront directement sur le réseau externe, ce qui les exposera à une éventuelle attaque. En fonction des ressources auxquelles vos machines virtuelles ont accès, vous devrez peut-être prendre toutes les <a href="../fr/Category:Firewalls.html" title="Category:Firewalls (Français)">précautions</a> que vous prendriez normalement pour sécuriser un ordinateur afin de sécuriser vos machines virtuelles. Si le risque est trop grand, que les machines virtuelles ont peu de ressources ou que vous configurez plusieurs machines virtuelles, une meilleure solution pourrait être d'utiliser <a href="#Mise_en_r%C3%A9seau_uniquement_avec_l'h%C3%B4te">mise en réseau avec l'hôte uniquement</a> et de configurer la NAT. Dans ce cas, vous n'avez besoin que d'un seul pare-feu sur l'hôte au lieu de plusieurs pare-feu pour chaque invité.</div>
<p>Comme indiqué dans la section sur la mise en réseau en mode utilisateur, les périphériques tap offrent des performances de mise en réseau plus élevées qu'en mode utilisateur.  Si le système d'exploitation invité prend en charge le pilote réseau virtio, les performances réseau seront également considérablement améliorées.  En supposant l'utilisation du périphérique tap0, que le pilote virtio est utilisé sur l'invité, et qu'aucun script n'est utilisé pour aider à démarrer/arrêter la mise en réseau, voici une partie de la commande qemu que l'on devrait consulter :
</p>
<pre>-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no
</pre>
<p>Mais si vous utilisez déjà un périphérique tap avec le pilote réseau de virtio, vous pouvez encore améliorer les performances réseau en activant vhost, comme suit :
</p>
<pre>-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on
</pre>
<p>Consultez <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20160222161955/http://www.linux-kvm.com:80/content/how-maximize-virtio-net-performance-vhost-net">[2]</a> pour plus d'informations.
</p>
<h4>
<span id="Mise_en_r.C3.A9seau_uniquement_avec_l.27h.C3.B4te"></span><span class="mw-headline" id="Mise_en_réseau_uniquement_avec_l'hôte">Mise en réseau uniquement avec l'hôte</span>
</h4>
<p>Si une adresse IP est attribuée au pont et que le trafic qui lui est destiné est autorisé, mais qu'aucune interface réelle (par exemple, <code>eth0</code>) n'est connectée au pont, les machines virtuelles pourront communiquer entre elles et avec le système hôte. Cependant, elles ne pourront pas parler à quoi que ce soit sur le réseau externe, à condition que vous ne configuriez pas de masquage d'IP sur l'hôte physique. Cette configuration est appelée <i>mise en réseau de l'hôte uniquement</i> par d'autres logiciels de virtualisation tels que <a href="../en/VirtualBox.html" class="mw-redirect" title="VirtualBox (Français)">VirtualBox</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> 
<ul>
<li>Si vous souhaitez configurer le masquage d'adresses IP, par exemple le NAT pour les machines virtuelles, consultez la page <a href="../fr/Internet_sharing.html#Activer_le_NAT" title="Internet sharing (Français)">Internet sharing (Français)#Activer le NAT</a>.</li>
<li>Consultez la page <a href="../en/Network_bridge.html" title="Network bridge">Network bridge</a> pour obtenir des informations sur la création de ponts.</li>
<li>Il se peut que vous souhaitiez qu'un serveur DHCP fonctionne sur l'interface du pont pour desservir le réseau virtuel. Par exemple, pour utiliser le sous-réseau <code>172.20.0.1/16</code> avec <a href="../en/Dnsmasq.html" title="Dnsmasq">dnsmasq</a> comme serveur DHCP :</li>
</ul>
<pre># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254</pre>
</div>
<h4>
<span id="R.C3.A9seau_interne"></span><span class="mw-headline" id="Réseau_interne">Réseau interne</span>
</h4>
<p>Si vous ne donnez pas d'adresse IP au pont et que vous ajoutez une règle <a href="../fr/Iptables.html" title="Iptables (Français)">iptables</a> pour supprimer tout le trafic vers le pont dans la chaîne INPUT, les machines virtuelles pourront communiquer entre elles, mais pas avec l'hôte physique ni avec le réseau extérieur. Cette configuration est appelée <i>réseau interne</i> par d'autres logiciels de virtualisation tels que <a href="../en/VirtualBox.html" class="mw-redirect" title="VirtualBox (Français)">VirtualBox</a>. Vous devrez soit attribuer des adresses IP statiques aux machines virtuelles, soit exécuter un serveur DHCP sur l'une d'entre elles.
</p>
<p>Par défaut, iptables laisse tomber les paquets dans le réseau ponté. Vous devrez peut-être utiliser une telle règle iptables pour autoriser les paquets dans un réseau ponté :
</p>
<pre># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4>
<span id="R.C3.A9seau_pont.C3.A9_utilisant_qemu-bridge-helper"></span><span class="mw-headline" id="Réseau_ponté_utilisant_qemu-bridge-helper">Réseau ponté utilisant qemu-bridge-helper</span>
</h4>
<p>Cette méthode ne nécessite pas de script de démarrage et s'adapte facilement à des prises multiples et à des ponts multiples. Elle utilise le binaire <code>/usr/lib/qemu/qemu-bridge-helper</code>, qui permet de créer des périphériques de prise sur un pont existant.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> 
<ul>
<li>Consultez <a href="../en/Network_bridge.html" title="Network bridge">Network bridge</a> pour des informations sur la création de ponts.</li>
<li>Consultez <a rel="nofollow" class="external free" href="https://wiki.qemu.org/Features/HelperNetworking">https://wiki.qemu.org/Features/HelperNetworking</a> pour plus d'informations sur l'aide réseau de QEMU.</li>
</ul>
</div>
<p>Tout d'abord, créez un fichier de configuration contenant les noms de tous les ponts à utiliser par QEMU :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu/bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">allow <i>br0</i> (autoriser)
allow <i>br1</i> (autoriser <i>br1</i>)
...</pre>
<p>Assurez-vous que <code>/etc/qemu/</code> a <code>755</code> <a href="../en/File_permissions_and_attributes.html" class="mw-redirect" title="Permissions">permissions</a>. Si ce n'est pas le cas, des <a rel="nofollow" class="external text" href="https://gitlab.com/qemu-project/qemu/-/issues/515">problèmes avec QEMU</a> et <a rel="nofollow" class="external text" href="https://www.gns3.com/community/discussions/gns3-cannot-work-with-qemu">problèmes avec GNS3</a> peuvent survenir.
</p>
<p>Maintenant démarrez la VM ; l'utilisation la plus basique est d'exécuter QEMU avec l'aide réseau par défaut et le pont par défaut <code>br0</code> :
</p>
<pre>$ qemu-system-x86_64 -nic bridge <i>[...]'</i>.
</pre>
<p>En utilisant le pont <code>br1</code> et le pilote virtio :
</p>
<pre>$ qemu-system-x86_64 -nic bridge,br=<i>br1</i>,model=virtio-net-pci <i>[...]'</i>
</pre>
<h4>
<span id="Cr.C3.A9er_un_pont_manuellement"></span><span class="mw-headline" id="Créer_un_pont_manuellement">Créer un pont manuellement</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Depuis QEMU 1.1, le <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/HelperNetworking">network bridge helper</a> peut configurer tun/tap pour vous sans avoir besoin de script supplémentaire. Consultez <a href="#R%C3%A9seau_pont%C3%A9_utilisant_qemu-bridge-helper">#Réseau ponté utilisant qemu-bridge-helper</a>.</div> 
<p>Ce qui suit décrit comment établir un pont entre une machine virtuelle et une interface hôte telle que <code>eth0</code>, qui est probablement la configuration la plus courante. Cette configuration donne l'impression que la machine virtuelle est située directement sur le réseau externe, sur le même segment Ethernet que la machine hôte physique.
</p>
<p>Nous allons remplacer l'adaptateur Ethernet normal par un adaptateur pont et lier l'adaptateur Ethernet normal à celui-ci.
</p>
<ul><li>Installer <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>, qui fournit <code>brctl</code> pour manipuler les ponts.</li></ul>
<ul><li>Activez le transfert d'IPv4 :</li></ul>
<pre># sysctl -w net.ipv4.ip_forward=1
</pre>
<p>Pour rendre le changement permanent, changez <code>net.ipv4.ip_forward = 0</code> en <code>net.ipv4.ip_forward = 1</code> dans <code>/etc/sysctl.d/99-sysctl.conf</code>.
</p>
<ul><li>Chargez le module <code>tun</code> et configurez-le pour qu'il soit chargé au démarrage. Consultez <a href="../fr/Kernel_module.html" title="Kernel module (Français)">Modules du noyau</a> pour plus de détails.</li></ul>
<ul><li>Créez maintenant le pont. Consultez <a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">Bridge with netctl</a> pour plus de détails. N'oubliez pas de nommer votre pont comme <code>br0</code>, ou changez les scripts ci-dessous avec le nom de votre pont.</li></ul>
<ul><li>Créez le script que QEMU utilise pour faire apparaître l'adaptateur de robinet avec <code>root:kvm</code>, permissions 750 :</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifup</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifup"
echo "Bringing up $1 for bridged mode..."
sudo /usr/bin/ip link set $1 up promisc on
echo "Adding $1 to br0..."
sudo /usr/bin/brctl addif br0 $1
sleep 2
</pre>
<ul><li>Créez le script que QEMU utilise pour mettre hors service l'adaptateur tap dans <code>/etc/qemu-ifdown</code> avec <code>root:kvm</code> permissions 750 :</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifdown</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifdown"
sudo /usr/bin/ip link set $1 down
sudo /usr/bin/brctl delif br0 $1
sudo /usr/bin/ip link delete dev $1
</pre>
<ul><li>Utilisez <code>visudo</code> pour ajouter les éléments suivants à votre fichier <code>sudoers</code> :</li></ul>
<pre>Cmnd_Alias QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
%kvm ALL=NOPASSWD : QEMU
</pre>
<ul><li>Vous lancez QEMU en utilisant le script <code>run-qemu</code> suivant :</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">run-qemu</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/bash
USERID=$(whoami)

# Obtenir le nom du périphérique TAP nouvellement créé ; consultez https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079
precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d : -f1 | /usr/bin/sort)
sudo /usr/bin/ip tuntap add user $USERID mode tap
postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d : -f1 | /usr/bin/sort)
IFACE=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))

# Cette ligne crée une adresse MAC aléatoire. L'inconvénient est que le serveur DHCP assignera une adresse IP différente à chaque fois
printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff ))
# Au lieu de cela, décommentez et modifiez cette ligne pour définir une adresse MAC statique. L'avantage est que le serveur DHCP attribuera la même adresse IP.
# macaddr='52:54:be:36:42:a9'

qemu-system-x86_64 -net nic,macaddr=$macaddr -net tap,ifname="$IFACE" $*

sudo ip link set dev $IFACE down &amp;&gt; /dev/null
sudo ip tuntap del $IFACE mode tap &amp;&gt; /dev/null
</pre>
<p>Ensuite, pour lancer une VM, faites quelque chose comme ceci
</p>
<pre>$ run-qemu -hda <i>myvm.img</i> -m 512
</pre>
<ul><li>Il est recommandé, pour des raisons de performance et de sécurité, de désactiver le <a rel="nofollow" class="external text" href="https://ebtables.netfilter.org/documentation/bridge-nf.html">pare-feu sur le pont</a> :</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/10-disable-firewall-on-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
</pre>
<p>Exécutez <code>sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf</code> pour appliquer les modifications immédiatement.
</p>
<p>Consultez <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Networking#Creating_network_initscripts">le wiki de libvirt</a> et <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=512206">bug de Fedora n°512206</a>. Si vous obtenez des erreurs par sysctl pendant le démarrage à propos de fichiers inexistants, faites en sorte que le module <code>bridge</code> soit chargé au démarrage. Consultez <a href="../fr/Kernel_module.html#Chargement_automatique_des_modules" title="Kernel module (Français)">Kernel module (Français)#Chargement automatique des modules</a>.
</p>
<p>Alternativement, vous pouvez configurer <a href="../fr/Iptables.html" title="Iptables (Français)">iptables</a> pour permettre à tout le trafic d'être transféré à travers le pont en ajoutant une règle comme celle-ci :
</p>
<pre>-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4>
<span id="Partage_de_r.C3.A9seau_entre_un_p.C3.A9riph.C3.A9rique_physique_et_un_p.C3.A9riph.C3.A9rique_Tap_via_iptables"></span><span class="mw-headline" id="Partage_de_réseau_entre_un_périphérique_physique_et_un_périphérique_Tap_via_iptables">Partage de réseau entre un périphérique physique et un périphérique Tap via iptables</span>
</h4>
<p>Le réseau ponté fonctionne bien entre une interface câblée (par exemple eth0), et il est facile à configurer.  Cependant, si l'hôte est connecté au réseau par un périphérique sans fil, le pontage n'est pas possible.
</p>
<p>Consultez <a href="../en/Network_bridge.html#Wireless_interface_on_a_bridge" title="Network bridge">Network bridge#Wireless interface on a bridge</a> comme référence.
</p>
<p>Une façon de surmonter ce problème est de configurer un périphérique de connexion avec une IP statique, en faisant en sorte que linux gère automatiquement le routage pour lui, puis de transférer le trafic entre l'interface de connexion et le périphérique connecté au réseau par le biais de règles iptables.
</p>
<p>Consultez <a href="../fr/Internet_sharing.html" title="Internet sharing (Français)">Internet sharing (Français)</a> comme référence.
</p>
<p>Vous y trouverez tout ce qui est nécessaire pour partager le réseau entre les appareils, y compris les appareils tap et tun.  Ce qui suit ne fait que donner des indications supplémentaires sur certaines des configurations d'hôtes requises.  Comme indiqué dans la référence ci-dessus, le client doit être configuré pour une IP statique, en utilisant l'IP assignée à l'interface tap comme passerelle.  La mise en garde est que les serveurs DNS sur le client peuvent devoir être édités manuellement s'ils changent lors du passage d'un périphérique hôte connecté au réseau à un autre.
</p>
<p>Pour autoriser la redirection IP à chaque démarrage, il faut ajouter les lignes suivantes au fichier de configuration sysctl dans <code>/etc/sysctl.d</code> :
</p>
<pre>net.ipv4.ip_forward = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.conf.all.forwarding = 1
</pre>
<p>Les règles iptables peuvent ressembler à ceci :
</p>
<pre># Transfert de/vers l'extérieur
iptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT
iptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT
# NAT/Masquerade (traduction d'adresse réseau)
iptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE
</pre>
<p>L'antérieur suppose qu'il y a 3 dispositifs connectés au réseau partageant le trafic avec un dispositif interne, où par exemple :
</p>
<pre>INT=tap0
EXT_0=eth0
EXT_1=wlan0
EXT_2=tun0
</pre>
<p>L'exemple précédent montre une redirection qui permettrait de partager des connexions câblées et sans fil avec le périphérique tap.
</p>
<p>Les règles de transfert présentées sont sans état, et pour un transfert pur.  On pourrait penser à restreindre un trafic spécifique, en mettant en place un pare-feu pour protéger l'invité et les autres.  Cependant, ces mesures réduiraient les performances du réseau, alors qu'un simple pont n'inclut rien de tout cela.
</p>
<p>Bonus : que la connexion soit filaire ou sans fil, si l'on se connecte par VPN à un site distant avec un périphérique tun, en supposant que le périphérique tun ouvert pour cette connexion est tun0, et que les règles iptables précédentes sont appliquées, alors la connexion distante est également partagée avec l'invité.  Cela évite à l'invité d'avoir à ouvrir également une connexion VPN.  Encore une fois, comme le réseau de l'invité doit être statique, si l'on connecte l'hôte à distance de cette façon, il faudra très probablement modifier les serveurs DNS de l'invité.
</p>
<h3>
<span id="Mise_en_r.C3.A9seau_avec_VDE2"></span><span class="mw-headline" id="Mise_en_réseau_avec_VDE2">Mise en réseau avec VDE2</span>
</h3>
<h4>
<span id="Qu.27est-ce_que_VDE_.3F"></span><span class="mw-headline" id="Qu'est-ce_que_VDE_?">Qu'est-ce que VDE ?</span>
</h4>
<p>VDE est l'abréviation de Virtual Distributed Ethernet. Il a commencé comme une amélioration de <a href="../en/User-mode_Linux.html" title="User-mode Linux">uml</a>_switch. Il s'agit d'une boîte à outils pour gérer les réseaux virtuels.
</p>
<p>L'idée est de créer des commutateurs virtuels, qui sont en fait des prises, et d'y "brancher" des machines physiques et virtuelles. La configuration que nous montrons ici est assez simple ; cependant, VDE est beaucoup plus puissant que cela, il peut brancher des commutateurs virtuels ensemble, les faire fonctionner sur différents hôtes et surveiller le trafic dans les commutateurs. Vous êtes invités à lire <a rel="nofollow" class="external text" href="https://wiki.virtualsquare.org/">la documentation du projet</a>.
</p>
<p>L'avantage de cette méthode est que vous ne devez pas ajouter les privilèges sudo à vos utilisateurs. Les utilisateurs ordinaires ne doivent pas être autorisés à exécuter modprobe.
</p>
<h4><span class="mw-headline" id="Notions_de_base">Notions de base</span></h4>
<p><a href="../fr/Help:Reading.html#Installation_de_paquets" class="mw-redirect" title="Installez">Installez</a> le paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=vde2">vde2</a></span> si vous souhaitez la prise en charge de VDE.
</p>
<p>Dans notre configuration, nous utilisons tun/tap pour créer une interface virtuelle sur mon hôte. Chargez le module <code>tun</code> (consultez <a href="../fr/Kernel_module.html" title="Kernel module (Français)">Modules du noyau</a> pour plus de détails) :
</p>
<pre># modprobe tun
</pre>
<p>Créez maintenant le commutateur virtuel :
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
</pre>
<p>Cette ligne crée le commutateur, crée <code>tap0</code>, le "branche", et permet aux utilisateurs du groupe <code>users</code> de l'utiliser.
</p>
<p>L'interface est branchée mais pas encore configurée. Pour la configurer, exécutez cette commande :
</p>
<pre># ip addr add 192.168.100.254/24 dev tap0
</pre>
<p>Maintenant, il vous suffit de lancer KVM avec ces options <code>-net</code> comme un utilisateur normal :
</p>
<pre>$ qemu-system-x86_64 -net nic -net vde -hda <i>[...]'</i>.
</pre>
<p>Configurez le réseau pour votre invité comme vous le feriez dans un réseau physique.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Vous voudrez peut-être configurer NAT sur le périphérique de robinet pour accéder à l'Internet à partir de la machine virtuelle. Consultez <a href="../fr/Internet_sharing.html#Activer_le_NAT" title="Internet sharing (Français)">Internet sharing (Français)#Activer le NAT</a> pour plus d'informations.</div>
<h4>
<span id="Scripts_de_d.C3.A9marrage"></span><span class="mw-headline" id="Scripts_de_démarrage">Scripts de démarrage</span>
</h4>
<p>Exemple de script principal démarrant VDE :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/scripts/qemu-network-env</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
# QEMU/VDE network environment preparation script

# The IP configuration for the tap device that will be used for
# the virtual machine network:

TAP_DEV=tap0
TAP_IP=192.168.100.254
TAP_MASK=24
TAP_NETWORK=192.168.100.0

# Host interface
NIC=eth0

case "$1" in
  start)
        echo -n "Starting VDE network for QEMU: "

        # If you want tun kernel module to be loaded by script uncomment here
	#modprobe tun 2&gt;/dev/null
	## Wait for the module to be loaded
 	#while ! lsmod | grep -q "^tun"; do echo "Waiting for tun device"; sleep 1; done

        # Start tap switch
        vde_switch -tap "$TAP_DEV" -daemon -mod 660 -group users

        # Bring tap interface up
        ip address add "$TAP_IP"/"$TAP_MASK" dev "$TAP_DEV"
        ip link set "$TAP_DEV" up

        # Start IP Forwarding
        echo "1" &gt; /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE
        ;;
  stop)
        echo -n "Stopping VDE network for QEMU: "
        # Delete the NAT rules
        iptables -t nat -D POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE

        # Bring tap interface down
        ip link set "$TAP_DEV" down

        # Kill VDE switch
        pgrep vde_switch | xargs kill -TERM
        ;;
  restart|reload)
        $0 stop
        sleep 1
        $0 start
        ;;
  *)
        echo "Usage: $0 {start|stop|restart|reload}"
        exit 1
esac
exit 0
</pre>
<p>Exemple de service systemd utilisant le script ci-dessus :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu-network-env.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Manage VDE Switch

[Service]
Type=oneshot
ExecStart=/etc/systemd/scripts/qemu-network-env start
ExecStop=/etc/systemd/scripts/qemu-network-env stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</pre>
<p>Changez les permissions pour que <code>qemu-network-env</code> soit <a href="../fr/Help:Reading.html#Rendre_ex%C3%A9cutable" class="mw-redirect" title="Exécutable">exécutable</a>. 
</p>
<p><a href="../fr/Systemd.html#Utilisation_des_unit%C3%A9s" class="mw-redirect" title="Démarrez">Démarrez</a> <code>qemu-network-env.service</code> comme d'habitude.
</p>
<h4>
<span id="M.C3.A9thode_alternative"></span><span class="mw-headline" id="Méthode_alternative">Méthode alternative</span>
</h4>
<p>Si la méthode ci-dessus ne fonctionne pas ou si vous ne voulez pas vous embêter avec les configurations du noyau, TUN, dnsmasq, et iptables, vous pouvez faire ce qui suit pour le même résultat.
</p>
<pre># vde_switch -daemon -mod 660 -group users
# slirpvde --dhcp --daemon
</pre>
<p>Ensuite, pour démarrer la VM avec une connexion au réseau de l'hôte :
</p>
<pre>$ qemu-system-x86_64 -net nic,macaddr=52:54:00:00:EE:03 -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="Pont_VDE2">Pont VDE2</span></h3>
<p>Basé sur le graphique <a rel="nofollow" class="external text" href="https://selamatpagicikgu.wordpress.com/2011/06/08/quickhowto-qemu-networking-using-vde-tuntap-and-bridge/">tutoriel rapide : mise en réseau de qemu avec vde, tun/tap, et pont</a>. Toute machine virtuelle connectée à vde est exposée à l'extérieur. Par exemple, chaque machine virtuelle peut recevoir une configuration DHCP directement de votre routeur ADSL.
</p>
<h4><span class="mw-headline" id="Notions_de_base_2">Notions de base</span></h4>
<p>Rappelez-vous que vous avez besoin du module <code>tun</code> et du paquet <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>.
</p>
<p>Créez le périphérique vde2/tap :
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
# ip link set tap0 up
</pre>
<p>Créez un pont :
</p>
<pre># brctl addbr br0
</pre>
<p>Ajouter des périphériques :
</p>
<pre># brctl addif br0 eth0
# brctl addif br0 tap0
</pre>
<p>Et configurez l'interface du pont :
</p>
<pre># dhcpcd br0
</pre>
<h4>
<span id="Scripts_de_d.C3.A9marrage_2"></span><span class="mw-headline" id="Scripts_de_démarrage_2">Scripts de démarrage</span>
</h4>
<p>Tous les périphériques doivent être configurés. Et seul le pont a besoin d'une adresse IP. Pour les périphériques physiques sur le pont (par exemple <code>eth0</code>), cela peut être fait avec <a href="../fr/Netctl.html" title="Netctl (Français)">netctl</a> en utilisant un profil Ethernet personnalisé avec :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/netctl/ethernet-noip</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Description='A more versatile static Ethernet connection'
Interface=eth0
Connection=ethernet
IP=no</pre>
<p>Le service systemd personnalisé suivant peut être utilisé pour créer et activer une interface de connexion VDE2 pour les utilisateurs du groupe <code>users</code>.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/vde2@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Network Connectivity for %i
Wants=network.target
Before=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users
ExecStart=/usr/bin/ip link set dev %i up
ExecStop=/usr/bin/ip addr flush dev %i
ExecStop=/usr/bin/ip link set dev %i down

[Install]
WantedBy=multi-user.target</pre>
<p>Et enfin, vous pouvez créer l'interface <a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">bridge avec netctl</a>.
</p>
<h3>
<span id="Configuration_abr.C3.A9g.C3.A9e"></span><span class="mw-headline" id="Configuration_abrégée">Configuration abrégée</span>
</h3>
<p>Si vous utilisez souvent QEMU avec diverses options de réseau, vous avez probablement créé beaucoup de paires d'arguments <code>-netdev</code> et <code>-device</code>, ce qui devient assez répétitif. Vous pouvez plutôt utiliser l'argument <code>-nic</code> pour combiner <code>-netdev</code> et <code>-device</code> ensemble, de sorte que, par exemple, ces arguments :
</p>
<pre>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</pre>
<p>devient :
</p>
<pre>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</pre>
<p>Remarquez l'absence d'ID de réseau, et que le périphérique a été créé avec <code>model=</code>. La première moitié des paramètres <code>-nic</code> sont des paramètres <code>-netdev</code>, tandis que la seconde moitié (après <code>model=</code>) est liée au périphérique. Les mêmes paramètres (par exemple, <code>smb=</code>) sont utilisés. Pour désactiver complètement la mise en réseau, utilisez <code>-nic none</code>.
</p>
<p>Consultez <a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/6.0/system/net.html">documentation sur la mise en réseau de QEMU</a> pour plus d'informations sur les paramètres que vous pouvez utiliser.
</p>
<h2><span class="mw-headline" id="Carte_graphique">Carte graphique</span></h2>
<p>QEMU peut émuler le mode texte d'une carte graphique standard en utilisant l'option de ligne de commande <code>-curses</code>. Cela permet de taper du texte et de consulter la sortie texte directement dans un terminal texte. Alternativement, <code>-nographic</code> sert un but similaire.
</p>
<p>QEMU peut émuler plusieurs types de cartes VGA. Le type de carte est passé dans l'option de ligne de commande <code>-vga <i>type</i></code> et peut être <code>std</code>, <code>qxl</code>, <code>vmware</code>, <code>virtio</code>, <code>cirrus</code> ou <code>none</code>.
</p>
<h3><span class="mw-headline" id="std">std</span></h3>
<p>Avec <code>-vga std</code>, vous pouvez obtenir une résolution allant jusqu'à 2560 x 1600 pixels sans avoir besoin de pilotes invités. C'est la valeur par défaut depuis QEMU 2.2.
</p>
<h3><span class="mw-headline" id="qxl">qxl</span></h3>
<p>QXL est un pilote graphique paravirtuel avec un support 2D. Pour l'utiliser, passez l'option <code>-vga qxl</code> et installez les pilotes dans l'invité. Vous pouvez utiliser <a href="#SPICE">#SPICE</a> pour améliorer les performances graphiques en utilisant QXL.
</p>
<p>Sur les invités Linux, les modules noyau <code>qxl</code> et <code>bochs_drm</code> doivent être chargés afin d'obtenir des performances décentes.
</p>
<p>La taille par défaut de la mémoire VGA pour les périphériques QXL est de 16M, ce qui est suffisant pour gérer des résolutions allant jusqu'à QHD (2560x1440). Pour permettre des résolutions plus élevées, <a href="#Prise_en_charge_de_plusieurs_moniteurs">increase vga_memmb</a>.
</p>
<h3><span class="mw-headline" id="vmware">vmware</span></h3>
<p>Bien qu'il soit un peu bogué, il est plus performant que std et cirrus. Installez les pilotes VMware <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a></span> et <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a></span> pour les invités Arch Linux.
</p>
<h3><span class="mw-headline" id="virtio">virtio</span></h3>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> est un pilote graphique 3D paravirtuel basé sur <a rel="nofollow" class="external text" href="https://virgil3d.github.io/">virgl</a>. Actuellement en cours de développement, il ne prend en charge que les hôtes Linux très récents (&gt;= 4.4) avec <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa">mesa</a></span>. (&gt;=11.2) compilé avec l'option <code>gallium-drivers=virgl</code>.
</p>
<p>Pour activer l'accélération 3D sur le système invité, sélectionnez ce vga avec <code>-device virtio-vga-gl</code> et activez le contexte opengl dans le périphérique d'affichage avec <code>-display sdl,gl=on</code> ou <code>-display gtk,gl=on</code> pour les sorties d'affichage sdl et gtk respectivement. Une configuration réussie peut être confirmée en regardant le journal du noyau dans l'invité :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># dmesg | grep drm </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[drm] pci : virtio-vga détecté
[drm] accélération 3d virgl activée
</pre>
<h3><span class="mw-headline" id="cirrus">cirrus</span></h3>
<p>L'adaptateur graphique cirrus était l'adaptateur par défaut <a rel="nofollow" class="external text" href="https://wiki.qemu.org/ChangeLog/2.2#VGA">avant 2.2</a>. Il <a rel="nofollow" class="external text" href="https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">ne devrait pas</a> être utilisé sur les systèmes modernes.
</p>
<h3><span class="mw-headline" id="none">none</span></h3>
<p>C'est comme un PC qui n'a pas de carte VGA du tout. Vous ne pourriez même pas y accéder avec l'option <code>-vnc</code>. En outre, ceci est différent de l'option <code>-nographic</code> qui permet à QEMU d'émuler une carte VGA, mais désactive l'affichage SDL.
</p>
<h2><span class="mw-headline" id="SPICE">SPICE</span></h2>
<p>Le <a rel="nofollow" class="external text" href="https://www.spice-space.org/">SPICE project</a> vise à fournir une solution open source complète pour l'accès à distance aux machines virtuelles de manière transparente.
</p>
<h3>
<span id="Activation_du_support_SPICE_sur_l.27h.C3.B4te"></span><span class="mw-headline" id="Activation_du_support_SPICE_sur_l'hôte">Activation du support SPICE sur l'hôte</span>
</h3>
<p>Voici un exemple de démarrage avec SPICE comme protocole de bureau à distance, y compris la prise en charge du copier-coller depuis l'hôte :
</p>
<pre>$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>Les paramètres ont la signification suivante :
</p>
<ol>
<li>
<code>-device virtio-serial-pci</code> ajoute un périphérique virtio-serial</li>
<li>
<code>-spice port=5930,disable-ticketing=on</code> définit le port TCP <code>5930</code> pour l'écoute des canaux spice et permet au client de se connecter sans authentification<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> L'utilisation de <a href="https://en.wikipedia.org/wiki/Unix_socket" class="extiw" title="wikipedia:Unix socket">Unix sockets</a> au lieu des ports TCP n'implique pas l'utilisation de la pile réseau sur le système hôte. Elle n'implique pas que les paquets soient encapsulés et décapsulés pour utiliser le réseau et le protocole correspondant. Les sockets sont identifiés uniquement par les inodes du disque dur. Il est donc considéré comme meilleur pour les performances. Utilisez plutôt <code>-spice unix=on,addr=/tmp/vm_spice.socket,disable-ticketing=on</code>.</div>
</li>
<li>
<code>-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0</code> ouvre un port pour spice vdagent dans le périphérique virtio-serial,</li>
<li>
<code>-chardev spicevmc,id=spicechannel0,name=vdagent</code> ajoute une chardev spicevmc pour ce port. Il est important que l'option <code>chardev=</code> du dispositif <code>virtserialport</code> corresponde à l'option <code>id=</code> donnée à l'option <code>chardev</code> (<code>spicechannel0</code> dans cet exemple). Il est également important que le nom du port soit <code>com.redhat.spice.0</code>, car c'est l'espace de nom que vdagent recherche dans l'invité. Et enfin, spécifiez <code>name=vdagent</code> pour que spice sache à quoi sert ce canal.</li>
</ol>
<h3>
<span id="Se_connecter_.C3.A0_l.27invit.C3.A9_avec_un_client_SPICE"></span><span class="mw-headline" id="Se_connecter_à_l'invité_avec_un_client_SPICE">Se connecter à l'invité avec un client SPICE</span>
</h3>
<p>Un client SPICE est nécessaire pour se connecter à l'invité. Dans Arch, les clients suivants sont disponibles :
</p>
<p><b>virt-viewer</b> — client SPICE recommandé par les développeurs du protocole, un sous-ensemble du projet virt-manager.
</p>
<dl><dd>
<a rel="nofollow" class="external free" href="https://virt-manager.org/">https://virt-manager.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>
</dd></dl>
<p><b>spice-gtk</b> — Client SPICE GTK, un sous-ensemble du projet SPICE. Intégré dans d'autres applications en tant que widget.
</p>
<dl><dd>
<a rel="nofollow" class="external free" href="https://www.spice-space.org/">https://www.spice-space.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span>
</dd></dl>
<p>Pour les clients fonctionnant sur smartphone ou sur d'autres plateformes, reportez-vous à la section <i>Autres clients</i> de <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">spice-space download</a>.
</p>
<h4>
<span id="Ex.C3.A9cution_manuelle_d.27un_client_SPICE"></span><span class="mw-headline" id="Exécution_manuelle_d'un_client_SPICE">Exécution manuelle d'un client SPICE</span>
</h4>
<p>Une façon de se connecter à un invité écoutant sur le socket Unix <code>/tmp/vm_spice.socket</code> est d'exécuter manuellement le client SPICE en utilisant <code>$ remote-viewer spice+unix:///tmp/vm_spice.socket</code> ou <code>$ spicy --uri="spice+unix:///tmp/vm_spice.socket"</code>, selon le client souhaité. Comme QEMU en mode SPICE agit de la même manière qu'un serveur de bureau à distance, il peut être plus pratique d'exécuter QEMU en mode daemon avec le paramètre <code>-daemonize</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Pour se connecter à l'invité par tuning SSH, le type de commande suivant peut être utilisé : <pre>$ ssh -fL 5999:localhost:5930 <i>my.domain.org</i> sleep 10 ; spicy -h 127.0.0.1 -p 5999</pre>
<p>Cet exemple connecte <i>spicy</i> au port local <code>5999</code> qui est transféré par SSH au serveur SPICE de l'invité situé à l'adresse <i>my.domain.org</i>, port <code>5930</code>.
Notez l'option <code>-f</code> qui demande à ssh d'exécuter la commande <code>sleep 10</code> en arrière-plan. De cette façon, la session ssh s'exécute tant que le client est actif et se ferme automatiquement lorsque le client se termine.
</p>
</div>
<h4>
<span id="Ex.C3.A9cuter_un_client_SPICE_avec_QEMU"></span><span class="mw-headline" id="Exécuter_un_client_SPICE_avec_QEMU">Exécuter un client SPICE avec QEMU</span>
</h4>
<p>QEMU peut automatiquement démarrer un client SPICE avec un socket approprié, si l'affichage est défini sur SPICE avec le paramètre <code>-display spice-app</code>. Cela utilisera le client SPICE par défaut du système comme visualisateur, déterminé par vos fichiers <a href="../en/XDG_MIME_Applications.html#mimeapps.list" title="XDG MIME Applications">mimeapps.list</a>.
</p>
<h3>
<span id="Activation_du_support_SPICE_sur_l.27invit.C3.A9"></span><span class="mw-headline" id="Activation_du_support_SPICE_sur_l'invité">Activation du support SPICE sur l'invité</span>
</h3>
<p>Pour les <b>invités Arch Linux</b>, pour une meilleure prise en charge de plusieurs moniteurs ou du partage du presse-papiers, les paquets suivants doivent être installés :
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-vdagent">spice-vdagent</a></span> : Agent Spice client xorg qui permet le copier/coller entre le client et la session X et plus encore.</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-qxl">xf86-video-qxl</a></span> : Pilote vidéo Xorg X11 qxl</li>
</ul>
<p>Pour les invités sous <b>d'autres systèmes d'exploitation</b>, référez-vous à la section <i>Invité</i> dans <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">téléchargement de spice-space</a>.
</p>
<h3><span class="mw-headline" id="Authentification_par_mot_de_passe_avec_SPICE">Authentification par mot de passe avec SPICE</span></h3>
<p>Si vous voulez activer l'authentification par mot de passe avec SPICE, vous devez supprimer <code>disable-ticketing</code> de l'argument <code>-spice</code> et ajouter à la place <code>password=<i>yourpassword</i></code>. Par exemple :
</p>
<pre>$ qemu-system-x86_64 -vga qxl -spice port=5900,password=<i>yourpassword</i> -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>Votre client SPICE devrait maintenant demander le mot de passe pour pouvoir se connecter au serveur SPICE.
</p>
<h3>
<span id="Communication_chiffr.C3.A9e_TLS_avec_SPICE"></span><span class="mw-headline" id="Communication_chiffrée_TLS_avec_SPICE">Communication chiffrée TLS avec SPICE</span>
</h3>
<p>Vous pouvez également configurer le chiffrement TLS pour communiquer avec le serveur SPICE. Tout d'abord, vous devez avoir un répertoire qui contient les fichiers suivants (les noms doivent être exactement comme indiqués) :
</p>
<ul>
<li>
<code>ca-cert.pem</code> : le certificat maître de l'AC.</li>
<li>
<code>server-cert.pem</code> : le certificat du serveur signé avec <code>ca-cert.pem</code>.</li>
<li>
<code>server-key.pem</code> : la clé privée du serveur.</li>
</ul>
<p>Un exemple de génération de certificats auto-signés avec votre propre CA pour votre serveur est montré dans le <a rel="nofollow" class="external text" href="https://www.spice-space.org/spice-user-manual.html#_generating_self_signed_certificates">Manuel de l'utilisateur de Spice</a>.
</p>
<p>Ensuite, vous pouvez exécuter QEMU avec SPICE comme expliqué ci-dessus mais en utilisant l'argument <code>-spice</code> suivant : <code>-spice tls-port=5901,password=<i>yourpassword</i>,x509-dir=<i>/path/to/pki_certs</i></code>, où <code><i>/path/to/pki_certs</i></code> est le chemin du répertoire qui contient les trois fichiers nécessaires montrés précédemment.
</p>
<p>Il est maintenant possible de se connecter au serveur en utilisant <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span> :
</p>
<pre>$ remote-viewer spice://<i>hostname</i>?tls-port=5901 --spice-ca-file=<i>/path/to/ca-cert.pem</i> --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<p>N'oubliez pas que le paramètre <code>--spice-host-subject</code> doit être défini en fonction de votre sujet <code>server-cert.pem</code>. Vous devez également copier <code>ca-cert.pem</code> sur chaque client pour vérifier le certificat du serveur.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Vous pouvez obtenir l'objet du certificat du serveur dans le format correct de <code>--spice-host-subject</code> (avec les entrées séparées par des virgules) en utilisant la commande suivante : <pre>$ openssl x509 -noout -subject -in server-cert.pem | cut -d' ' -f2- | sed 's/\///' | sed 's/\/,/g'</pre>
</div>
<p>La commande équivalente <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span> est :
</p>
<pre>$ spicy -h <i>hostname</i> -s 5901 --spice-ca-file=ca-cert.pem --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<h2><span class="mw-headline" id="VNC">VNC</span></h2>
<p>On peut ajouter l'option <code>-vnc :<i>X</i></code> pour que QEMU redirige l'écran VGA vers la session VNC. Remplacez <code><i>X</i></code> par le numéro de l'écran (0 écoutera alors sur 5900, 1 sur 5901...).
</p>
<pre>$ qemu-system-x86_64 -vnc :0
</pre>
<p>Un exemple est également fourni dans la section <a href="#D%C3%A9marrer_des_machines_virtuelles_QEMU_au_d%C3%A9marrage">#Démarrer des machines virtuelles QEMU au démarrage</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> La configuration par défaut du serveur VNC n'utilise aucune forme d'authentification. Tout utilisateur peut se connecter à partir de n'importe quel hôte.</div>
<h3><span class="mw-headline" id="Authentification_par_mot_de_passe_de_base">Authentification par mot de passe de base</span></h3>
<p>Un mot de passe d'accès peut être configuré facilement en utilisant l'option <code>password</code>. Le mot de passe doit être indiqué dans le moniteur QEMU et la connexion n'est possible que lorsque le mot de passe est fourni.
</p>
<pre>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<p>Dans le moniteur QEMU, le mot de passe est défini en utilisant la commande <code>change vnc password</code> et en indiquant ensuite le mot de passe.
</p>
<p>La ligne de commande suivante lance directement vnc avec un mot de passe :
</p>
<pre>$ printf "change vnc password\n%s\n" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Le mot de passe est limité à 8 caractères et peut être deviné par une attaque par force brute. Une protection plus élaborée est fortement recommandée pour les réseaux publics.</div>
<h2><span class="mw-headline" id="Audio">Audio</span></h2>
<h3>
<span id="Cr.C3.A9er_un_backend_audio"></span><span class="mw-headline" id="Créer_un_backend_audio">Créer un backend audio</span>
</h3>
<p>L'option <code>-audiodev</code> définit le pilote dubackend audio et ses options. La liste des pilotes audio disponibles et leurs paramètres optionnels est détaillée dans la page de manuel de <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span>.
</p>
<p>Au minimum, vous devez choisir un backend et définir un id, pour <a href="../en/PulseAudio.html" class="mw-redirect" title="PulseAudio (Français)">PulseAudio</a> par exemple : 
</p>
<pre>-audiodev pa,id=snd0
</pre>
<h3><span class="mw-headline" id="Utiliser_le_backend_audio">Utiliser le backend audio</span></h3>
<h5><span class="mw-headline" id="Intel_HD_Audio">Intel HD Audio</span></h5>
<p>Pour l'émulation Intel HD Audio, ajoutez les périphériques contrôleur et codec. Pour lister les périphériques audio Intel HDA disponibles :
</p>
<pre>$ qemu-system-x86_64 -device help | grep hda
</pre>
<p>Ajoutez le contrôleur audio: 
</p>
<pre>-device ich9-intel-hda
</pre>
<p>Ajoutez également le codec audio et mappez-le à un id de backend audio hôte: 
</p>
<pre>-device hda-output,audiodev=snd0
</pre>
<h5><span class="mw-headline" id="Intel_82801AA_AC97">Intel 82801AA AC97</span></h5>
<p>Pour l'émulation AC97, il suffit d'ajouter le périphérique de la carte audio et de l'associer à un identifiant de backend audio hôte.
</p>
<pre>-périphérique AC97, audiodev=snd0
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>Si le backend audiodev n'est pas fourni, QEMU le recherche et l'ajoute automatiquement, cela ne fonctionne que pour un seul audiodev. Par exemple, <code>-device intel-hda -device hda-duplex</code> émulera <code>intel-hda</code> sur l'invité en utilisant le backend audiodev par défaut.</li>
<li>Les pilotes émulés de carte graphique vidéo pour la machine invitée peuvent également causer un problème de qualité sonore. Testez-les un par un pour qu'ils fonctionnent. Vous pouvez lister les options possibles avec <code>qemu-system-x86_64 -h | grep vga</code>.</li>
</ul>
</div>
<h2><span class="mw-headline" id="Installation_des_pilotes_virtio">Installation des pilotes virtio</span></h2>
<p>QEMU offre aux invités la possibilité d'utiliser des périphériques bloc et réseau paravirtualisés à l'aide des pilotes <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a>, qui offrent de meilleures performances et une plus faible surcharge.
</p>
<ul><li>Un périphérique de type bloc virtio nécessite l'option <code>-drive</code> pour passer une image disque, avec le paramètre <code>if=virtio</code> :</li></ul>
<pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=<b>virtio</b>
</pre>
<ul><li>Il en va presque de même pour le réseau :</li></ul>
<pre>$ qemu-system-x86_64 -nic user,model=<b>virtio-net-pci'</b>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Ceci ne fonctionnera que si la machine invitée possède des pilotes pour les périphériques virtio. Linux en a, et les pilotes requis sont inclus dans Arch Linux, mais il n'y a aucune garantie que les périphériques virtio fonctionneront avec d'autres systèmes d'exploitation.</div>
<h3>
<span id="Pr.C3.A9parer_un_invit.C3.A9_Arch_Linux"></span><span class="mw-headline" id="Préparer_un_invité_Arch_Linux">Préparer un invité Arch Linux</span>
</h3>
<p>Pour utiliser les périphériques virtio après l'installation d'un invité Arch Linux, les modules suivants doivent être chargés dans l'invité : <code>virtio</code>, <code>virtio_pci</code>, <code>virtio_blk</code>, <code>virtio_net</code>, et <code>virtio_ring</code>. Pour les invités 32 bits, le module spécifique "virtio" n'est pas nécessaire.
</p>
<p>Si vous voulez démarrer à partir d'un disque virtio, le ramdisk initial doit contenir les modules nécessaires. Par défaut, ceci est géré par le hook <code>autodetect</code> de <a href="../en/Mkinitcpio.html" title="Mkinitcpio">mkinitcpio</a>. Sinon, utilisez le tableau <code>MODULES</code> dans <code>/etc/mkinitcpio.conf</code> pour inclure les modules nécessaires et reconstruire le ramdisk initial.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">MODULES=(virtio virtio_blk virtio_pci virtio_net)</pre>
<p>Les disques Virtio sont reconnus avec le préfixe <code> <b>v</b></code> (par exemple, <code><b>v</b>da</code>, <code><b>v</b>db</code>, etc.) ; par conséquent, des modifications doivent être apportées au moins dans <code>/etc/fstab</code> et <code>/boot/grub/grub.cfg</code> lors du démarrage à partir d'un disque virtio.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Lorsque l'on référence les disques par <a href="../fr/Persistent_block_device_naming.html#by-uuid" title="Persistent block device naming (Français)">UUID</a> dans <code>/etc/fstab</code> et dans le chargeur d'amorçage, il n'y a rien à faire.</div>
<p>Vous trouverez de plus amples informations sur la paravirtualisation avec KVM <a rel="nofollow" class="external text" href="https://www.linux-kvm.org/page/Boot_from_virtio_block_device">ici</a>.
</p>
<p>Vous pouvez également installer <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span> pour implémenter la prise en charge des commandes QMP qui amélioreront les capacités de gestion de l'hyperviseur. Après avoir installé le paquet, vous pouvez activer et démarrer le <code>qemu-guest-agent.service</code>.
</p>
<h3>
<span id="Pr.C3.A9paration_d.27un_invit.C3.A9_Windows"></span><span class="mw-headline" id="Préparation_d'un_invité_Windows">Préparation d'un invité Windows</span>
</h3>
<h4><span class="mw-headline" id="Pilotes_Virtio_pour_Windows">Pilotes Virtio pour Windows</span></h4>
<p>Windows n'est pas livré avec les pilotes virtio. Les dernières versions stables des pilotes sont régulièrement construites par Fedora, les détails sur le téléchargement des pilotes sont donnés sur <a rel="nofollow" class="external text" href="https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md">virtio-win on GitHub</a>. Dans les sections suivantes, nous utiliserons principalement le fichier ISO stable fourni ici : <a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">virtio-win.iso</a>. Vous pouvez également utiliser <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/virtio-win/">virtio-win</a></span><sup><small>AUR</small></sup>.
</p>
<h4>
<span id="Pilotes_de_p.C3.A9riph.C3.A9rique_de_bloc"></span><span class="mw-headline" id="Pilotes_de_périphérique_de_bloc">Pilotes de périphérique de bloc</span>
</h4>
<h5><span class="mw-headline" id="Nouvelle_installation_de_Windows">Nouvelle installation de Windows</span></h5>
<p>Les pilotes doivent être chargés pendant l'installation, la procédure est de charger l'image ISO avec les pilotes virtio dans un cdrom avec le disque primaire et le média d'installation ISO de Windows :
</p>
<pre>$ qemu-system-x86_64 ... \
-drive file=<i>disk_image</i>,index=0,media=disk,if=virtio \
-drive file=<i>windows.iso</i>,index=2,media=cdrom \
-drive file=<i>virtio-win.iso</i>,index=3,media=cdrom \
...
</pre>
<p>Pendant l'installation, à un moment donné, le programme d'installation de Windows demandera "Où voulez-vous installer Windows ?", il émettra un avertissement indiquant qu'aucun disque n'a été trouvé. Suivez les instructions de l'exemple ci-dessous (basé sur Windows Server 2012 R2 avec Update) .
</p>
<ul>
<li>Sélectionnez l'option <i>Load Drivers</i>.</li>
<li>Décochez la case pour <i>Masquer les pilotes qui ne sont pas compatibles avec le matériel de cet ordinateur</i>.</li>
<li>Cliquez sur le bouton Parcourir et ouvrez le CDROM pour l'iso virtio, généralement nommé "virtio-win-XX".</li>
<li>Naviguez maintenant jusqu'à <code>E:\viostor\[your-os]\d64</code>, sélectionnez-le et confirmez.</li>
</ul>
<p>Vous devriez maintenant consulter la liste de vos disques virtio, prêts à être sélectionnés, formatés et installés.
</p>
<h5><span class="mw-headline" id="Modifier_une_VM_Windows_existante_pour_utiliser_virtio">Modifier une VM Windows existante pour utiliser virtio</span></h5>
<p>Modifier une VM Windows existante pour démarrer à partir d'un disque virtio nécessite que le pilote virtio soit chargé par l'invité au moment du démarrage.
Nous devrons donc apprendre à Windows à charger le pilote virtio au démarrage avant de pouvoir démarrer une image disque en mode virtio.
</p>
<p>Pour cela, il faut d'abord créer une nouvelle image disque qui sera attachée en mode virtio et déclencher la recherche du pilote :
</p>
<pre>$ qemu-img create -f qcow2 <i>dummy.qcow2</i> 1G
</pre>
<p>Exécutez l'invité Windows original avec le disque de démarrage toujours en mode IDE, le faux disque en mode virtio et l'image ISO du pilote.
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>disk_image</i>,if=ide -drive file=<i>dummy.qcow2</i>,if=virtio -cdrom virtio-win.iso
</pre>
<p>Windows détectera le faux disque et cherchera un pilote approprié. S'il échoue, allez dans le <i>Gestionnaire de périphériques</i>, localisez le lecteur SCSI avec une icône en forme de point d'exclamation (il devrait être ouvert), cliquez sur <i>Mettre à jour le pilote</i> et sélectionnez le CD-ROM virtuel. Ne naviguez pas jusqu'au dossier du pilote dans le CD-ROM, sélectionnez simplement le lecteur de CD-ROM et Windows trouvera automatiquement le pilote approprié (testé pour Windows 7 SP1).
</p>
<p>Demandez à Windows de démarrer en mode sans échec lors de son prochain démarrage. Vous pouvez le faire en utilisant l'outil <i>msconfig.exe</i> de Windows. En mode sans échec, tous les pilotes seront chargés au démarrage, y compris le nouveau pilote virtio. Une fois que Windows sait que le pilote virtio est nécessaire au démarrage, il le mémorisera pour les démarrages futurs.
</p>
<p>Une fois que vous avez reçu l'instruction de démarrer en mode sans échec, vous pouvez éteindre la machine virtuelle et la relancer, maintenant avec le disque de démarrage attaché en mode virtio :
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>disk_image</i>,if=virtio
</pre>
<p>Vous devriez démarrer en mode sans échec avec le pilote virtio chargé, vous pouvez maintenant retourner à <i>msconfig.exe</i> pour désactiver le démarrage en mode sans échec et redémarrer Windows.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Si vous rencontrez l'écran bleu de la mort en utilisant le paramètre <code>if=virtio</code>, cela signifie probablement que le pilote du disque virtio n'est pas installé ou n'est pas chargé au démarrage, redémarrez en mode sans échec et vérifiez la configuration de votre pilote.</div>
<h4>
<span id="Pilotes_r.C3.A9seau"></span><span class="mw-headline" id="Pilotes_réseau">Pilotes réseau</span>
</h4>
<p>L'installation des pilotes réseau de virtio est un peu plus simple, il suffit d'ajouter l'argument <code>-nic</code>.
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>windows_disk_image</i>,if=virtio -nic user,model=virtio-net-pci -cdrom virtio-win.iso
</pre>
<p>Windows va détecter l'adaptateur réseau et essayer de trouver un pilote pour celui-ci. S'il échoue, allez dans le <i>Gestionnaire de périphériques</i>, localisez l'adaptateur réseau avec une icône en forme de point d'exclamation (il devrait être ouvert), cliquez sur <i>Mettre à jour le pilote</i> et sélectionnez le CD-ROM virtuel. N'oubliez pas de cocher la case qui dit de rechercher les répertoires de manière récursive.
</p>
<h4><span class="mw-headline" id="Pilote_de_ballon">Pilote de ballon</span></h4>
<p>Si vous souhaitez suivre l'état de la mémoire de votre invité (par exemple via la commande <code>virsh</code> <code>dommemstat</code>) ou modifier la taille de la mémoire de l'invité en cours d'exécution (vous ne pourrez toujours pas modifier la taille de la mémoire, mais vous pourrez limiter l'utilisation de la mémoire en gonflant le pilote ballon), vous devrez installer le pilote ballon de l'invité.
</p>
<p>Pour cela, vous devez aller dans le <i>Gestionnaire de périphériques</i>, localiser <i>PCI standard RAM Controller</i> dans <i>System devices</i> (ou un contrôleur PCI non reconnu dans <i>Other devices</i>) et choisir <i>Update driver</i>. Dans la fenêtre ouverte, vous devrez choisir <i>Browse my computer...</i> et sélectionner le CD-ROM (et n'oubliez pas de cocher la case <i>Include subdirectories</i>). Redémarrez après l'installation. Cela installera le pilote et vous pourrez gonfler le ballon (par exemple via la commande hmp <code>balloon <i>memory_size</i></code>, qui fera en sorte que le ballon prenne autant de mémoire que possible afin de réduire la taille de la mémoire disponible de l'invité à <i>memory_size</i>). Cependant, vous ne serez toujours pas en mesure de suivre l'état de la mémoire de l'invité. Pour ce faire, vous devez installer correctement le service <i>Balloon</i>. Pour cela ouvrez la ligne de commande en tant qu'administrateur, allez sur le CD-ROM, dans le répertoire <i>Balloon</i> et plus profondément, en fonction de votre système et de votre architecture. Une fois dans le répertoire <i>amd64</i> (<i>x86</i>), exécutez <code>blnsrv.exe -i</code> qui fera l'installation. Après cela, la commande <code>virsh</code> <code>dommemstat</code> devrait afficher toutes les valeurs prises en charge.
</p>
<h3>
<span id="Pr.C3.A9parer_un_invit.C3.A9_FreeBSD"></span><span class="mw-headline" id="Préparer_un_invité_FreeBSD">Préparer un invité FreeBSD</span>
</h3>
<p>Installez le port <code>emulators/virtio-kmod</code> si vous utilisez FreeBSD 8.3 ou plus jusqu'à 10.0-CURRENT où ils sont inclus dans le noyau. Après l'installation, ajoutez ce qui suit à votre fichier <code>/boot/loader.conf</code> :
</p>
<pre>virtio_load="YES"
virtio_pci_load="YES" (en anglais)
virtio_blk_load="YES"
if_vtnet_load="YES"
virtio_balloon_load="YES"</pre>
<p>Puis modifiez votre <code>/etc/fstab</code> en faisant ce qui suit :
</p>
<pre># sed -ibak "s/ada/vtbd/g" /etc/fstab
</pre>
<p>Et vérifiez que <code>/etc/fstab</code> est cohérent. Si quelque chose ne va pas, démarrez simplement sur un CD de secours et copiez <code>/etc/fstab.bak</code> vers <code>/etc/fstab</code>.
</p>
<h2><span class="mw-headline" id="Moniteur_de_QEMU">Moniteur de QEMU</span></h2>
<p>Lorsque QEMU est en cours d'exécution, une console de surveillance est fournie afin d'offrir plusieurs façons d'interagir avec la machine virtuelle en cours d'exécution. Le moniteur QEMU offre des capacités intéressantes telles que l'obtention d'informations sur la machine virtuelle en cours, le branchement à chaud de périphériques, la création d'instantanés de l'état actuel de la machine virtuelle, etc. Pour consulter la liste de toutes les commandes, exécutez <code>help</code> ou <code>?</code> dans la console du moniteur QEMU ou consultez la section correspondante de la <a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/system/monitor.html">documentation officielle QEMU</a>.
</p>
<h3>
<span id="Acc.C3.A8s_.C3.A0_la_console_de_surveillance"></span><span class="mw-headline" id="Accès_à_la_console_de_surveillance">Accès à la console de surveillance</span>
</h3>
<h4><span class="mw-headline" id="Vue_graphique">Vue graphique</span></h4>
<p>Lorsque l'option graphique par défaut <code>std</code> est utilisée, on peut accéder au moniteur QEMU en appuyant sur <code>Ctrl+Alt+2</code> ou en cliquant sur <i>View &gt; compatmonitor0</i> dans la fenêtre QEMU. Pour revenir à la vue graphique de la machine virtuelle, appuyez sur <code>Ctrl+Alt+1</code> ou cliquez sur <i>View &gt; VGA</i>.
</p>
<p>Cependant, la méthode standard d'accès au moniteur n'est pas toujours pratique et ne fonctionne pas avec toutes les sorties graphiques prises en charge par QEMU.
</p>
<h4><span class="mw-headline" id="Telnet">Telnet</span></h4>
<p>Pour activer <a href="../en/Telnet.html" title="Telnet">telnet</a>, exécutez QEMU avec le paramètre <code>-monitor telnet:127.0.0.1:<i>port</i>,server,nowait</code>. Lorsque la machine virtuelle est démarrée, vous pourrez accéder au moniteur via telnet :
</p>
<pre>$ telnet 127.0.0.1 : <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Si <code>127.0.0.1</code> est spécifié comme l'IP à écouter, il ne sera possible de se connecter au moniteur qu'à partir du même hôte sur lequel QEMU fonctionne. Si la connexion à partir d'hôtes distants est souhaitée, il faut indiquer à QEMU d'écouter <code>0.0.0.0</code> comme suit : <code>-monitor telnet:0.0.0.0:<i>port</i>,server,nowait</code>. Gardez à l'esprit qu'il est recommandé d'avoir un <a href="../fr/Category:Firewalls.html" class="mw-redirect" title="Pare-feu">pare-feu</a> configuré dans ce cas ou de s'assurer que votre réseau local est totalement digne de confiance puisque cette connexion est totalement non authentifiée et non chiffré.</div>
<h4><span class="mw-headline" id="Socket_UNIX">Socket UNIX</span></h4>
<p>Lancez QEMU avec le paramètre <code>-monitor unix:<i>socketfile</i>,server,nowait</code>. Vous pouvez ensuite vous connecter avec soit <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=socat">socat</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nmap">nmap</a></span> ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span>.
</p>
<p>Par exemple, si QEMU est lancé via :
</p>
<pre>$ qemu-system-x86_64 -monitor unix:/tmp/monitor.sock,server,nowait <i>[...]'</i>.
</pre>
<p>Il est possible de se connecter au moniteur avec :
</p>
<pre>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</pre>
<p>Ou avec :
</p>
<pre>$ nc -U /tmp/monitor.sock
</pre>
<p>Alternativement avec <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nmap">nmap</a></span> : 
</p>
<pre>$ ncat -U /tmp/monitor.sock
</pre>
<h4><span class="mw-headline" id="TCP">TCP</span></h4>
<p>Vous pouvez exposer le moniteur sur TCP avec l'argument <code>-monitor tcp:127.0.0.1 : <i>port</i>,server,nowait</code>. Ensuite, connectez-vous avec netcat, soit <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span> ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a></span> en exécutant :
</p>
<pre>$ nc 127.0.0.1 <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Pour pouvoir se connecter à la socket tcp à partir d'autres périphériques que l'hôte sur lequel QEMU est exécuté, vous devez écouter <code>0.0.0.0</code> comme expliqué dans le cas de telnet. Les mêmes avertissements de sécurité s'appliquent également dans ce cas.</div>
<h4>
<span id="E.2FS_standard"></span><span class="mw-headline" id="E/S_standard">E/S standard</span>
</h4>
<p>Il est possible d'accéder automatiquement au moniteur à partir du même terminal que celui où QEMU est exécuté en le lançant avec l'argument <code>-monitor stdio</code>.
</p>
<h3>
<span id="Envoyer_les_frappes_du_clavier_.C3.A0_la_machine_virtuelle_en_utilisant_la_console_du_moniteur"></span><span class="mw-headline" id="Envoyer_les_frappes_du_clavier_à_la_machine_virtuelle_en_utilisant_la_console_du_moniteur">Envoyer les frappes du clavier à la machine virtuelle en utilisant la console du moniteur</span>
</h3>
<p>Certaines combinaisons de touches peuvent être difficiles à exécuter sur les machines virtuelles car l'hôte les intercepte à la place dans certaines configurations (un exemple notable est la combinaison de touches <code>Ctrl+Alt+F*</code>, qui change le tty actif). Pour éviter ce problème, la combinaison de touches problématique peut être envoyée via la console du moniteur. Passez au moniteur et utilisez la commande <code>sendkey</code> pour transmettre les pressions de touche nécessaires à la machine virtuelle. Par exemple :
</p>
<pre>(qemu) sendkey ctrl-alt-f2
</pre>
<h3>
<span id="Cr.C3.A9ation_et_gestion_des_snapshots_via_la_console_du_moniteur"></span><span class="mw-headline" id="Création_et_gestion_des_snapshots_via_la_console_du_moniteur">Création et gestion des snapshots via la console du moniteur</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Cette fonctionnalité fonctionnera <b>uniquement</b> lorsque l'image disque de la machine virtuelle est au format <i>qcow2</i>. Elle ne fonctionnera pas avec les images <i>brutes</i>.</div>
<p>Il est parfois souhaitable de sauvegarder l'état actuel d'une machine virtuelle et d'avoir la possibilité de revenir à l'état de la machine virtuelle à celui d'un snapshot précédemment sauvegardé à tout moment. La console de surveillance QEMU fournit à l'utilisateur les utilitaires nécessaires pour créer des snapshots, les gérer et rétablir l'état de la machine à un snapshot sauvegardé.
</p>
<ul>
<li>Utilisez <code>savevm <i>name</i></code> pour créer un instantané avec l'étiquette <i>name</i>.</li>
<li>Utilisez <code>loadvm <i>name</i></code> pour ramener la machine virtuelle à l'état du snapshot <i>name</i>.</li>
<li>Utilisez <code>delvm <i>name</i></code> pour supprimer le snapshot marqué comme <i>name</i>.</li>
<li>Utilisez <code>info snapshots</code> pour consulter une liste des instantanés sauvegardés. Les snapshots sont identifiés à la fois par un numéro d'identification auto-incrémenté et une balise texte (définie par l'utilisateur lors de la création du snapshot).</li>
</ul>
<h3>
<span id="Ex.C3.A9cuter_la_machine_virtuelle_en_mode_immuable"></span><span class="mw-headline" id="Exécuter_la_machine_virtuelle_en_mode_immuable">Exécuter la machine virtuelle en mode immuable</span>
</h3>
<p>Il est possible d'exécuter une machine virtuelle dans un état figé de sorte que tous les changements seront supprimés lorsque la machine virtuelle est mise hors tension, simplement en exécutant QEMU avec le paramètre <code>-snapshot</code>. Lorsque l'image disque est écrite par l'invité, les changements seront enregistrés dans un fichier temporaire dans <code>/tmp</code> et seront supprimés lorsque QEMU s'arrêtera.
</p>
<p>Cependant, si une machine fonctionne en mode gelé, il est toujours possible de sauvegarder les changements dans l'image disque si on le souhaite par la suite en utilisant la console de surveillance et en exécutant la commande suivante :
</p>
<pre>(qemu) commit all
</pre>
<p>Si des snapshots sont créés lors d'une exécution en mode gelé, ils seront supprimés dès que QEMU sera quitté, à moins que les changements ne soient explicitement commités sur le disque, également.
</p>
<h3>
<span id="Options_de_pause_et_d.27alimentation_via_la_console_du_moniteur"></span><span class="mw-headline" id="Options_de_pause_et_d'alimentation_via_la_console_du_moniteur">Options de pause et d'alimentation via la console du moniteur</span>
</h3>
<p>Certaines opérations d'une machine physique peuvent être émulées par QEMU en utilisant certaines commandes de la console de surveillance :
</p>
<ul>
<li>
<code>system_powerdown</code> enverra une demande d'arrêt ACPI à la machine virtuelle. Cet effet est similaire au bouton d'alimentation dans une machine physique.</li>
<li>
<code>system_reset</code> réinitialisera la machine virtuelle de manière similaire à un bouton de réinitialisation dans une machine physique. Cette opération peut entraîner une perte de données et une corruption du système de fichiers puisque la machine virtuelle n'est pas redémarrée proprement.</li>
<li>
<code>stop</code> mettra en pause la machine virtuelle.</li>
<li>
<code>cont</code> reprendra une machine virtuelle précédemment mise en pause.</li>
</ul>
<h3>
<span id="Prendre_des_captures_d.27.C3.A9cran_de_la_machine_virtuelle"></span><span class="mw-headline" id="Prendre_des_captures_d'écran_de_la_machine_virtuelle">Prendre des captures d'écran de la machine virtuelle</span>
</h3>
<p>Les captures d'écran de l'affichage graphique de la machine virtuelle peuvent être obtenues au format PPM en exécutant la commande suivante dans la console du moniteur :
</p>
<pre>(qemu) screendump <i>file.ppm</i>
</pre>
<h2><span class="mw-headline" id="Protocole_machine_QEMU">Protocole machine QEMU</span></h2>
<p>Le protocole machine QEMU (QMP) est un protocole basé sur JSON qui permet aux applications de contrôler une instance QEMU. Comme le <a href="#Moniteur_de_QEMU">#Moniteur de QEMU</a>, il offre des moyens d'interagir avec une machine en fonctionnement et le protocole JSON permet de le faire de manière programmatique. La description de toutes les commandes QMP se trouve dans <a rel="nofollow" class="external text" href="https://raw.githubusercontent.com/coreos/qemu/master/qmp-commands.hx">qmp-commands</a>.
</p>
<h3>
<span id="D.C3.A9marrer_QMP"></span><span class="mw-headline" id="Démarrer_QMP">Démarrer QMP</span>
</h3>
<p>La manière habituelle de contrôler l'invité en utilisant le protocole QMP, est d'ouvrir un socket TCP lors du lancement de la machine en utilisant l'option <code>-qmp</code>. Ici, on utilise par exemple le port TCP 4444 :
</p>
<pre>$ qemu-system-x86_64 <i>[...]</i> -qmp tcp:localhost:4444,server,nowait
</pre>
<p>Ensuite, une façon de communiquer avec l'agent QMP est d'utiliser <a href="../en/Network_tools.html#Netcat" class="mw-redirect" title="Netcat">netcat</a> :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">nc localhost 4444</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"QMP" : {"version" : {"qemu" : {"micro" : 0, "minor" : 1, "major" : 3}, "package" : ""}, "capabilities" : []} } </pre>
<p>À ce stade, la seule commande qui peut être reconnue est <code>qmp_capabilities</code>, de sorte que QMP passe en mode commande. Type :
</p>
<pre>{"execute" : "qmp_capabilities"}
</pre>
<p>Maintenant, QMP est prêt à recevoir des commandes, pour récupérer la liste des commandes reconnues, utilisez :
</p>
<pre>{"execute" : "query-commands"}
</pre>
<h3>
<span id="Fusion_en_direct_de_l.27image_enfant_dans_l.27image_parent"></span><span class="mw-headline" id="Fusion_en_direct_de_l'image_enfant_dans_l'image_parent">Fusion en direct de l'image enfant dans l'image parent</span>
</h3>
<p>Il est possible de fusionner un instantané en cours dans son parent en émettant une commande <code>block-commit</code>. Dans sa forme la plus simple, la ligne suivante commet l'enfant dans son parent :
</p>
<pre>{"execute" : "block-commit", "arguments" : {"device" : "<i>devicename</i>"}}
</pre>
<p>À la réception de cette commande, le gestionnaire recherche l'image de base et la convertit du mode lecture seule au mode lecture-écriture, puis exécute le travail de validation.
</p>
<p>Une fois l'opération de <i>block-commit</i> terminée, l'événement <code>BLOCK_JOB_READY</code> sera émis, signalant que la synchronisation est terminée. Le travail peut alors être terminé en douceur en émettant la commande <code>block-job-complete</code> :
</p>
<pre>{"execute" : "block-job-complete", "arguments" : {"device" : "<i>devicename</i>"}}
</pre>
<p>Jusqu'à ce qu'une telle commande soit émise, l'opération <i>commit</i> reste active.
Une fois l'opération terminée avec succès, l'image de base reste en mode lecture-écriture et devient la nouvelle couche active. En revanche, l'image enfant devient invalide et il incombe à l'utilisateur de la nettoyer.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> La liste des périphériques et leurs noms peuvent être récupérés en exécutant la commande <code>query-block</code> et en analysant les résultats. Le nom du périphérique se trouve dans le champ <code>device</code>, par exemple <code>ide0-hd0</code> pour le disque dur dans cet exemple : <pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">{"execute" : "query-block"}</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"return" : [{"io-status" : "ok", "device" : "<b>ide0-hd0</b>", "locked" : false, "removable" : false, "inserted" : {"iops_rd" : 0, "detect_zeroes" : "off", "image" : {"backing-image" : {"virtual-size" : 27074281472, "filename" : "parent.qcow2", ... } </pre> </div>
<h3>
<span id="Cr.C3.A9ation_en_direct_d.27un_nouvel_instantan.C3.A9"></span><span class="mw-headline" id="Création_en_direct_d'un_nouvel_instantané">Création en direct d'un nouvel instantané</span>
</h3>
<p>Pour créer un nouvel instantané à partir d'une image en cours d'exécution, exécutez la commande :
</p>
<pre>{"execute" : "blockdev-snapshot-sync", "arguments" : {"device" : "<i>devicename</i>", "snapshot-file" : "<i>new_snapshot_name</i>.qcow2"}}
</pre>
<p>Cela crée un fichier de superposition nommé <code><i>new_snapshot_name</i>.qcow2</code> qui devient alors la nouvelle couche active.
</p>
<h2><span class="mw-headline" id="Trucs_et_astuces">Trucs et astuces</span></h2>
<h3>
<span id="Am.C3.A9liorer_les_performances_de_la_machine_virtuelle"></span><span class="mw-headline" id="Améliorer_les_performances_de_la_machine_virtuelle">Améliorer les performances de la machine virtuelle</span>
</h3>
<p>Il existe un certain nombre de techniques que vous pouvez utiliser pour améliorer les performances de la machine virtuelle. Par exemple :
</p>
<ul>
<li>Appliquez <a href="#Activation_de_KVM">#Activation de KVM</a> pour une virtualisation complète.</li>
<li>Utilisez l'option <code>-cpu host</code> pour que QEMU émule le CPU exact de l'hôte plutôt qu'un CPU plus générique.</li>
<li>Surtout pour les invités Windows, activez <a rel="nofollow" class="external text" href="https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Hyper-V enlightenments</a> : <code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>.</li>
<li>Si la machine hôte a plusieurs cœurs, assignez à l'invité plus de cœurs en utilisant l'option <code>-smp</code>.</li>
<li>Assurez-vous que vous avez attribué suffisamment de mémoire à la machine virtuelle. Par défaut, QEMU n'attribue que 128 MiB de mémoire à chaque machine virtuelle. Utilisez l'option <code>-m</code> pour attribuer plus de mémoire. Par exemple, <code>-m 1024</code> exécute une machine virtuelle avec 1024 MiB de mémoire.</li>
<li>Si les pilotes du système d'exploitation invité le prennent en charge, utilisez virtio pour les périphériques réseau et/ou de bloc, consultez <a href="#Installation_des_pilotes_virtio">#Installation des pilotes virtio</a>.</li>
<li>Utilisez les périphériques TAP au lieu de la mise en réseau en mode utilisateur, consultez <a href="#Mise_en_r%C3%A9seau_avec_tap_pour_QEMU">#Mise en réseau avec tap pour QEMU</a>.</li>
<li>Si le système d'exploitation invité écrit beaucoup sur son disque, vous pouvez bénéficier de certaines options de montage sur le système de fichiers de l'hôte. Par exemple, vous pouvez monter un système de fichiers <a href="../fr/Ext4.html" title="Ext4 (Français)">ext4</a> avec l'option <code>barrier=0</code>. Vous devez lire la documentation de toutes les options que vous modifiez, car parfois, les options d'amélioration des performances des systèmes de fichiers se font au détriment de l'intégrité des données.</li>
<li>Si vous avez une image disque brute, vous pouvez vouloir désactiver le cache : <pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=virtio,<b>cache=none</b></pre>
</li>
<li>Utiliser l'AIO native de Linux : <pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=virtio<i>,aio=native,cache.direct=on'</i></pre>
</li>
<li>Si vous exécutez simultanément plusieurs machines virtuelles qui ont toutes le même système d'exploitation installé, vous pouvez économiser de la mémoire en activant <a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)" class="extiw" title="wikipedia:Kernel SamePage Merging (KSM)">kernel same-page merging</a>. Consultez <a href="#Activation_de_KSM">#Activation de KSM</a>.</li>
<li>Dans certains cas, la mémoire peut être récupérée des machines virtuelles en cours d'exécution en exécutant un pilote de ballon de mémoire dans le système d'exploitation invité et en lançant QEMU à l'aide de <code>-device virtio-balloon</code>.</li>
<li>Il est possible d'utiliser une couche d'émulation pour un contrôleur ICH-9 AHCI (bien que cela puisse être instable). L'émulation AHCI prend en charge <a href="https://en.wikipedia.org/wiki/Native_Command_Queuing" class="extiw" title="wikipedia:Native Command Queuing">NCQ</a>, ainsi plusieurs requêtes de lecture ou d'écriture peuvent être en cours en même temps : <pre>$ qemu-system-x86_64 -drive id=disk,file=<i>disk_image</i>,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0</pre>
</li>
</ul>
<p>Consultez <a rel="nofollow" class="external free" href="https://www.linux-kvm.org/page/Tuning_KVM">https://www.linux-kvm.org/page/Tuning_KVM</a> pour plus d'informations.
</p>
<h3>
<span id="D.C3.A9marrer_des_machines_virtuelles_QEMU_au_d.C3.A9marrage"></span><span class="mw-headline" id="Démarrer_des_machines_virtuelles_QEMU_au_démarrage">Démarrer des machines virtuelles QEMU au démarrage</span>
</h3>
<h4><span class="mw-headline" id="Avec_libvirt">Avec libvirt</span></h4>
<p>Si une machine virtuelle est configurée avec <a href="../en/Libvirt.html" title="Libvirt">libvirt</a>, elle peut être configurée avec <code>virsh autostart</code> ou via l'interface graphique <i>virt-manager</i> pour démarrer au démarrage de l'hôte en allant dans les options de démarrage de la machine virtuelle et en sélectionnant "Start virtual machine on host boot up".
</p>
<h4><span class="mw-headline" id="Avec_le_service_systemd">Avec le service systemd</span></h4>
<p>Pour exécuter les VM QEMU au démarrage, vous pouvez utiliser l'unité et la configuration systemd suivantes.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=QEMU virtual machine

[Service]
Environment="haltcmd=kill -INT $MAINPID"
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/usr/bin/bash -c ${haltcmd}
ExecStop=/usr/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Ce service attendra que le port console soit libéré, ce qui signifie que la VM a été arrêtée, pour se terminer gracieusement.</div>
<p>Créez ensuite des fichiers de configuration par VM, nommés <code>/etc/conf.d/qemu.d/<i>vm_name</i></code>, avec les variables <code>args</code> et <code>haltcmd</code> définies. Exemples de configurations :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/one</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0"

haltcmd="echo 'system_powerdown' | nc localhost 7100" # ou netcat/ncat</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/two</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1"

haltcmd="ssh powermanager@vm2 sudo poweroff"</pre>
<p>La description des variables est la suivante :
</p>
<ul>
<li>
<code>args</code> - Arguments de ligne de commande QEMU à utiliser.</li>
<li>
<code>haltcmd</code> - Commande permettant d'éteindre une VM en toute sécurité. Dans le premier exemple, le moniteur QEMU est exposé via telnet en utilisant <code>-monitor telnet :..</code> et les VMs sont mises hors tension via ACPI en envoyant <code>system_powerdown</code> au moniteur avec la commande <code>nc</code>. Dans l'autre exemple, SSH est utilisé.</li>
</ul>
<p>Pour définir quelles machines virtuelles démarreront au démarrage, <a href="../fr/Systemd.html#Utilisation_des_unit%C3%A9s" class="mw-redirect" title="Activez">activez</a> l'unité systemd <code>qemu@<i>vm_name</i>.service</code>.
</p>
<h3>
<span id="Int.C3.A9gration_de_la_souris"></span><span class="mw-headline" id="Intégration_de_la_souris">Intégration de la souris</span>
</h3>
<p>Pour éviter que la souris soit saisie lors d'un clic sur la fenêtre du système d'exploitation invité, ajoutez les options <code>-usb -device usb-tablet</code>. Cela signifie que QEMU est capable de signaler la position de la souris sans avoir à la saisir. Cela remplace également l'émulation de la souris PS/2 lorsqu'elle est activée. Par exemple :
</p>
<pre>$ qemu-system-x86_64 -hda <i>disk_image</i> -m 512 -usb -device usb-tablet
</pre>
<p>Si cela ne fonctionne pas, essayez d'utiliser le paramètre <code>-vga qxl</code>, consultez également les instructions <a href="#Le_curseur_de_la_souris_est_instable_ou_erratique">#Le curseur de la souris est instable ou erratique</a>.
</p>
<h3><span class="mw-headline" id="Pass-through_host_USB_device">Pass-through host USB device</span></h3>
<p>Il est possible d'accéder au périphérique physique connecté à un port USB de l'hôte depuis l'invité. La première étape consiste à identifier où le périphérique est connecté, ce qui peut être trouvé en exécutant la commande <code>lsusb</code>. Par exemple :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ lsusb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
Bus <b>003</b> Device <b>007</b> : ID <b>0781</b>:<b>5406</b> SanDisk Corp. Cruzer Micro U3
</pre>
<p>Les sorties en gras ci-dessus seront utiles pour identifier respectivement le <i>host_bus</i> et le <i>host_addr</i> ou le <i>vendor_id</i> et le <i>product_id</i>.
</p>
<p>Dans qemu, l'idée est d'émuler un contrôleur EHCI (USB 2) ou XHCI (USB 1.1 USB 2 USB 3) avec l'option <code>-device usb-ehci,id=ehci</code> ou <code>-device qemu-xhci,id=xhci</code> respectivement, puis d'y attacher le périphérique physique avec l'option <code>-device usb-host,..</code>. Nous considérerons que <i>controller_id</i> est soit <code>ehci</code> soit <code>xhci</code> pour le reste de cette section.
</p>
<p>Ensuite, il y a deux façons de se connecter à l'USB de l'hôte avec qemu :
</p>
<ol>
<li>Identifiez le périphérique et se connecter à lui sur n'importe quel bus et adresse auquel il est attaché sur l'hôte, la syntaxe générique est : <pre>-device usb-host,bus=<i>controller_id</i>.0,vendorid=0x<i>vendor_id</i>,productid=0x<i>product_id</i></pre>Appliquée au périphérique utilisé dans l'exemple ci-dessus, elle devient:<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, vendorid=0x'<i>0781<b>,productid=0x</b>5406</i></pre>On peut également ajouter le paramètre <code>...,port=<i>port_number</i></code> à l'option précédente pour spécifier dans quel port physique du contrôleur virtuel le périphérique doit être attaché, utile dans le cas où l'on veut ajouter plusieurs périphériques usb à la VM. Une autre option est d'utiliser la nouvelle propriété <code>hostdevice</code> de <code>usb-host</code> qui est disponible depuis QEMU 5.1.0, la syntaxe est : <pre>-device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007</pre>
</li>
<li>Attachez ce qui est connecté à un bus USB et une adresse donnés, la syntaxe est:<pre>-device usb-host,bus=<i>controller_id</i>.0,hostbus=<i>host_bus</i>,host_addr=<i>host_addr</i></pre>Appliqué au bus et à l'adresse dans l'exemple ci-dessus, cela devient:<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, hostbus=<b>3</b>,hostaddr=<b>7</b></pre>
</li>
</ol>
<p>Consultez <a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/system/devices/usb.html">émulation QEMU/USB</a> pour plus d'informations.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Si vous rencontrez des erreurs de permission lors de l'exécution de QEMU, consultez <a href="../fr/Udev.html#%C3%80_propos_des_r%C3%A8gles_udev" title="Udev (Français)">udev (Français)#À propos des règles udev</a> pour savoir comment définir les permissions du périphérique.</div>
<h3><span class="mw-headline" id="Redirection_USB_avec_SPICE">Redirection USB avec SPICE</span></h3>
<p>En utilisant <a href="#SPICE">#SPICE</a>, il est possible de rediriger les périphériques USB du client vers la machine virtuelle sans avoir besoin de les spécifier dans la commande QEMU. Il est possible de configurer le nombre de slots USB disponibles pour les périphériques redirigés (le nombre de slots déterminera le nombre maximum de périphériques pouvant être redirigés simultanément). Les principaux avantages de l'utilisation de SPICE pour la redirection par rapport à la méthode <code>-usbdevice</code> mentionnée précédemment est la possibilité de remplacer à chaud les périphériques USB après le démarrage de la machine virtuelle, sans avoir besoin de l'arrêter pour supprimer les périphériques USB de la redirection ou en ajouter de nouveaux. Cette méthode de redirection USB nous permet également de rediriger les périphériques USB sur le réseau, du client au serveur. En résumé, c'est la méthode la plus flexible pour utiliser les périphériques USB dans une machine virtuelle QEMU.
</p>
<p>Nous devons ajouter un contrôleur EHCI/UHCI par slot de redirection USB disponible souhaité ainsi qu'un canal de redirection SPICE par slot. Par exemple, en ajoutant les arguments suivants à la commande QEMU que vous utilisez pour démarrer la machine virtuelle en mode SPICE, la machine virtuelle démarrera avec trois slots USB disponibles pour la redirection :
</p>
<pre>-device ich9-usb-ehci1,id=usb \
-device ich9-usb-uhci1,masterbus=usb.0,firstport=0,multifunction=on \\
-dispositif ich9-usb-uhci2,masterbus=usb.0,firstport=2 \
-device ich9-usb-uhci3,masterbus=usb.0,firstport=4 \
-chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 \
-chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 \
-chardev spicevmc,name=usbredir,id=usbredirchardev3 -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3</pre>
<p>Consultez <a rel="nofollow" class="external text" href="https://www.spice-space.org/usbredir.html">SPICE/usbredir</a> pour plus d'informations.
</p>
<p>Les deux <code>spicy</code> de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span> (<i>Entrée &gt; Sélectionner les périphériques USB pour la redirection</i>) et <code>remote-viewer</code> de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span> (<i>File &gt; USB device selection</i>) prennent en charge cette fonctionnalité. Veuillez vous assurer que vous avez installé les outils SPICE Guest Tools nécessaires sur la machine virtuelle pour que cette fonctionnalité fonctionne comme prévu (consultez la section <a href="#SPICE">#SPICE</a> pour plus d'informations).
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Ne perdez pas de vue que lorsqu'un périphérique USB est redirigé depuis le client, il ne sera pas utilisable depuis le système d'exploitation client lui-même jusqu'à ce que la redirection soit arrêtée. Il est particulièrement important de ne jamais rediriger les périphériques d'entrée (à savoir la souris et le clavier), car il sera alors difficile d'accéder aux menus du client SPICE pour rétablir la situation, car le client ne répondra pas aux périphériques d'entrée après avoir été redirigé vers la machine virtuelle.</div>
<h4><span class="mw-headline" id="Redirection_USB_automatique_avec_udev">Redirection USB automatique avec udev</span></h4>
<p>Normalement, les périphériques transférés doivent être disponibles au moment du démarrage de la VM pour être transférés. Si ce périphérique est déconnecté, il ne sera plus transféré.
</p>
<p>Vous pouvez utiliser des <a href="../fr/Udev.html#%C3%80_propos_des_r%C3%A8gles_udev" title="Udev (Français)">règles udev</a> pour attacher automatiquement un périphérique lorsqu'il est en ligne. Créez une entrée <code>hostdev</code> quelque part sur le disque. <a href="../en/File_permissions_and_attributes.html#Changing_ownership" class="mw-redirect" title="Chown">chown</a> à root pour empêcher les autres utilisateurs de la modifier.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/usr/local/hostdev-mydevice.xml</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">&lt;hostdev mode='subsystem' type='usb'&gt;
  &lt;source&gt;
    &lt;vendor id='0x03f0'/&gt;
    &lt;product id='0x4217'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</pre>
<p>Créez ensuite une règle <i>udev</i> qui attachera/détachera le périphérique :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/usr/lib/udev/rules.d/90-libvirt-mydevice</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="add", \
    SUBSYSTEM=="usb", \
    ENV{ID_VENDOR_ID}=="03f0", \
    ENV{ID_MODEL_ID}=="4217", \
    RUN+="/usr/bin/virsh attach-device GUESTNAME /usr/local/hostdev-mydevice.xml"
ACTION=="remove", \
    SUBSYSTEM=="usb", \
    ENV{ID_VENDOR_ID}=="03f0", \
    ENV{ID_MODEL_ID}=="4217", \
    RUN+="/usr/bin/virsh detach-device GUESTNAME /usr/local/hostdev-mydevice.xml"</pre>
<p><a rel="nofollow" class="external text" href="https://rolandtapken.de/blog/2011-04/how-auto-hotplug-usb-devices-libvirt-vms-update-1">Source et lecture complémentaire</a>.
</p>
<h3><span class="mw-headline" id="Activation_de_KSM">Activation de KSM</span></h3>
<p>KSM (Kernel Samepage Merging) est une fonctionnalité du noyau Linux qui permet à une application de s'enregistrer auprès du noyau pour que ses pages soient fusionnées avec d'autres processus qui s'enregistrent également pour que leurs pages soient fusionnées. Le mécanisme KSM permet aux machines virtuelles invitées de partager des pages entre elles. Dans un environnement où de nombreux systèmes d'exploitation invités sont similaires, cela peut permettre de réaliser d'importantes économies de mémoire.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Bien que KSM puisse réduire l'utilisation de la mémoire, il peut augmenter l'utilisation du CPU. Notez également que certains problèmes de sécurité peuvent survenir, consultez <a href="https://en.wikipedia.org/wiki/Kernel_same-page_merging" class="extiw" title="wikipedia:Kernel same-page merging">Wikipedia:Kernel same-page merging</a>.</div>
<p>Pour activer KSM :
</p>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<p>Pour le rendre permanent, utilisez les <a href="../fr/Systemd.html#systemd-tmpfiles_-_fichiers_temporaires" title="Systemd (Français)">fichiers temporaires de systemd</a> :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/tmpfiles.d/ksm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">w /sys/kernel/mm/ksm/run - - - - 1
</pre>
<p>Si KSM est en cours d'exécution et que des pages doivent être fusionnées (c'est-à-dire qu'au moins deux VM similaires sont en cours d'exécution), alors <code>/sys/kernel/mm/ksm/pages_shared</code> doit être différent de zéro. Consultez <a rel="nofollow" class="external free" href="https://docs.kernel.org/admin-guide/mm/ksm.html">https://docs.kernel.org/admin-guide/mm/ksm.html</a> pour plus d'informations.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Astuce:</strong> Une façon simple de consulter les performances de KSM est d'afficher le contenu de tous les fichiers du répertoire :
<pre>$ grep -r . /sys/kernel/mm/ksm/
</pre>
</div>
<h3><span class="mw-headline" id="Prise_en_charge_de_plusieurs_moniteurs">Prise en charge de plusieurs moniteurs</span></h3>
<p>Le pilote Linux QXL prend en charge quatre têtes (écrans virtuels) par défaut. Ceci peut être modifié par le paramètre noyau <code>qxl.heads=N</code>.
</p>
<p>La taille de la mémoire VGA par défaut pour les périphériques QXL est de 16M (la taille de la VRAM est de 64M). Ce n'est pas suffisant si vous souhaitez activer deux moniteurs 1920x1200 car cela nécessite 2 × 1920 × 4 (profondeur de couleur) × 1200 = 17,6 Mio de mémoire VGA. Ceci peut être modifié en remplaçant <code>-vga qxl</code> par <code>-vga none -device qxl-vga,vgamem_mb=32</code>. Si vous augmentez vgamem_mb au-delà de 64M, vous devez également augmenter l'option <code>vram_size_mb</code>.
</p>
<h3>
<span id="R.C3.A9solution_d.27affichage_personnalis.C3.A9e"></span><span class="mw-headline" id="Résolution_d'affichage_personnalisée">Résolution d'affichage personnalisée</span>
</h3>
<p>Une résolution d'affichage personnalisée peut être définie avec <code>-device VGA,edid=on,xres=1280,yres=720</code>. (consultez <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data" class="extiw" title="wikipedia:Extended Display Identification Data">EDID</a> et <a href="https://en.wikipedia.org/wiki/Display_resolution" class="extiw" title="wikipedia:Display resolution">display resolution</a>).
</p>
<h3><span class="mw-headline" id="Copier_et_coller">Copier et coller</span></h3>
<p>Une façon de partager le presse-papiers entre l'hôte et l'invité est d'activer le protocole de bureau à distance SPICE et d'accéder au client avec un client SPICE.
Il faut suivre les étapes décrites dans <a href="#SPICE">#SPICE</a>. Un invité exécuté de cette façon prendra en charge le copier-coller avec l'hôte.
</p>
<h3>
<span id="Notes_sp.C3.A9cifiques_.C3.A0_Windows"></span><span class="mw-headline" id="Notes_spécifiques_à_Windows">Notes spécifiques à Windows</span>
</h3>
<p>QEMU peut exécuter toute version de Windows, de Windows 95 à Windows 10.
</p>
<p>Il est possible d'exécuter <a href="../en/Windows_PE.html" title="Windows PE">Windows PE</a> dans QEMU.
</p>
<h4>
<span id="D.C3.A9marrage_rapide"></span><span class="mw-headline" id="Démarrage_rapide">Démarrage rapide</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Un compte administrateur est nécessaire pour modifier les paramètres d'alimentation</div>
<p>Pour les invités Windows 8 (ou ultérieur), il est préférable de désactiver l'option "Activer le démarrage rapide (recommandé)" dans les Options d'alimentation du Panneau de configuration, comme expliqué dans la [page du forum <a rel="nofollow" class="external free" href="https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html">https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html</a>] suivante, car elle provoque le blocage de l'invité lors de chaque démarrage.
</p>
<p>Le démarrage rapide peut également devoir être désactivé pour que les modifications apportées à l'option <code>-smp</code> soient correctement appliquées.
</p>
<h4>
<span id="Protocole_de_bureau_.C3.A0_distance"></span><span class="mw-headline" id="Protocole_de_bureau_à_distance">Protocole de bureau à distance</span>
</h4>
<p>Si vous utilisez un invité MS Windows, vous voudrez peut-être utiliser RDP pour vous connecter à votre VM invitée. Si vous utilisez un VLAN ou si vous n'êtes pas dans le même réseau que l'invité, utilisez :
</p>
<pre>$ qemu-system-x86_64 -nographic -nic user,hostfwd=tcp::5555-:3389
</pre>
<p>Ensuite, connectez-vous avec <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=rdesktop">rdesktop</a></span> ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=freerdp">freerdp</a></span> à l'invité. Par exemple :
</p>
<pre>$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan
</pre>
<h3>
<span id="Cloner_un_syst.C3.A8me_Linux_install.C3.A9_sur_un_.C3.A9quipement_physique"></span><span class="mw-headline" id="Cloner_un_système_Linux_installé_sur_un_équipement_physique">Cloner un système Linux installé sur un équipement physique</span>
</h3>
<p>Le système Linux installé sur un équipement physique peut être cloné pour fonctionner sur une vm QEMU. Consultez <a rel="nofollow" class="external text" href="https://coffeebirthday.wordpress.com/2018/09/14/clone-linux-system-for-qemu-virtual-machine/">Cloner le système Linux à partir du matériel pour la machine virtuelle QEMU</a>.
</p>
<h3>
<span id="Chrooter_dans_l.27environnement_arm.2Farm64_.C3.A0_partir_de_x86_64"></span><span class="mw-headline" id="Chrooter_dans_l'environnement_arm/arm64_à_partir_de_x86_64">Chrooter dans l'environnement arm/arm64 à partir de x86_64</span>
</h3>
<p>Parfois, il est plus facile de travailler directement sur une image disque plutôt que sur le dispositif réel basé sur ARM. Ceci peut être réalisé en montant une carte SD/stockage contenant la partition <i>root</i> et en s'y connectant.
</p>
<p>Un autre cas d'utilisation pour un chroot ARM est la construction de paquets ARM sur une machine x86_64. Ici, l'environnement chroot peut être créé à partir d'une image tarball de <a rel="nofollow" class="external text" href="https://archlinuxarm.org">Arch Linux ARM</a> - consultez <a rel="nofollow" class="external autonumber" href="https://nerdstuff.org/posts/2020/2020-003_simplest_way_to_create_an_arm_chroot/">[3]</a> pour une description détaillée de cette approche.
</p>
<p>Dans tous les cas, à partir du chroot, il devrait être possible d'exécuter <i>pacman</i> et d'installer plus de paquets, de compiler de grandes bibliothèques, etc. Comme les exécutables sont pour l'architecture ARM, la traduction en x86 doit être effectuée par <a class="mw-selflink selflink">QEMU</a>.
</p>
<p>Installez <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> sur la machine/hôte x86_64 et <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static-binfmt">qemu-user-static-binfmt</a></span> se chargera d'enregistrer les binaires qemu au service binfmt.
</p>
<p><a href="../fr/Systemd.html#Utilisation_des_unit%C3%A9s" class="mw-redirect" title="Redémarrez">Redémarrez</a> <code>systemd-binfmt.service</code>
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> est nécessaire pour permettre l'exécution de programmes compilés provenant d'autres architectures. C'est similaire à ce qui est fourni par <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-emulators-full">qemu-emulators-full</a></span>, mais la variante "static" est requise pour chroot. Exemples :
</p>
<pre>qemu-arm-static path_to_sdcard/usr/bin/ls
qemu-aarch64-static chemin_vers_sdcard/usr/bin/ls
</pre>
<p>Ces deux lignes exécutent la commande <code>ls</code> compilée pour ARM 32 bits et ARM 64 bits respectivement. Notez que cela ne fonctionnera pas sans chrooting, car il cherchera des bibliothèques non présentes dans le système hôte.
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-user-static">qemu-user-static</a></span> permet de préfixer automatiquement l'exécutable ARM avec <code>qemu-arm-static</code> ou <code>qemu-aarch64-static</code>.
</p>
<p>Assurez-vous que le support de l'exécutable ARM est actif :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ ls /proc/sys/fs/binfmt_misc</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">].
qemu-aarch64 qemu-arm qemu-cris qemu-microblaze qemu-mipsel qemu-ppc64 qemu-riscv64 qemu-sh4 qemu-sparc qemu-sparc64 status
qemu-alpha qemu-armeb qemu-m68k qemu-mips qemu-ppc qemu-ppc64abi32 qemu-s390x qemu-sh4eb qemu-sparc32plus register
</pre>
<p>Chaque exécutable doit être listé.
</p>
<p>S'il n'est pas actif, <a href="../fr/Systemd.html#Utilisation_des_unit%C3%A9s" class="mw-redirect" title="Redémarrez">redémarrez</a> <code>systemd-binfmt.service</code>.
</p>
<p>Montez la carte SD sur <code>/mnt/sdcard</code>. (le nom du périphérique peut être différent).
</p>
<pre># mkdir -p /mnt/sdcard
# mount /dev/mmcblk0p2 /mnt/sdcard
</pre>
<p>Montez la partition de démarrage si nécessaire (encore une fois, utilisez le nom de périphérique approprié) :
</p>
<pre># mount /dev/mmcblk0p1 /mnt/sdcard/boot
</pre>
<p>Enfin, <i>chroot</i> dans la racine de la carte SD comme décrit dans <a href="../fr/Chroot.html#Avec_chroot" title="Chroot (Français)">Chroot (Français)#Avec chroot</a> :
</p>
<pre># chroot /mnt/sdcard /bin/bash
</pre>
<p>Alternativement, vous pouvez utiliser <i>arch-chroot</i> à partir de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=arch-install-scripts">arch-install-scripts</a></span>, car il fournira un moyen plus facile d'obtenir un support réseau :
</p>
<pre># arch-chroot /mnt/sdcard /bin/bash
</pre>
<p>Vous pouvez également utiliser <a href="../en/Systemd-nspawn.html" title="Systemd-nspawn">systemd-nspawn</a> pour chrooter dans l'environnement ARM :
</p>
<pre># systemd-nspawn -D /mnt/sdcard -M myARMMachine --bind-ro=/etc/resolv.conf
</pre>
<p><code>--bind-ro=/etc/resolv.conf</code> est optionnel et donne un DNS réseau fonctionnel dans le chroot.
</p>
<h3>
<span id="Ne_pas_saisir_l.27entr.C3.A9e_de_la_souris"></span><span class="mw-headline" id="Ne_pas_saisir_l'entrée_de_la_souris">Ne pas saisir l'entrée de la souris</span>
</h3>
<p>Le mode tablette a pour effet secondaire de ne pas saisir l'entrée de la souris dans la fenêtre QEMU :
</p>
<pre>-usb -device usb-tablet
</pre>
<p>Cela fonctionne avec plusieurs backends <code>-vga</code> dont l'un est virtio.
</p>
<h2>
<span id="D.C3.A9pannage"></span><span class="mw-headline" id="Dépannage">Dépannage</span>
</h2>
<h3><span class="mw-headline" id="Le_curseur_de_la_souris_est_instable_ou_erratique">Le curseur de la souris est instable ou erratique</span></h3>
<p>Si le curseur saute à l'écran de manière incontrôlée, entrer ceci dans le terminal avant de démarrer QEMU peut aider :
</p>
<pre>$ export SDL_VIDEO_X11_DGAMOUSE=0
</pre>
<p>Si cela aide, vous pouvez ajouter ceci à votre fichier <code>~/.bashrc</code>.
</p>
<h3><span class="mw-headline" id="Pas_de_curseur_visible">Pas de curseur visible</span></h3>
<p>Ajoutez <code>-display default,show-cursor=on</code> aux options de QEMU pour consulter un curseur de souris.
</p>
<p>Si cela ne fonctionne toujours pas, vérifiez que vous avez configuré votre périphérique d'affichage de manière appropriée, par exemple : <code>-vga qxl</code>.
</p>
<p>Une autre option à essayer est <code>-usb -device usb-tablet</code> comme mentionné dans <a href="#Int%C3%A9gration_de_la_souris">#Intégration de la souris</a>. Cela remplace l'émulation de la souris PS/2 par défaut et synchronise l'emplacement du pointeur entre l'hôte et l'invité comme un bonus supplémentaire.
</p>
<h3>
<span id="Deux_curseurs_de_souris_diff.C3.A9rents_sont_visibles"></span><span class="mw-headline" id="Deux_curseurs_de_souris_différents_sont_visibles">Deux curseurs de souris différents sont visibles</span>
</h3>
<p>Appliquez l'astuce <a href="#Int%C3%A9gration_de_la_souris">#Intégration de la souris</a>.
</p>
<h3>
<span id="Probl.C3.A8mes_de_clavier_lors_de_l.27utilisation_de_VNC"></span><span class="mw-headline" id="Problèmes_de_clavier_lors_de_l'utilisation_de_VNC">Problèmes de clavier lors de l'utilisation de VNC</span>
</h3>
<p>Lors de l'utilisation de VNC, vous pouvez rencontrer des problèmes de clavier décrits (dans les détails sanglants) <a rel="nofollow" class="external text" href="https://www.berrange.com/posts/2010/07/04/more-than-you-or-i-ever-wanted-to-know-about-virtual-keyboard-handling/">ici</a>. La solution est de <i>ne pas</i> utiliser l'option <code>-k</code> sur QEMU, et d'utiliser <code>gvncviewer</code> de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gtk-vnc">gtk-vnc</a></span>. Consultez également le message <a rel="nofollow" class="external text" href="https://www.mail-archive.com/libvir-list@redhat.com/msg13340.html">this</a> posté sur la liste de diffusion de libvirt.
</p>
<h3>
<span id="Le_clavier_semble_cass.C3.A9_ou_les_touches_fl.C3.A9ch.C3.A9es_ne_fonctionnent_pas"></span><span class="mw-headline" id="Le_clavier_semble_cassé_ou_les_touches_fléchées_ne_fonctionnent_pas">Le clavier semble cassé ou les touches fléchées ne fonctionnent pas</span>
</h3>
<p>Si vous trouvez que certaines de vos touches ne fonctionnent pas ou "appuient" sur la mauvaise touche (en particulier, les touches fléchées), vous devez probablement spécifier votre disposition de clavier en option. Les dispositions de clavier peuvent être trouvées dans <code>/usr/share/qemu/keymaps/</code>.
</p>
<pre>$ qemu-system-x86_64 -k <i>keymap</i> <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="Impossible_de_lire_le_fichier_keymap">Impossible de lire le fichier keymap</span></h3>
<pre>qemu-system-x86_64 : -display vnc=0.0.0.0:0 : could not read keymap file : 'en'.
</pre>
<p>est causée par un <i>keymap</i> invalide passé à l'argument <code>-k</code>. Par exemple, <code>en</code> est invalide, mais <code>en-us</code> est valide - consultez <code>/usr/share/qemu/keymaps/</code>.
</p>
<h3>
<span id="L.27affichage_invit.C3.A9_s.27.C3.A9tire_lors_du_redimensionnement_de_la_fen.C3.AAtre"></span><span class="mw-headline" id="L'affichage_invité_s'étire_lors_du_redimensionnement_de_la_fenêtre">L'affichage invité s'étire lors du redimensionnement de la fenêtre</span>
</h3>
<p>Pour restaurer la taille de fenêtre par défaut, appuyez sur <code>Ctrl+Alt+u</code>.
</p>
<h3>
<span id="ioctl.28KVM_CREATE_VM.29_failed_:_16_Device_or_resource_busy"></span><span class="mw-headline" id="ioctl(KVM_CREATE_VM)_failed_:_16_Device_or_resource_busy">ioctl(KVM_CREATE_VM) failed : 16 Device or resource busy</span>
</h3>
<p>Si un message d'erreur comme celui-ci est imprimé au démarrage de QEMU avec l'option <code>-enable-kvm</code> :
</p>
<pre>ioctl(KVM_CREATE_VM) failed : 16 Périphérique ou ressource occupée
échec de l'initialisation de KVM : Périphérique ou ressource occupée
</pre>
<p>cela signifie qu'un autre <a href="../fr/Category:Hypervisors.html" title="Category:Hypervisors (Français)">hyperviseur</a> est en cours d'exécution. Il n'est pas recommandé ou possible d'exécuter plusieurs hyperviseurs en parallèle.
</p>
<h3>
<span id="message_d.27erreur_libgfapi"></span><span class="mw-headline" id="message_d'erreur_libgfapi">message d'erreur libgfapi</span>
</h3>
<p>Le message d'erreur affiché au démarrage :
</p>
<pre>Failed to open module : libgfapi.so.0 : cannot open shared object file : No such file or directory
</pre>
<p><a href="../fr/Help:Reading.html#Installation_de_paquets" class="mw-redirect" title="Installez">Installez</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=glusterfs">glusterfs</a></span> ou ignorez le message d'erreur car GlusterFS est une dépendance facultative.
</p>
<h3><span class="mw-headline" id="Panique_du_noyau_sur_les_environnements_LIVE">Panique du noyau sur les environnements LIVE</span></h3>
<p>Si vous démarrez un environnement vivant (ou mieux : si vous démarrez un système), vous pouvez rencontrer ceci :
</p>
<pre>[ end Panique du noyau - pas de synchronisation : VFS : Impossible de monter le fs racine sur un bloc inconnu(0,0)
</pre>
<p>ou tout autre processus entravant le démarrage (par exemple, impossible de décompresser initramfs, impossible de démarrer le service foo).
Essayez de démarrer la VM avec le paramètre <code>-m VALUE</code> et une quantité appropriée de RAM, si la RAM est trop faible, vous rencontrerez probablement les mêmes problèmes que ci-dessus/sans le paramètre de mémoire.
</p>
<h3>
<span id="L.27invit.C3.A9_Windows_7_souffre_d.27un_son_de_mauvaise_qualit.C3.A9"></span><span class="mw-headline" id="L'invité_Windows_7_souffre_d'un_son_de_mauvaise_qualité">L'invité Windows 7 souffre d'un son de mauvaise qualité</span>
</h3>
<p>L'utilisation du pilote audio <code>hda</code> pour l'invité Windows 7 peut entraîner un son de mauvaise qualité. Changer le pilote audio pour <code>ac97</code> en passant les arguments <code>-soundhw ac97</code> à QEMU et installer le pilote AC97 de <a rel="nofollow" class="external text" href="https://www.realtek.com/en/component/zoo/category/pc-audio-codecs-ac-97-audio-codecs-software">Realtek AC'97 Audio Codecs</a> dans l'invité peut résoudre le problème. Consultez <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=1176761#c16">Red Hat Bugzilla - Bug 1176761</a> pour plus d'informations.
</p>
<h3>
<span id="Impossible_d.27acc.C3.A9der_au_module_du_noyau_KVM_:_Permission_refus.C3.A9e"></span><span class="mw-headline" id="Impossible_d'accéder_au_module_du_noyau_KVM_:_Permission_refusée">Impossible d'accéder au module du noyau KVM : Permission refusée</span>
</h3>
<p>Si vous rencontrez l'erreur suivante :
</p>
<pre>libvirtError : internal error : process exited while connecting to monitor : Could not access KVM kernel module : Permission refusée failed to initialize KVM : Permission refusée
</pre>
<p>Systemd 234 attribue un ID dynamique pour le groupe <code>kvm</code> (consultez <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/54943">FS#54943</a>). Pour éviter cette erreur, vous devez éditer le fichier <code>/etc/libvirt/qemu.conf</code> et changer la ligne avec <code>group = "78"</code> en <code>group = "kvm"</code>.
</p>
<h3>
<span id=".22System_Thread_Exception_Not_Handled.22_lors_du_d.C3.A9marrage_d.27une_VM_Windows"></span><span class="mw-headline" id="&quot;System_Thread_Exception_Not_Handled&quot;_lors_du_démarrage_d'une_VM_Windows">"System Thread Exception Not Handled" lors du démarrage d'une VM Windows</span>
</h3>
<p>Les invités Windows 8 ou Windows 10 peuvent soulever une exception de compatibilité générique au démarrage, à savoir "System Thread Exception Not Handled", qui tend à être causée par des pilotes hérités agissant étrangement sur des machines réelles. Sur les machines KVM, ce problème peut généralement être résolu en définissant le modèle de CPU sur <code>core2duo</code>.
</p>
<h3>
<span id="Certains_jeux.2Fapplications_Windows_se_plantent.2Fprovoquent_un_.C3.A9cran_bleu"></span><span class="mw-headline" id="Certains_jeux/applications_Windows_se_plantent/provoquent_un_écran_bleu">Certains jeux/applications Windows se plantent/provoquent un écran bleu</span>
</h3>
<p>Il arrive que des applications exécutées dans la VM se plantent de manière inattendue, alors qu'elles fonctionneraient normalement sur une machine physique. Si, lors de l'exécution de <code>dmesg -wH</code> en tant que root, vous rencontrez une erreur mentionnant <code>MSR</code>, la raison de ces plantages est que KVM injecte une <a href="https://en.wikipedia.org/wiki/General_protection_fault" class="extiw" title="wikipedia:General protection fault">General protection fault</a> (GPF) lorsque l'invité tente d'accéder à des <a href="https://en.wikipedia.org/wiki/Model-specific_register" class="extiw" title="wikipedia:Model-specific register">Model-specific registers</a> non pris en charge. (MSRs) - cela entraîne souvent le plantage des applications/OS invités. Un certain nombre de ces problèmes peuvent être résolus en passant l'option <code>ignore_msrs=1</code> au module KVM, qui ignorera les MSRs non implémentés.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/modprobe.d/kvm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
options kvm ignore_msrs=1
...</pre>
<p>Cas où l'ajout de cette option peut aider :
</p>
<ul>
<li>GeForce Experience se plaignant de la présence d'un CPU non pris en charge.</li>
<li>StarCraft 2 et L.A. Noire affichent un écran bleu fiable sous Windows 10 avec <code>KMODE_EXCEPTION_NOT_HANDLED</code>. Les informations de l'écran bleu n'identifient pas de fichier pilote dans ces cas.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attention:</strong> Bien que cela soit normalement sans danger et que certaines applications puissent ne pas fonctionner sans cela, ignorer silencieusement des accès MSR inconnus pourrait potentiellement casser d'autres logiciels dans la VM ou d'autres VM. </div>
<h3>
<span id="Les_applications_dans_la_VM_subissent_des_retards_importants_ou_prennent_beaucoup_de_temps_.C3.A0_d.C3.A9marrer"></span><span class="mw-headline" id="Les_applications_dans_la_VM_subissent_des_retards_importants_ou_prennent_beaucoup_de_temps_à_démarrer">Les applications dans la VM subissent des retards importants ou prennent beaucoup de temps à démarrer</span>
</h3>
<p>Cela peut être dû à une entropie disponible insuffisante dans la VM. Envisagez d'autoriser l'invité à accéder au pool d'entropie des hôtes en ajoutant un <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/VirtIORNG">VirtIO RNG device</a> à la VM, ou en installant un daemon de génération d'entropie tel que <a href="../en/Haveged.html" title="Haveged">Haveged</a>.
</p>
<p>Anecdotiquement, OpenSSH prend un certain temps avant de commencer à accepter des connexions lorsque l'entropie est insuffisante, sans que les journaux ne révèlent pourquoi.
</p>
<h3>
<span id="Latence_.C3.A9lev.C3.A9e_des_interruptions_et_microstuttering"></span><span class="mw-headline" id="Latence_élevée_des_interruptions_et_microstuttering">Latence élevée des interruptions et microstuttering</span>
</h3>
<p>Ce problème se manifeste par de petites pauses (bégaiements) et est particulièrement visible dans les applications à forte intensité graphique, comme les jeux.
</p>
<ul>
<li>L'une des causes est les fonctions d'économie d'énergie du processeur, qui sont contrôlées par la <a href="../fr/CPU_frequency_scaling.html" title="CPU frequency scaling (Français)">modification de la fréquence du processeur</a>. Changez cette valeur en <code>performance</code> pour tous les cœurs du processeur.</li>
<li>Une autre cause possible est les entrées PS/2. Passez des entrées PS/2 aux entrées Virtio, consultez <a href="../en/PCI_passthrough_via_OVMF.html#Passing_keyboard/mouse_via_Evdev" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Passing keyboard/mouse via Evdev</a>.</li>
</ul>
<h3>
<span id="La_vid.C3.A9o_QXL_cause_une_basse_r.C3.A9solution"></span><span class="mw-headline" id="La_vidéo_QXL_cause_une_basse_résolution">La vidéo QXL cause une basse résolution</span>
</h3>
<p>QEMU 4.1.0 a introduit une régression où la vidéo QXL peut retomber à de basses résolutions, lorsqu'elle est affichée via spice.  <a rel="nofollow" class="external autonumber" href="https://bugs.launchpad.net/qemu/+bug/1843151">[4]</a> Par exemple, lorsque KMS démarre, la résolution du texte peut devenir aussi basse que 4x10 caractères.  Lorsque vous essayez d'augmenter la résolution de l'interface graphique, elle peut passer à la résolution la plus faible prise en charge.
</p>
<p>Comme solution de contournement, créez votre périphérique sous cette forme :
</p>
<pre>-device qxl-vga,max_outputs=1...
</pre>
<h3><span class="mw-headline" id="Hang_pendant_VM_initramfs">Hang pendant VM initramfs</span></h3>
<p>Linux 5.2.11 a introduit une régression KVM où, dans certaines circonstances, une VM peut se bloquer de manière permanente pendant la phase de démarrage précoce, lorsque l'initramfs est chargé ou exécuté.  <a rel="nofollow" class="external autonumber" href="https://lore.kernel.org/kvm/CA+X5Wn4CbU305tDeu4UM=rBEzVyVgf0+YLsx70RtUJMZCFhXXw@mail.gmail.com/">[5]</a>  Linux 5.3 a corrigé la régression.  L'hôte montre que qemu utilise 100% du CPU * nombre de CPU virtuels.  Le cas rapporté est celui d'un hôte utilisant l'hyperthreading, et d'une VM à qui l'on donne plus que les <code>nproc</code>}/2 CPU virtuels de l'hôte.  On ignore quelles circonstances exactes déclenchent la suppression d'une région de mémoire par l'un des threads pour provoquer ce problème.  Les solutions de contournement sont les suivantes :
</p>
<ul>
<li>Mettre à jour vers Linux 5.3.</li>
<li>Mise à jour vers Linux 5.2.10.</li>
<li>Jusqu'à ce que le problème soit résolu, essayez de ne pas donner à la VM plus que les <code>nproc</code>/2 CPU virtuels de l'hôte.</li>
<li>Compilation personnalisée de Linux, rétablissement du commit 2ad350fb4c (notez que cela réintroduit une régression déclenchée lors de la suppression d'un memslot).</li>
</ul>
<h3>
<span id="La_VM_ne_d.C3.A9marre_pas_lorsqu.27on_utilise_un_OVMF_activ.C3.A9_par_Secure_Boot"></span><span class="mw-headline" id="La_VM_ne_démarre_pas_lorsqu'on_utilise_un_OVMF_activé_par_Secure_Boot">La VM ne démarre pas lorsqu'on utilise un OVMF activé par Secure Boot</span>
</h3>
<p><code>/usr/share/edk2-ovmf/x64/OVMF_CODE.secboot.fd</code> de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=edk2-ovmf">edk2-ovmf</a></span> est construit avec le support <a href="https://en.wikipedia.org/wiki/System_Management_Mode" class="extiw" title="wikipedia:System Management Mode">SMM</a>. Si le support S3 n'est pas pris en charge dans la VM, la VM peut ne pas démarrer du tout.
</p>
<p>Ajoutez l'option <code>-global ICH9-LPC.disable_s3=1</code> à la commande <i>qemu</i>.
</p>
<p>Consultez <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/59465">FS#59465</a> et <a rel="nofollow" class="external free" href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/README">https://github.com/tianocore/edk2/blob/master/OvmfPkg/README</a> pour plus de détails et les options requises pour utiliser Secure Boot dans QEMU.
</p>
<h3>
<span id="Les_interruptions_du_CPU_invit.C3.A9_ne_se_d.C3.A9clenchent_pas"></span><span class="mw-headline" id="Les_interruptions_du_CPU_invité_ne_se_déclenchent_pas">Les interruptions du CPU invité ne se déclenchent pas</span>
</h3>
<p>Si vous écrivez votre propre système d'exploitation en suivant le <a rel="nofollow" class="external text" href="https://wiki.osdev.org/">OSDev wiki</a>, ou si vous vous promenez simplement dans le code d'assemblage de l'architecture invitée en utilisant l'interface <code>gdb</code> de QEMU en utilisant l'option <code>-s</code>, il est utile de savoir que de nombreux émulateurs, y compris QEMU, implémentent généralement certaines interruptions du CPU laissant de nombreuses interruptions matérielles non implémentées. Une façon de savoir si votre code déclenche une interruption, est d'utiliser :
</p>
<pre>-d int
</pre>
<p>pour activer l'affichage des interruptions/exceptions sur stdout.
</p>
<p>Pour consulter les autres fonctionnalités de débogage des invités que QEMU a à offrir, consultez :
</p>
<pre>qemu-system-x86_64 -d help
</pre>
<p>ou remplacez <code>x86_64</code> par l'architecture invitée de votre choix.
</p>
<h2><span class="mw-headline" id="Voir_aussi">Voir aussi</span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://qemu.org">Site web officiel de QEMU</a></li>
<li><a rel="nofollow" class="external text" href="https://www.linux-kvm.org">Site officiel de KVM</a></li>
<li><a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/6.0/">Documentation utilisateur de l'émulateur QEMU</a></li>
<li><a href="https://en.wikibooks.org/wiki/QEMU" class="extiw" title="wikibooks:QEMU">QEMU Wikibook</a></li>
<li>
<a rel="nofollow" class="external text" href="http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu">Hardware virtualization with QEMU</a> par AlienBOB (dernière mise à jour en 2008)</li>
<li>
<a rel="nofollow" class="external text" href="http://blog.falconindy.com/articles/build-a-virtual-army.html">Construire une armée virtuelle</a> par Falconindy</li>
<li><a rel="nofollow" class="external text" href="https://git.qemu.org/?p=qemu.git;a=tree;f=docs">Derniers docs</a></li>
<li><a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/">QEMU sous Windows</a></li>
<li><a href="https://en.wikipedia.org/wiki/Qemu" class="extiw" title="wikipedia:Qemu">Wikipedia</a></li>
<li><a href="https://wiki.debian.org/QEMU" class="extiw" title="debian:QEMU">Debian Wiki - QEMU</a></li>
<li>
<a rel="nofollow" class="external text" href="https://people.gnome.org/~markmc/qemu-networking.html">La mise en réseau de QEMU sur gnome.org</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2022-09-22 ⓘ]</sup>
</li>
<li><a rel="nofollow" class="external text" href="http://bsdwiki.reedmedia.net/wiki/networking_qemu_virtual_bsd_systems.html">Mise en réseau de systèmes BSD virtuels avec QEMU</a></li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/hurd/hurd/running/qemu.html">QEMU sur gnu.org</a></li>
<li><a rel="nofollow" class="external text" href="https://wiki.freebsd.org/qemu">QEMU sur FreeBSD en tant qu'hôte</a></li>
<li>
<a rel="nofollow" class="external text" href="https://wiki.mikejung.biz/KVM_/_Xen">Guide d'optimisation des machines virtuelles KVM/QEMU Virtio et SSD</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2022-09-22 ⓘ]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virt/part-virt-qemu.html">Gérer les machines virtuelles avec QEMU - documentation openSUSE</a><sup title="Last check status: 404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2024-07-30 ⓘ]</sup>.</li>
<li>
<a rel="nofollow" class="external text" href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaat/liaatkvm.htm">KVM sur le centre de connaissances IBM</a> * <a rel="nofollow" class="external text" href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaat/liaatkvm.htm">KVM sur le centre de connaissances IBM</a>.</li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../fr/Category:Emulation.html" title="Category:Emulation (Français)">Emulation (Français)</a></li>
<li><a href="../fr/Category:Hypervisors.html" title="Category:Hypervisors (Français)">Hypervisors (Français)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../fr/Category:Pages_or_sections_flagged_with_Template:Translateme.html" title="Category:Pages or sections flagged with Template:Translateme (Français)">Pages or sections flagged with Template:Translateme (Français)</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Accuracy.html" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
</ul>
</div>
</div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=QEMU_(Fran%C3%A7ais)&amp;oldid=813447">https://wiki.archlinux.org/index.php?title=QEMU_(Français)&amp;oldid=813447</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 30 July 2024, at 16:24.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
	<li id="footer-places-archwiki-code-of-conduct"><a href="https://terms.archlinux.org/docs/code-of-conduct/" class="extiw" title="archlinux-service-agreements:code-of-conduct">Code of conduct</a></li>
	<li id="footer-places-archwiki-terms-of-service"><a href="https://terms.archlinux.org/docs/terms-of-service/" class="extiw" title="archlinux-service-agreements:terms-of-service">Terms of service</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul>
		<li>
		<button class="cdx-button cdx-button--icon-only vector-limited-width-toggle" id=""><span class="vector-icon mw-ui-icon-fullScreen mw-ui-icon-wikimedia-fullScreen"></span>

<span>Toggle limited content width</span>
</button>
</li>
	</ul>
</div>
</body>
</html>
