<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-0 vector-feature-appearance-pinned-clientpref-1 vector-feature-night-mode-enabled skin-theme-clientpref-os vector-sticky-header-enabled vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>udev (Français) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.45.1">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0">
<link rel="search" type="application/opensearchdescription+xml" href="/rest.php/v1/search" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="https://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="skin--responsive skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Udev_Français rootpage-Udev_Français skin-vector-2022 action-view">
<a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned" data-feature-name="toc-pinned" data-pinnable-element-id="vector-toc">
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text" class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">Beginning</div>
			</a>
		</li>
		<li id="toc-Installation" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Installation">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">1</span>
				<span>Installation</span>
			</div>
		</a>
		
		<ul id="toc-Installation-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Introduction_aux_règles_udev" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Introduction_aux_r%C3%A8gles_udev">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">2</span>
				<span>Introduction aux règles udev</span>
			</div>
		</a>
		
			<button aria-controls="toc-Introduction_aux_règles_udev-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Introduction aux règles udev subsection</span>
			</button>
		
		<ul id="toc-Introduction_aux_règles_udev-sublist" class="vector-toc-list">
			<li id="toc-Exemple_de_règle_udev" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Exemple_de_r%C3%A8gle_udev">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.1</span>
					<span>Exemple de règle udev</span>
				</div>
			</a>
			
			<ul id="toc-Exemple_de_règle_udev-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Lister_les_attributs_d'un_périphérique" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Lister_les_attributs_d'un_p%C3%A9riph%C3%A9rique">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.2</span>
					<span>Lister les attributs d'un périphérique</span>
				</div>
			</a>
			
			<ul id="toc-Lister_les_attributs_d'un_périphérique-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Test_des_règles_avant_le_chargement" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Test_des_r%C3%A8gles_avant_le_chargement">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.3</span>
					<span>Test des règles avant le chargement</span>
				</div>
			</a>
			
			<ul id="toc-Test_des_règles_avant_le_chargement-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Charger_de_nouvelles_règles" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Charger_de_nouvelles_r%C3%A8gles">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.4</span>
					<span>Charger de nouvelles règles</span>
				</div>
			</a>
			
			<ul id="toc-Charger_de_nouvelles_règles-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Composantes_des_règles_udev" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Composantes_des_r%C3%A8gles_udev">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">3</span>
				<span>Composantes des règles udev</span>
			</div>
		</a>
		
			<button aria-controls="toc-Composantes_des_règles_udev-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Composantes des règles udev subsection</span>
			</button>
		
		<ul id="toc-Composantes_des_règles_udev-sublist" class="vector-toc-list">
			<li id="toc-Action_de_l'évènement" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Action_de_l'%C3%A9v%C3%A8nement">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.1</span>
					<span>Action de l'évènement</span>
				</div>
			</a>
			
			<ul id="toc-Action_de_l'évènement-sublist" class="vector-toc-list">
				<li id="toc-L'action_KOBJ_CHANGE" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#L'action_KOBJ_CHANGE">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.1.1</span>
					<span>L'action KOBJ_CHANGE</span>
				</div>
			</a>
			
			<ul id="toc-L'action_KOBJ_CHANGE-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
	</ul>
	</li>
	<li id="toc-udisks" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#udisks">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">4</span>
				<span>udisks</span>
			</div>
		</a>
		
		<ul id="toc-udisks-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Trucs_et_astuces" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Trucs_et_astuces">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">5</span>
				<span>Trucs et astuces</span>
			</div>
		</a>
		
			<button aria-controls="toc-Trucs_et_astuces-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Trucs et astuces subsection</span>
			</button>
		
		<ul id="toc-Trucs_et_astuces-sublist" class="vector-toc-list">
			<li id="toc-Montage_de_lecteurs_dans_les_règles" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Montage_de_lecteurs_dans_les_r%C3%A8gles">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.1</span>
					<span>Montage de lecteurs dans les règles</span>
				</div>
			</a>
			
			<ul id="toc-Montage_de_lecteurs_dans_les_règles-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Permettre_aux_utilisateurs_normaux_d'utiliser_les_périphériques" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Permettre_aux_utilisateurs_normaux_d'utiliser_les_p%C3%A9riph%C3%A9riques">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.2</span>
					<span>Permettre aux utilisateurs normaux d'utiliser les périphériques</span>
				</div>
			</a>
			
			<ul id="toc-Permettre_aux_utilisateurs_normaux_d'utiliser_les_périphériques-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Lancer_des_processus_à_long_terme" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Lancer_des_processus_%C3%A0_long_terme">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.3</span>
					<span>Lancer des processus à long terme</span>
				</div>
			</a>
			
			<ul id="toc-Lancer_des_processus_à_long_terme-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Exécution_lorsque_le_câble_HDMI_est_branché_ou_débranché" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Ex%C3%A9cution_lorsque_le_c%C3%A2ble_HDMI_est_branch%C3%A9_ou_d%C3%A9branch%C3%A9">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.4</span>
					<span>Exécution lorsque le câble HDMI est branché ou débranché</span>
				</div>
			</a>
			
			<ul id="toc-Exécution_lorsque_le_câble_HDMI_est_branché_ou_débranché-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Exécuter_sur_le_branchement_du_câble_VGA" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Ex%C3%A9cuter_sur_le_branchement_du_c%C3%A2ble_VGA">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.5</span>
					<span>Exécuter sur le branchement du câble VGA</span>
				</div>
			</a>
			
			<ul id="toc-Exécuter_sur_le_branchement_du_câble_VGA-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Détecter_les_nouveaux_lecteurs_eSATA" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9tecter_les_nouveaux_lecteurs_eSATA">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.6</span>
					<span>Détecter les nouveaux lecteurs eSATA</span>
				</div>
			</a>
			
			<ul id="toc-Détecter_les_nouveaux_lecteurs_eSATA-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Marquer_les_ports_SATA_internes_comme_eSATA" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Marquer_les_ports_SATA_internes_comme_eSATA">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.7</span>
					<span>Marquer les ports SATA internes comme eSATA</span>
				</div>
			</a>
			
			<ul id="toc-Marquer_les_ports_SATA_internes_comme_eSATA-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Définition_de_noms_de_périphériques_statiques" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9finition_de_noms_de_p%C3%A9riph%C3%A9riques_statiques">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.8</span>
					<span>Définition de noms de périphériques statiques</span>
				</div>
			</a>
			
			<ul id="toc-Définition_de_noms_de_périphériques_statiques-sublist" class="vector-toc-list">
				<li id="toc-Périphérique_vidéo" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#P%C3%A9riph%C3%A9rique_vid%C3%A9o">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.8.1</span>
					<span>Périphérique vidéo</span>
				</div>
			</a>
			
			<ul id="toc-Périphérique_vidéo-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Imprimante" class="vector-toc-list-item vector-toc-level-3">
			<a class="vector-toc-link" href="#Imprimante">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.8.2</span>
					<span>Imprimante</span>
				</div>
			</a>
			
			<ul id="toc-Imprimante-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
		</li>
		<li id="toc-Identifier_un_disque_par_son_numéro_de_série" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Identifier_un_disque_par_son_num%C3%A9ro_de_s%C3%A9rie">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.9</span>
					<span>Identifier un disque par son numéro de série</span>
				</div>
			</a>
			
			<ul id="toc-Identifier_un_disque_par_son_numéro_de_série-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Réveil_de_la_suspension_avec_un_périphérique_USB" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#R%C3%A9veil_de_la_suspension_avec_un_p%C3%A9riph%C3%A9rique_USB">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.10</span>
					<span>Réveil de la suspension avec un périphérique USB</span>
				</div>
			</a>
			
			<ul id="toc-Réveil_de_la_suspension_avec_un_périphérique_USB-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Forcer_les_fonctionnalités_d'un_appareil_USB_à_être_réinitialisées_en_sortie_de_veille" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Forcer_les_fonctionnalit%C3%A9s_d'un_appareil_USB_%C3%A0_%C3%AAtre_r%C3%A9initialis%C3%A9es_en_sortie_de_veille">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.11</span>
					<span>Forcer les fonctionnalités d'un appareil USB à être réinitialisées en sortie de veille</span>
				</div>
			</a>
			
			<ul id="toc-Forcer_les_fonctionnalités_d'un_appareil_USB_à_être_réinitialisées_en_sortie_de_veille-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Déclenchement_d'événements" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#D%C3%A9clenchement_d'%C3%A9v%C3%A9nements">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">5.12</span>
					<span>Déclenchement d'événements</span>
				</div>
			</a>
			
			<ul id="toc-Déclenchement_d'événements-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Dépannage" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#D%C3%A9pannage">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">6</span>
				<span>Dépannage</span>
			</div>
		</a>
		
			<button aria-controls="toc-Dépannage-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Dépannage subsection</span>
			</button>
		
		<ul id="toc-Dépannage-sublist" class="vector-toc-list">
			<li id="toc-Liste_noire_de_modules" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Liste_noire_de_modules">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.1</span>
					<span>Liste noire de modules</span>
				</div>
			</a>
			
			<ul id="toc-Liste_noire_de_modules-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Sortie_de_débogage" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Sortie_de_d%C3%A9bogage">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.2</span>
					<span>Sortie de débogage</span>
				</div>
			</a>
			
			<ul id="toc-Sortie_de_débogage-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-udevd_se_bloque_au_démarrage" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#udevd_se_bloque_au_d%C3%A9marrage">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.3</span>
					<span>udevd se bloque au démarrage</span>
				</div>
			</a>
			
			<ul id="toc-udevd_se_bloque_au_démarrage-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Certains_périphériques,_qui_devraient_être_traités_comme_amovibles,_ne_le_sont_pas" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Certains_p%C3%A9riph%C3%A9riques,_qui_devraient_%C3%AAtre_trait%C3%A9s_comme_amovibles,_ne_le_sont_pas">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.4</span>
					<span>Certains périphériques, qui devraient être traités comme amovibles, ne le sont pas</span>
				</div>
			</a>
			
			<ul id="toc-Certains_périphériques,_qui_devraient_être_traités_comme_amovibles,_ne_le_sont_pas-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Problèmes_de_son_avec_certains_modules_non_chargés_automatiquement" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Probl%C3%A8mes_de_son_avec_certains_modules_non_charg%C3%A9s_automatiquement">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.5</span>
					<span>Problèmes de son avec certains modules non chargés automatiquement</span>
				</div>
			</a>
			
			<ul id="toc-Problèmes_de_son_avec_certains_modules_non_chargés_automatiquement-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Prise_en_charge_des_lecteurs_de_CD/DVD_IDE" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Prise_en_charge_des_lecteurs_de_CD/DVD_IDE">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.6</span>
					<span>Prise en charge des lecteurs de CD/DVD IDE</span>
				</div>
			</a>
			
			<ul id="toc-Prise_en_charge_des_lecteurs_de_CD/DVD_IDE-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Les_lecteurs_optiques_ont_un_ID_de_groupe_défini_sur_&quot;disk&quot;" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Les_lecteurs_optiques_ont_un_ID_de_groupe_d%C3%A9fini_sur_&quot;disk&quot;">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.7</span>
					<span>Les lecteurs optiques ont un ID de groupe défini sur "disk"</span>
				</div>
			</a>
			
			<ul id="toc-Les_lecteurs_optiques_ont_un_ID_de_groupe_défini_sur_&quot;disk&quot;-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Les_programmes_graphiques_dans_les_règles_RUN_se_bloquent_lorsqu'aucun_serveur_X_n'est_présent" class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Les_programmes_graphiques_dans_les_r%C3%A8gles_RUN_se_bloquent_lorsqu'aucun_serveur_X_n'est_pr%C3%A9sent">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.8</span>
					<span>Les programmes graphiques dans les règles RUN se bloquent lorsqu'aucun serveur X n'est présent</span>
				</div>
			</a>
			
			<ul id="toc-Les_programmes_graphiques_dans_les_règles_RUN_se_bloquent_lorsqu'aucun_serveur_X_n'est_présent-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Voir_aussi" class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Voir_aussi">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">7</span>
				<span>Voir aussi</span>
			</div>
		</a>
		
		<ul id="toc-Voir_aussi-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body" style="margin: 0">
				<header class="mw-body-header vector-page-titlebar no-font-mode-scale">
					<nav aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left" title="Table of Contents">
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading">udev (Français)</h1>
							
</header>
				<div class="vector-column-end no-font-mode-scale">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-appearance-landmark" aria-label="Appearance">
							<div id="vector-appearance-pinned-container" class="vector-pinned-container">
				<div id="vector-appearance" class="vector-appearance vector-pinnable-element">
	<div class="vector-pinnable-header vector-appearance-pinnable-header vector-pinnable-header-pinned" data-feature-name="appearance-pinned" data-pinnable-element-id="vector-appearance" data-pinned-container-id="vector-appearance-pinned-container" data-unpinned-container-id="vector-appearance-unpinned-container">
	<div class="vector-pinnable-header-label">Appearance</div>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-appearance.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-appearance.unpin">hide</button>
</div>


</div>

							</div>
		</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From ArchWiki</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content">
<div class="mw-content-ltr mw-parser-output" lang="fr" dir="ltr">
<p><span>
</span>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>État de la traduction:</strong> Cet article est la version francophone de <a href="../en/Udev.html" title="Udev">udev</a>. Date de la dernière traduction: 2022-10-05. Vous pouvez aider à synchroniser la traduction s'il y a eu des <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Udev&amp;diff=0&amp;oldid=746387">changements</a> dans la version anglaise.</div>
<div class="archwiki-template-meta-related-articles">
<p>Related articles</p>
<ul>
<li><a href="../en/Udisks.html" title="Udisks">udisks</a></li>
</ul>
</div>
<p><b>udev</b> est une interface entre le <a href="../fr/Kernel.html" title="Kernel (Français)">noyau</a> et l'utilisateur qui permet au système d'exploitation d'enregistrer la gestion des événements en espace utilisateur. Les événements décodés par le <a href="../fr/Daemons.html" class="mw-redirect" title="Daemons (Français)">daemon</a> d'<code>udev</code> sont en effet principalement déclenchés par le noyau Linux en réponse à des signaux physiques comme la connexion d'un périphérique plug-and-play. De ce point de vue, la principale fonction d'<code>udev</code> est la détection de  périphérique et la connexion de ports intelligents, ainsi que la restitution du contrôle au noyau Linux, par ex. le chargement de modules ou de <i>firmwares</i> vers le noyau. Un autre élément de cette détection consiste à ajuster les autorisations de l'appareil pour qu'il soit accessible aux utilisateurs et groupes non root.
</p>
<p>En tant que successeur de <i>devfsd</i> et de <i>hotplug</i>, <i>udev</i> gère également les nœuds de périphériques dans le répertoire <code>/dev</code> en les ajoutant, en créant des liens symboliques et en les renommant. <i>udev</i> remplace les fonctionnalités de <i>hotplug</i> et de <i>hwdetect</i>.
</p>
<p><i>udev</i> traite des événements distincts simultanément (en parallèle), ce qui entraîne une amélioration potentielle des performances par rapport aux anciens systèmes. En même temps, cela peut compliquer l'administration du système, car, par exemple, l'ordre de chargement des modules du noyau n'est pas préservé d'un démarrage à l'autre. Si la machine possède plusieurs périphériques de type bloc, cela peut se manifester sous la forme de nœuds de périphérique changeant de désignation après le redémarrage. Par exemple, si la machine possède deux disques durs, <code>/dev/sda</code> peut devenir <code>/dev/sdb</code> au prochain démarrage. Poursuivez votre lecture pour plus d'informations à ce sujet.
</p>
<meta property="mw:PageProp/toc">
<div class="mw-heading mw-heading2"><h2 id="Installation">Installation</h2></div>
<p><i>udev</i> fait partie de <a href="../en/Systemd.html" title="Systemd">systemd</a> et est donc installé par défaut. Consultez <span class="plainlinks archwiki-template-man" title="$ man 8 systemd-udevd.service"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/systemd-udevd.service.8">systemd-udevd.service(8)</a></span> pour plus d'informations.
</p>
<div class="mw-heading mw-heading2"><h2 id="Introduction_aux_règles_udev">
<span id="Introduction_aux_r.C3.A8gles_udev"></span>Introduction aux règles udev</h2></div>
<p>Les règles <i>udev</i> écrites par l'administrateur se trouvent dans <code>/etc/udev/rules.d/</code>, leur nom de fichier doit se terminer par <i>.rules</i>. Les règles <i>udev</i> fournies avec divers paquets se trouvent dans <code>/usr/lib/udev/rules.d/</code>. S'il y a deux fichiers du même nom sous <code>/usr/lib</code> et <code>/etc</code>, celui de <code>/etc</code> est prioritaire.
</p>
<p>Pour en savoir plus sur les règles <i>udev</i>, reportez-vous au manuel <span class="plainlinks archwiki-template-man" title="$ man 7 udev"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/udev.7">udev(7)</a></span>. Consultez également <a rel="nofollow" class="external text" href="https://www.reactivated.net/writing_udev_rules.html">Writing udev rules</a> et des exemples pratiques sont fournis dans le guide : <a rel="nofollow" class="external text" href="https://www.reactivated.net/writing_udev_rules.html#example-printer">Rédaction des règles udev - Exemples</a>.
</p>
<div class="mw-heading mw-heading3"><h3 id="Exemple_de_règle_udev">
<span id="Exemple_de_r.C3.A8gle_udev"></span>Exemple de règle udev</h3></div>
<p>Voici un exemple de règle qui crée un lien symbolique <code>/dev/video-cam</code> lorsqu'une webcam est connectée.
</p>
<p>Disons que cette caméra est actuellement connectée et a été chargée avec le nom de périphérique <code>/dev/video2</code>. La raison de l'écriture de cette règle est qu'au prochain démarrage, le périphérique pourrait apparaître sous un nom différent, comme <code>/dev/video0</code>.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ udevadm info --attribute-walk --path=$(udevadm info --query=path --name=/dev/video2)</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Udevadm info starts with the device specified by the devpath and then walks up the chain of parent devices.
It prints for every device found, all possible attributes in the udev rules key format.
A rule to match, can be composed by the attributes of the device and the attributes from one single parent device.

looking at device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0/video4linux/video2':
  KERNEL=="video2"
  SUBSYSTEM=="video4linux"
   ...
looking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0':
  KERNELS=="3-2:1.0"
  SUBSYSTEMS=="usb"
  ...
looking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2':
  KERNELS=="3-2"
  SUBSYSTEMS=="usb"
  ATTRS{idVendor}=="05a9"
  ATTRS{manufacturer}=="OmniVision Technologies, Inc."
  ATTRS{removable}=="unknown"
  ATTRS{idProduct}=="4519"
  ATTRS{bDeviceClass}=="00"
  ATTRS{product}=="USB Camera"
  ...</pre>
<p>Pour identifier la webcam, à partir du périphérique <i>video4linux</i>, nous utilisons <code>KERNEL=="video2"</code> et <code>SUBSYSTEM=="video4linux"</code>, puis nous remontons deux niveaux au-dessus, nous faisons correspondre la webcam en utilisant les identifiants du fournisseur et du produit du parent usb <code>SUBSYSTEMS=="usb"</code>, <code>ATTRS{idVendor}=="05a9"</code> et <code>ATTRS{idProduct}=="4519"</code>.
</p>
<p>Nous sommes maintenant en mesure de créer une règle de correspondance pour ce périphérique comme suit :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/83-webcam.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">KERNEL=="video[0-9]*", SUBSYSTEM=="video4linux", SUBSYSTEMS=="usb", ATTRS{idVendor}=="05a9", ATTRS{idProduct}=="4519", SYMLINK+="video-cam"</pre>
<p>Nous créons ici un lien symbolique en utilisant <code>SYMLINK+="video-cam"</code> mais nous pourrions facilement définir l'utilisateur <code>OWNER="john"</code> ou le groupe en utilisant <code>GROUP="video"</code> ou définir les autorisations en utilisant <code>MODE="0660"</code>. 
</p>
<p>Si vous avez l'intention d'écrire une règle pour faire quelque chose lorsqu'un périphérique est retiré, sachez que les attributs du périphérique peuvent ne pas être accessibles. Dans ce cas, vous devrez travailler avec des <a href="../en/Environment_variables.html" title="Environment variables">variables d'environnement</a> de périphérique prédéfinies. Pour surveiller ces variables d'environnement, exécutez la commande suivante tout en débranchant votre périphérique :
</p>
<pre>$ udevadm monitor --environment --udev
</pre>
<p>Dans le résultat de cette commande, vous consulterez des paires de valeurs telles que <code>ID_VENDOR_ID</code> et <code>ID_MODEL_ID</code>, qui correspondent aux attributs précédemment utilisés <code>idVendor</code> et <code>idProduct</code>. Une règle qui utilise les variables d'environnement du périphérique au lieu des attributs du périphérique peut ressembler à ceci :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/83-webcam-removed.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="remove", SUBSYSTEM=="usb", ENV{ID_VENDOR_ID}=="05a9", ENV{ID_MODEL_ID}=="4519", RUN+="<i>/path/to/your/script</i>"</pre>
<div class="mw-heading mw-heading3"><h3 id="Lister_les_attributs_d'un_périphérique">
<span id="Lister_les_attributs_d.27un_p.C3.A9riph.C3.A9rique"></span>Lister les attributs d'un périphérique</h3></div>
<p>Pour obtenir une liste de tous les attributs d'un périphérique que vous pouvez utiliser pour écrire des règles, exécutez cette commande :
</p>
<pre>$ udevadm info --attribute-walk --name=<i>device_name</i>
</pre>
<p>Remplacez <code><i>device_name</i></code> par le périphérique présent dans le système, tel que <code>/dev/sda</code> ou <code>/dev/ttyUSB0</code>.
</p>
<p>Si vous ne connaissez pas le nom du périphérique, vous pouvez également lister tous les attributs d'un chemin système spécifique :
</p>
<pre>$ udevadm info --attribute-walk --path=/sys/class/backlight/acpi_video0
</pre>
<p>Pour affiner la recherche d'un périphérique, déterminez sa classe et exécutez :
</p>
<pre>$ ls /dev/<i>class</i>/by-id
</pre>
<p>Vous pouvez utiliser le lien symbolique ou ce qu'il pointe comme entrée de <code>--name</code>. Par exemple :
</p>
<pre>$ udevadm info --attribute-walk --name=/dev/input/by-id/usb-foostan_Corne-event-kbd
</pre>
<p>Pour obtenir le chemin d'un périphérique USB nu qui ne contient aucun périphérique subordonné, vous devez utiliser le chemin complet du périphérique USB. Démarrez le mode moniteur, puis branchez le périphérique USB pour l'obtenir :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ udevadm monitor</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
KERNEL[26652.638931] add /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3 (usb)
KERNEL[26652.639153] add /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0 (usb)
...</pre>
<p>Vous pouvez simplement choisir le chemin le plus profond et <code><i>--attribute-walk</i></code> montrera de toute façon tous les attributs du parent :
</p>
<p>Vous pouvez simplement choisir le chemin le plus profond et <code><i>--attribute-walk</i></code> montrera de toute façon tous les attributs du parent :
</p>
<pre>$ udevadm info --attribute-walk --path=<i>/devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0</i>
</pre>
<div class="mw-heading mw-heading3"><h3 id="Test_des_règles_avant_le_chargement">
<span id="Test_des_r.C3.A8gles_avant_le_chargement"></span>Test des règles avant le chargement</h3></div>
<pre># udevadm test $(udevadm info --query=path --name=<i>device_name</i>) 2&gt;&amp;1
</pre>
<p>Cette procédure n'exécutera pas toutes les actions de vos nouvelles règles, mais elle traitera les règles symlink sur les périphériques existants, ce qui peut s'avérer utile si vous ne parvenez pas à les charger autrement. Vous pouvez également fournir directement le chemin du périphérique pour lequel vous voulez tester la règle <i>udev</i> :
</p>
<pre># udevadm test /sys/class/backlight/acpi_video0/
</pre>
<div class="mw-heading mw-heading3"><h3 id="Charger_de_nouvelles_règles">
<span id="Charger_de_nouvelles_r.C3.A8gles"></span>Charger de nouvelles règles</h3></div>
<p><i>udev</i> détecte automatiquement les modifications apportées aux fichiers de règles, ainsi les changements prennent effet immédiatement sans nécessiter le redémarrage de <i>udev</i>. Cependant, les règles ne sont pas redéclenchées automatiquement sur les périphériques déjà existants. Les périphériques connectables à chaud, comme les périphériques USB, devront probablement être reconnectés pour que les nouvelles règles prennent effet, ou au moins décharger et recharger les modules du noyau ohci-hcd et ehci-hcd et ainsi recharger tous les pilotes USB.
</p>
<p>Si les règles ne se rechargent pas automatiquement :
</p>
<pre># udevadm control --reload
</pre>
<p>Pour forcer manuellement <i>udev</i> à déclencher vos règles :
</p>
<pre># udevadm trigger
</pre>
<div class="mw-heading mw-heading2"><h2 id="Composantes_des_règles_udev">
<span id="Composantes_des_r.C3.A8gles_udev"></span>Composantes des règles udev</h2></div>
<div class="mw-heading mw-heading3"><h3 id="Action_de_l'évènement">
<span id="Action_de_l.27.C3.A9v.C3.A8nement"></span>Action de l'évènement</h3></div>
<p>La directive <code>ACTION==""</code> permet de limiter la règle à s'activer uniquement lorsque quelque-chose de spécifique se produit avec un appareil, habituellement lorsqu'il est branché ou débranché. Il y a huit types d'actions qu'un évènement peut avoir:
</p>
<dl>
<dt>add/remove</dt>
<dd>Lorsque le noeud d'un appareil (dans /dev/) est créé/détruit</dd>
<dt>bind/unbind</dt>
<dd>Quand un pilote est attaché/détaché d'un appareil</dd>
<dt>change</dt>
<dd>Levée manuellement par les pilotes lors d'un "changement d'état de l'appareil", sans signification normalisée</dd>
<dt>offline</dt>
<dd>Quand un appareil (souvent de la <a rel="nofollow" class="external text" href="https://docs.kernel.org/core-api/memory-hotplug.html#locking-internals">mémoire vive</a> ou des <a rel="nofollow" class="external text" href="https://docs.kernel.org/core-api/cpu_hotplug.html#user-space-notification">processeurs</a>) devient bloqué en vue d'un débranchement à chaud</dd>
<dt>online</dt>
<dd>Quand un appareil précédemment marqué "offline" redevient disponible</dd>
<dt>move</dt>
<dd>Quand un appareil (habituellement une interface réseau) est renommée, <a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/infrastructure.html#c.device_rename">idéalement jamais</a>
</dd>
</dl>
<div class="mw-heading mw-heading4"><h4 id="L'action_KOBJ_CHANGE">
<span id="L.27action_KOBJ_CHANGE"></span>L'action KOBJ_CHANGE</h4></div>
<p>Le type d'action "change" est particulier, étant donné que les pilotes ne s'en servent pas tous de la même manière, voire pas du tout. L'évènement "change" est uniquement émis lorsqu'un pilote lève un évènement vers l'espace utilisateur (<i>userspace event</i>, ou uevent) de type <code>KOBJ_CHANGE</code>. Cela signale qu'il est arrivé <i>quelque-chose</i> à l'appareil, mais il faut davantage de contexte pour déterminer quoi exactement.
</p>
<p>Puisque cet évènement est seulement lancé dans un nombre fini de circonstances, voici un tableau (pas encore exhaustif) contenant la liste des sous-systèmes qui peuvent émettre un évènement de type "change", et dans quelles conditions.
</p>
<table class="wikitable">
<tbody>
<tr>
<th>SUBSYSTEM</th>
<th>Déclencheur</th>
<th>Propriétés spécifiques à l'évènement</th>
<th>Documentation
</th>
</tr>
<tr>
<td>typec</td>
<td>Changement du alt-mode, du rôle USB-PD ou du sens de la connexion</td>
<td>Aucun</td>
<td>
</td>
</tr>
<tr>
<td>usb_role</td>
<td>Changement du sens de la connexion (pour les appareils USB OTG ou Type-C)</td>
<td>
<code>USB_ROLE_SWITCH=</code> avec la valeur <code>none</code>, <code>host</code> ou <code>device</code>, selon le nouveau rôle de l'ordinateur</td>
<td>
</td>
</tr>
<tr>
<td>block</td>
<td>Changement de carte ou de disque dans un lecteur</td>
<td>
<code>DISK_MEDIA_CHANGE=1</code> quand le contenu change ou <code>DISK_EJECT_REQUEST=1</code> juste avant l'éjection</td>
<td>
</td>
</tr>
<tr>
<td>drm</td>
<td>Appareil détecté comme "coincé" (le pilote ne peut plus rien faire car l'appareil ne répond plus)</td>
<td>
<code>WEDGED=</code> avec une liste de méthodes disponibles pour réinitialiser l'appareil, comme <code>rebind</code> ou <code>bus-reset</code>
</td>
<td>
<a rel="nofollow" class="external text" href="https://docs.kernel.org/gpu/drm-uapi.html#device-wedging">Device wedging</a>
</td>
</tr>
<tr>
<td>drm</td>
<td>Écran connecté ou déconnecté</td>
<td>
<code>HOTPLUG=1</code>, parfois aussi <code>CONNECTOR=</code> avec l'ID interne du connecteur</td>
<td>
</td>
</tr>
<tr>
<td>drm</td>
<td>Changement d'une des propriétés du connecteur (comme l'état HDCP)</td>
<td>
<code>CONNECTOR=</code> et <code>PROPERTY=</code> avec leurs ID internes respectifs</td>
<td>
</td>
</tr>
<tr>
<td>backlight</td>
<td>Changement de luminosité</td>
<td>
<code>SOURCE=</code> avec comme valeur <code>sysfs</code>, <code>hotkey</code> ou <code>unknown</code> selon ce qui a déclanché le changement</td>
<td>
</td>
</tr>
<tr>
<td>power_supply</td>
<td>Changement dans l'état de la source d'alimentation (chargent branché ou débranché, batterie en charge ou en décharge, etc.)</td>
<td>Aucun</td>
<td>
</td>
</tr>
<tr>
<td>rfkill</td>
<td>Radio (Wi-Fi, Bluetooth, LTE, etc.) allumée ou éteinte par sa "killswitch" ou par un menu</td>
<td>Aucun</td>
<td>
</td>
</tr>
<tr>
<td>thunderbolt</td>
<td>Changement de mode de tunnelage</td>
<td>
<code>TUNNEL_EVENT=</code> avec l'état du tunnel, possiblement aussi <code>TUNNEL_DETAILS=</code>
</td>
<td>
<a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/thunderbolt.html#tunneling-events">Thunderbolt tunneling events</a>
</td>
</tr>
<tr>
<td>N'importe quel appareil avec un groupe d'attributs <code>power/</code>
</td>
<td>Recevoir ou perdre la capacité de sortir le système de veille<sup>1</sup> (c-à-d: lorsque les attributs <code>power/wakeup*</code> apparaissent ou disparaissent)</td>
<td>Aucun</td>
<td>
<a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/pm/devices.html#sys-devices-power-wakeup-files">Device Power Management Basics</a>, mais ce uevent n'est pas documenté
</td>
</tr>
<tr>
<td>Tous (uevent synthétique)</td>
<td>Écrire <code>change $(uuidgen) MACHIN=TOTO</code> dans le fichier uevent de n'importe quel appareil dans sysfs<sup>2</sup>
</td>
<td>
<code>SYNTH_UUID=</code> avec l'UUID écrit dans le fichier, et aussi <code>SYNTH_ARG_MACHIN=TOTO</code> pour toute paire de clé et de valeur écrite après l'UUID</td>
<td>
<a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/abi-testing.html#abi-sys-uevent">sysfs-uevent</a>
</td>
</tr>
</tbody>
</table>
<ol>
<li>Recevoir ou perdre la capacité de sortir le système de veille est intéressant pour des cas comme USB, puisque les appareils USB ne peuvent pas réveiller le système lorsqu'ils sont en attente d'être (re)configurés.</li>
<li>La directive <code>OPTIONS+="watch"</code> dans une règle udev ainsi que la commande <code>udevadm trigger</code> vont faire lever un évènement systhétique par le biais de ce méchanisme, dans les deux cas avec <code>ENV{SYNTH_UUID}=="0"</code>.</li>
</ol>
<div class="mw-heading mw-heading2"><h2 id="udisks">udisks</h2></div>
<p>Consultez <a href="../en/Udisks.html" title="Udisks">udisks</a>.
</p>
<div class="mw-heading mw-heading2"><h2 id="Trucs_et_astuces">Trucs et astuces</h2></div>
<div class="mw-heading mw-heading3"><h3 id="Montage_de_lecteurs_dans_les_règles">
<span id="Montage_de_lecteurs_dans_les_r.C3.A8gles"></span>Montage de lecteurs dans les règles</h3></div>
<p>Pour monter des disques amovibles, n'appelez pas <code>mount</code> à partir des règles <i>udev</i>. Ceci est déconseillé pour deux raisons : 
</p>
<ol>
<li>systemd exécute par défaut <code>systemd-udevd.service</code> avec un "espace de noms mount" séparé (consultez <span class="plainlinks archwiki-template-man" title="$ man 7 namespaces"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/namespaces.7">namespaces(7)</a></span>), ce qui signifie que les montages ne seront pas visibles pour le reste du système.</li>
<li>Même si vous changez les paramètres du service pour résoudre ce problème (en commentant les lignes <code>PrivateMounts</code> et <code>MountFlags</code>), il y a un autre problème qui est que les processus démarrés depuis Udev sont tués après quelques secondes. Dans le cas des systèmes de fichiers FUSE, tels que <a href="../en/NTFS-3G.html" title="NTFS-3G">NTFS-3G</a>, <i>mount</i> démarre un processus en espace utilisateur pour gérer les internes du système de fichiers ; lorsque celui-ci est tué, vous obtiendrez des erreurs <code>Transport endpoint not connected</code> si vous essayez d'accéder au système de fichiers.</li>
</ol>
<p>Il existe quelques options qui fonctionnent :
</p>
<ul>
<li>Démarrer un service systemd personnalisé à partir de la règle Udev ; le service systemd peut invoquer un script qui peut démarrer un nombre quelconque de processus longs (comme FUSE). Un exemple concis qui monte automatiquement les disques USB sous <code>/media</code> est <a rel="nofollow" class="external text" href="https://github.com/Ferk/udev-media-automount">udev-media-automount</a>. Une variante de la même idée est expliquée dans <a rel="nofollow" class="external text" href="http://jasonwryan.com/blog/2014/01/20/udev/">ce post de blog</a>.</li>
<li>Utilisez <code>systemd-mount</code> au lieu de <code>mount</code> dans votre règle Udev. Ceci est <a rel="nofollow" class="external text" href="https://github.com/systemd/systemd/issues/11982#issuecomment-472529566">recommandé par les développeurs de systemd</a>. Par exemple, cette règle Udev devrait monter les disques USB sous <code>/media</code> :</li>
</ul>
<dl><dd><pre>ACTION=="add", SUBSYSTEMS=="usb", SUBSYSTEM=="block", ENV{ID_FS_USAGE}=="filesystem", RUN{program}+="/usr/bin/systemd-mount --no-block --automount=yes --collect $devnode /media"</pre></dd></dl>
<ul><li>Utilisez un paquet comme <a href="../en/Udisks.html" title="Udisks">udisks</a> ou <a href="../en/Udisks.html" class="mw-redirect" title="Udiskie">udiskie</a>. Ils sont très puissants, mais difficiles à mettre en place. De plus, ils sont destinés à être utilisés dans des sessions mono-utilisateur, car ils rendent certains systèmes de fichiers disponibles sous la propriété de l'utilisateur non privilégié dont la session est actuellement active.</li></ul>
<div class="mw-heading mw-heading3"><h3 id="Permettre_aux_utilisateurs_normaux_d'utiliser_les_périphériques">
<span id="Permettre_aux_utilisateurs_normaux_d.27utiliser_les_p.C3.A9riph.C3.A9riques"></span>Permettre aux utilisateurs normaux d'utiliser les périphériques</h3></div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning</strong> N'appliquez pas l'étiquette <code>uaccess</code> sur des des prériphériques d'entrée ou des appareils de stockage; ceux-ci ont leur propres méthodes de controle d'accès et les utilisateurs ne devraient pas en recevoir un accès brût. Par exemple, un accès direct non-privilégié au clavier permettrait à n'importe quelle application lancée par l'utilisateur d'écouter tout ce qui est entré sur le clavier, et un accès direct non-privilégié à un disque pourrait contourner toute méthode de sécurité du système de fichier.</div>
<p>Lorsqu'un pilote <a href="../fr/Kernel.html" class="mw-redirect" title="Noyau">noyau</a> initialise un périphérique, l'état par défaut du nœud de périphérique est d'être la propriété de <code>root:root</code>, avec les permissions <code>600</code>. <a rel="nofollow" class="external autonumber" href="https://github.com/torvalds/linux/blob/v5.19/drivers/base/devtmpfs.c#L11-L13">[1]</a> Cela rend les périphériques inaccessibles aux utilisateurs normaux, à moins que le pilote ne modifie la valeur par défaut, ou qu'une règle udev dans l'espace utilisateur ne modifie les permissions.
</p>
<p>Les valeurs udev <code>OWNER</code>, <code>GROUP</code>, et <code>MODE</code> peuvent être utilisées pour fournir un accès, bien que l'on rencontre le problème de savoir comment rendre un périphérique utilisable par tous les utilisateurs sans être trop permissif. L'approche d'Ubuntu consiste à créer un groupe <code>plugdev</code> auquel les périphériques sont ajoutés, mais cette pratique est non seulement déconseillée par les développeurs de systemd, <a rel="nofollow" class="external autonumber" href="https://bugzilla.redhat.com/show_bug.cgi?id=815093">[2]</a> mais considérée comme un bogue lorsqu'elle est livrée dans les règles udev sur Arch (<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/35602">FS#35602</a>).
</p>
<p>L'approche recommandée est d'utiliser un <code>MODE</code> de <code>660</code> pour laisser le groupe utiliser le périphérique, puis d'attacher une <code>TAG</code> nommée <code>uaccess</code>. Cette balise spéciale permet à udev d'appliquer une <a rel="nofollow" class="external text" href="https://github.com/systemd/systemd/blob/main/src/udev/udev-builtin-uaccess.c">dynamic user ACL</a> au noeud du périphérique, qui se coordonne avec <span class="plainlinks archwiki-template-man" title="$ man 8 systemd-logind"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/systemd-logind.8">systemd-logind(8)</a></span> pour rendre le périphérique utilisable par les utilisateurs connectés. Exemple de règle udev implémentant ceci :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/71-device-name.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEMS=="usb", ATTRS{idVendor}=="<i>vendor_id</i>", ATTRS{idProduct}=="<i>product_id</i>", MODE="0660", TAG+="uaccess"</pre>
<div class="mw-heading mw-heading3"><h3 id="Lancer_des_processus_à_long_terme">
<span id="Lancer_des_processus_.C3.A0_long_terme"></span>Lancer des processus à long terme</h3></div>
<p>Les programmes lancés par udev bloqueront les autres événements provenant de ce périphérique, et toutes les tâches créées à partir d'une règle udev seront tuées une fois le traitement des événements terminé. Si vous devez lancer un processus à long terme avec udev, la manière reccomandée est d'utiliser un service <a href="../en/Systemd.html" title="Systemd">systemd</a> pour lancer la commande proprement-dite, et une règle udev qui ne fait que signaler au service de se lancer. Il est toutefois découragé d'utiliser <code>systemctl</code> dans une règle udev, puisqu'il s'agit d'un outil destiné à un usage interactif qui peut entre autres se bloquer.
</p>
<p>La bonne façon de faire est d'utiliser la règle pour marquer que l'appareil doit recevoir une unité "device" de systemd (voir <span class="plainlinks archwiki-template-man" title="$ man 5 systemd.device"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/systemd.device.5">systemd.device(5)</a></span>) avec <code>TAG+="systemd"</code> et d'ajouter une propriété de soit <code>ENV{SYSTEMD_WANTS}+=</code> pour les services qui fonctionneraient normalement avec <code>systemctl --system</code> ou bien <code>ENV{SYSTEMD_USER_WANTS}+=</code> pour ceux qu'on lancerait avec <code>systemctl --user</code>. Par exemple:
</p>
<p><br>
</p>
<pre>SUBSYSTEM=="tty", ACTION=="add", ATTRS{manufacturer}=="Pulse-Eight", ATTRS{product}=="CEC Adapter", TAG+="systemd", ENV{SYSTEMD_WANTS}+="inputattach-cec@$devnode.service"
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/inputattach-cec@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Configure une interface série USB pour %I

[Service]
Type=simple
ExecStart=/usr/bin/inputattach --pulse8-cec %I</pre>
<p><code>SYSTEMD_WANTS</code> est équivalent à la directive <code>Wants=</code> dans les unités systemd, donc l'appareil n'est pas affecté si jamais le service plante, n'existe pas ou si sa tâche se termine correctement.
</p>
<div class="mw-heading mw-heading3"><h3 id="Exécution_lorsque_le_câble_HDMI_est_branché_ou_débranché">
<span id="Ex.C3.A9cution_lorsque_le_c.C3.A2ble_HDMI_est_branch.C3.A9_ou_d.C3.A9branch.C3.A9"></span>Exécution lorsque le câble HDMI est branché ou débranché</h3></div>
<p>Créez la règle <code>/etc/udev/rules.d/95-hdmi-plug.rules</code> avec le contenu suivant :
</p>
<pre>ACTION=="change", SUBSYSTEM=="drm", ENV{DISPLAY}=":0", ENV{XAUTHORITY}="/home/<i>username</i>/.Xauthority", RUN+="<i>/path/to/script.sh</i>"
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note</strong> Si la règle se déclenche avant le démarrage du serveur X, elle peut ne pas fonctionner comme prévu. Voir <a href="#Les_programmes_graphiques_dans_les_r%C3%A8gles_RUN_se_bloquent_lorsqu'aucun_serveur_X_n'est_pr%C3%A9sent">#Les programmes graphiques dans les règles RUN se bloquent lorsqu'aucun serveur X n'est présent</a>. </div>
<div class="mw-heading mw-heading3"><h3 id="Exécuter_sur_le_branchement_du_câble_VGA">
<span id="Ex.C3.A9cuter_sur_le_branchement_du_c.C3.A2ble_VGA"></span>Exécuter sur le branchement du câble VGA</h3></div>
<p>Créez la règle <code>/etc/udev/rules.d/95-monitor-hotplug.rules</code> avec le contenu suivant pour lancer <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=arandr">arandr</a></span> lors du branchement d'un câble de moniteur VGA :
</p>
<pre>KERNEL=="card0", SUBSYSTEM=="drm", ENV{DISPLAY}=":0", ENV{XAUTHORITY}="/home/<i>username</i>/.Xauthority", RUN+="/usr/bin/arandr"
</pre>
<p>Certains gestionnaires d'affichage stockent le <code>.Xauthority</code> en dehors du répertoire personnel de l'utilisateur. Vous devrez mettre à jour <code>ENV{XAUTHORITY</code>} en conséquence. Par exemple, <a href="../en/GNOME_Display_Manager.html" class="mw-redirect" title="GNOME Display Manager">GNOME Display Manager</a> se présente comme suit :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ printenv XAUTHORITY</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/run/user/1000/gdm/Xauthority</pre>
<div class="mw-heading mw-heading3"><h3 id="Détecter_les_nouveaux_lecteurs_eSATA">
<span id="D.C3.A9tecter_les_nouveaux_lecteurs_eSATA"></span>Détecter les nouveaux lecteurs eSATA</h3></div>
<p>Si votre lecteur eSATA n'est pas détecté lorsque vous le branchez, vous pouvez essayer plusieurs choses. Vous pouvez redémarrer avec le eSATA branché. Ou vous pouvez essayer :
</p>
<pre># echo 0 0 0 &gt; /sys/class/scsi_host/host*/scan
</pre>
<p>Ou vous pouvez installer <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/scsiadd/">scsiadd</a></span><sup><small>AUR</small></sup> (à partir de l'AUR) et essayer :
</p>
<pre># scsiadd -s
</pre>
<p>Avec un peu de chance, votre disque est maintenant dans <code>/dev</code>. Si ce n'est pas le cas, vous pouvez essayer les commandes ci-dessus en cours d'exécution :
</p>
<pre># udevadm monitor
</pre>
<p>pour consulter si quelque chose se passe réellement.
</p>
<div class="mw-heading mw-heading3"><h3 id="Marquer_les_ports_SATA_internes_comme_eSATA">Marquer les ports SATA internes comme eSATA</h3></div>
<p>Si vous avez connecté une baie eSATA ou un autre adaptateur eSATA, le système reconnaîtra toujours ce disque comme un lecteur SATA interne. <a href="../en/GNOME.html" title="GNOME">GNOME</a> et <a href="../en/KDE.html" title="KDE">KDE</a> vous demanderont en permanence votre mot de passe root. La règle suivante marquera le port SATA spécifié comme un port eSATA externe. Avec cela, un utilisateur normal de GNOME peut connecter ses disques eSATA à ce port comme une clé USB, sans mot de passe root et ainsi de suite.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/10-esata.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">DEVPATH=="/devices/pci0000:00/0000:00:1f.2/host4/*", ENV{UDISKS_SYSTEM}="0"
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note</strong> La <code>DEVPATH</code> peut être trouvée après la connexion du lecteur eSATA avec les commandes suivantes (remplacez <code>sdb</code> en conséquence) :
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ udevadm info --query=path /dev/sdb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ find /sys/devices/ -name sdb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/sys/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb
</pre>
</div>
<div class="mw-heading mw-heading3"><h3 id="Définition_de_noms_de_périphériques_statiques">
<span id="D.C3.A9finition_de_noms_de_p.C3.A9riph.C3.A9riques_statiques"></span>Définition de noms de périphériques statiques</h3></div>
<p>Comme <i>udev</i> charge tous les modules de manière asynchrone, ils sont initialisés dans un ordre différent. Cela peut entraîner un changement aléatoire des noms des périphériques. Une règle <i>udev</i> peut être ajoutée pour utiliser des noms de périphériques statiques.
Consultez également <a href="../en/c11459db9e63dfe323791891e90d95f6.html" class="mw-redirect" title="Nommage persistant des périphériques">Nommage persistant des périphériques</a> pour les périphériques de type bloc et <a href="../en/Network_configuration.html#Change_interface_name" title="Network configuration">Network configuration#Change interface name</a> pour les périphériques réseau.
</p>
<div class="mw-heading mw-heading4"><h4 id="Périphérique_vidéo">
<span id="P.C3.A9riph.C3.A9rique_vid.C3.A9o"></span>Périphérique vidéo</h4></div>
<p>Pour configurer la webcam en premier lieu, reportez-vous à <a href="../en/Webcam_setup.html" title="Webcam setup">Webcam setup</a>.
</p>
<p>L'utilisation de plusieurs webcams affectera les périphériques vidéo comme <code>/dev/video*</code> de manière aléatoire au démarrage. La solution recommandée est de créer des liens symboliques en utilisant une règle <i>udev</i> comme dans <a href="#Exemple_de_r%C3%A8gle_udev">#Exemple de règle udev</a> :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/83-webcam.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">KERNEL=="video[0-9]*", SUBSYSTEM=="video4linux", SUBSYSTEMS=="usb", ATTRS{idVendor}=="05a9", ATTRS{idProduct}=="4519", SYMLINK+="video-cam1"
KERNEL=="video[0-9]*", SUBSYSTEM=="video4linux", SUBSYSTEMS=="usb", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="08f6", SYMLINK+="video-cam2"</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note</strong> L'utilisation de noms autres que <code>/dev/video*</code> brisera le préchargement de <code>v4l1compat.so</code> et peut-être de <code>v4l2convert.so</code>
</div>
<div class="mw-heading mw-heading4"><h4 id="Imprimante">Imprimante</h4></div>
<p>Si vous utilisez plusieurs imprimantes, les périphériques <code>/dev/lp[0-9]</code> seront attribués de manière aléatoire au démarrage, ce qui perturbera par exemple la configuration de <a href="../fr/CUPS.html" title="CUPS (Français)">CUPS</a>. 
</p>
<p>Vous pouvez créer la règle suivante, qui créera des liens symboliques sous <code>/dev/lp/by-id</code> et <code>/dev/lp/by-path</code>, de manière similaire au schéma du <a href="../en/c11459db9e63dfe323791891e90d95f6.html" class="mw-redirect" title="Nommage persistant des périphériques">nommage persistant des périphériques</a> :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/60-persistent-printer.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="remove", GOTO="persistent_printer_end"
# Ceci ne devrait pas être nécessaire
#KERNEL!="lp*", GOTO="persistent_printer_end"

SUBSYSTEMS=="usb", IMPORT{builtin}="usb_id"
ENV{ID_TYPE}!="imprimante", GOTO="persistent_printer_end"

ENV{ID_SERIAL}=="?*", SYMLINK+="lp/by-id/$env{ID_BUS}-$env{ID_SERIAL}"

IMPORT{builtin}="path_id"
ENV{ID_PATH}=="?*", SYMLINK+="lp/by-path/$env{ID_PATH}"

LABEL="persistent_printer_end"</pre>
<div class="mw-heading mw-heading3"><h3 id="Identifier_un_disque_par_son_numéro_de_série">
<span id="Identifier_un_disque_par_son_num.C3.A9ro_de_s.C3.A9rie"></span>Identifier un disque par son numéro de série</h3></div>
<p>Pour effectuer une action sur un périphérique disque spécifique <code>/dev/sd<i>X</i></code> identifié de manière permanente par son numéro de série unique <code>ID_SERIAL_SHORT</code> tel qu'affiché avec <code>udevadm info /dev/sd<i>X</i></code>, on peut utiliser la règle suivante. Elle passe comme paramètre le nom du périphérique trouvé s'il y en a un pour illustrer :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/69-disk.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="add", KERNEL=="sd[a-z]", ENV{ID_SERIAL_SHORT}=="<i>X5ER1ALX</i>", RUN+="/path/to/script /dev/%k"</pre>
<div class="mw-heading mw-heading3"><h3 id="Réveil_de_la_suspension_avec_un_périphérique_USB">
<span id="R.C3.A9veil_de_la_suspension_avec_un_p.C3.A9riph.C3.A9rique_USB"></span>Réveil de la suspension avec un périphérique USB</h3></div>
<p>Une règle udev peut être utile pour activer la fonctionnalité de réveil d'un périphérique USB, comme une souris ou un clavier, afin de pouvoir l'utiliser pour sortir la machine de la veille.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note</strong> Par défaut, les contrôleurs hôtes USB sont tous activés pour le réveil. L'état peut être vérifié en utilisant <code>cat /proc/acpi/wakeup</code>. La règle ci-dessous n'est dans ce cas pas nécessaire mais peut être utilisée comme modèle pour effectuer d'autres actions, comme la désactivation de la fonctionnalité de réveil par exemple.
</div>
<p>Tout d'abord, identifiez les identifiants du fournisseur et du produit du périphérique USB. Ils seront utilisés pour le reconnaître dans la règle udev. Par exemple :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ lsusb | grep Logitech</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Bus 007 Device 002: ID <b>046d</b>:<b>c52b</b> Logitech, Inc. Unifying Receiver
</pre>
<p>Ensuite, trouvez l'endroit où le périphérique est connecté en utilisant :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ grep <i>c52b</i> /sys/bus/usb/devices/*/idProduct</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/sys/bus/usb/devices/<b>1-1.1.1.4/</b>idProduct:c52b
</pre>
<p>Créez maintenant la règle pour modifier l'attribut <code>power/wakeup</code> du périphérique et du contrôleur USB auquel il est connecté à chaque fois qu'il est ajouté :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/50-wake-on-device.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ATTRS{idVendor}=="<b>046d</b>", ATTRS{idProduct}=="<b>c52b</b>", ATTR{power/wakeup}="enabled", ATTR{driver/<b>1-1.1.1.4</b>/power/wakeup}="enabled"</pre>
<div class="mw-heading mw-heading3"><h3 id="Forcer_les_fonctionnalités_d'un_appareil_USB_à_être_réinitialisées_en_sortie_de_veille">
<span id="Forcer_les_fonctionnalit.C3.A9s_d.27un_appareil_USB_.C3.A0_.C3.AAtre_r.C3.A9initialis.C3.A9es_en_sortie_de_veille"></span>Forcer les fonctionnalités d'un appareil USB à être réinitialisées en sortie de veille</h3></div>
<p>Les appareils USB doivent être réinitialisés après avoir été suspendus (soit parce que le système sort de veille ou parce que le port a été éteint pour conserver de l'énergie quand l'appareil est devenu inactif), chose que le noyau Linux gère <a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/persist.html">de façon généralement transparente</a> avec une procédure nommée <a rel="nofollow" class="external text" href="https://docs.kernel.org/driver-api/usb/power-management.html">reset-resume</a>, pour que les appareils USB ne se comportent pas comme s'ils avaient été déconnectés puis reconnectés à chaque fois. C'est habituellement ce qu'on recharche, mais certains appareils comme les interfaces USB qui se comportent en port série, ont bel et bien besoin d'être reconfigurées lorsqu'on les rallume, ce qui n'est pas signallé par les pilotes en charge de ces appareils.
</p>
<p>Il y a toutefois un évènement qui survient dans ces conditions, et c'est celui qui indique que l'appareil a pertu et regagné la capacité de sortir le système de veille, puisqu'un appareil USB est inutilisable lorsqu'il est en attende d'être configuré et ne pourrait pas réveiller le système dans cet état. Ces deux évènements n'ont pas de propriétés uniques permettant de les distinguer, mais le permier peut quand-même être identifié facilement car <code>DEVNUM</code> est mis à zéro (alors que ce n'est pas pas un numéro d'appareil valide) <a rel="nofollow" class="external text" href="https://github.com/torvalds/linux/blob/8d561baae505bab6b3f133e10dc48e27e4505cbe/drivers/usb/core/hub.c#L3167-L3178">juste avant</a> que l'appareil soit déconfiguré et ne perde <code>power/wakeup</code>, ce qui fait survenir l'évènement. Lorsque cela se produit, on peut simplement assigner à l'attribut sysfs <code>bConfigurationValue</code> la même valeur qu'il avait déjà pour <a rel="nofollow" class="external text" href="https://docs.kernel.org/admin-guide/abi-stable.html#abi-sys-bus-usb-devices-bconfigurationvalue">forcer le système à reconfigurer</a> l'appareil de manière <i>non transparante</i>, comme s'il avait été déconnecté durant la veille, ce qui dissocie tous les pilotes et enlève tous les périphériques en aval avant des les rajouter quand l'appareil est à nouveau prêt.
</p>
<pre># La règle qu'on cherche vraiment à faire fonctionner
ACTION=="add" SUBSYSTEM=="tty" SUBSYSTEMS="usb" ATTRS{manufacturer}=="Machin" ATTRS{product}=="Toto" TAG+="systemd" ENV{SYSTEMD_WANTS}="setup-usb-tty@$devnode.service"

# Une seconde règle pour relancer la règle plus haut en sortie de veille.
# On ne peut pas utiliser $attr{bConfigurationValue} dans la directive ATTR{},
# donc assurez-vous de changer "1" aux deux endroits par le numéro de configuration
# utilisé par l'appareil quand il est fonctionnel
ACTION=="change" SUBSYSTEM=="usb" ENV{DEVNUM}=="000" ATTR{manufacturer}=="Machin" ATTR{product}=="Toto" ATTR{bConfigurationValue}=="1" ATTR{bConfigurationValue}="1"</pre>
<div class="mw-heading mw-heading3"><h3 id="Déclenchement_d'événements">
<span id="D.C3.A9clenchement_d.27.C3.A9v.C3.A9nements"></span>Déclenchement d'événements</h3></div>
<p>Il peut être utile de déclencher divers événements <i>udev</i>. Par exemple, vous pourriez vouloir simuler la déconnexion d'un périphérique USB sur une machine distante. Dans ce cas, utilisez <code>udevadm trigger</code> :
</p>
<pre># udevadm trigger --verbose --type=subsystems --action=remove --subsystem-match=usb --attr-match="idVendor=abcd"
</pre>
<p>Cette commande déclenchera un événement de suppression USB sur tous les périphériques USB avec l'ID du fournisseur <code>abcd</code>.
</p>
<div class="mw-heading mw-heading2"><h2 id="Dépannage">
<span id="D.C3.A9pannage"></span>Dépannage</h2></div>
<div class="mw-heading mw-heading3"><h3 id="Liste_noire_de_modules">Liste noire de modules</h3></div>
<p>Dans de rares cas, <i>udev</i> peut faire des erreurs et charger les mauvais modules. Pour l'empêcher de le faire, vous pouvez <a href="../en/Mettre_sur_liste_noire.html" class="mw-redirect" title="Mettre sur liste noire">mettre sur liste noire</a> les modules. Une fois mis sur liste noire, <i>udev</i> ne chargera jamais ce module - ni au démarrage, ni plus tard lorsqu'un événement hot-plug est reçu (par exemple, lorsque vous branchez votre clé USB).
</p>
<div class="mw-heading mw-heading3"><h3 id="Sortie_de_débogage">
<span id="Sortie_de_d.C3.A9bogage"></span>Sortie de débogage</h3></div>
<p>Pour obtenir des informations sur le matériel <a href="../fr/General_troubleshooting.html" title="General troubleshooting (Français)">débogage</a>, utilisez le <a href="../en/Kernel_parameters.html" title="Kernel parameters">paramètre du noyau</a> <code>udev.log-priority=debug</code>. Vous pouvez également définir
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/udev.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">udev_log="debug"</pre>
<p>Cette option peut également être compilée dans votre initramfs en ajoutant le fichier de configuration à votre tableau <code>FILES</code>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">FILES="... /etc/udev/udev.conf"</pre>
<p>et ensuite <a href="../en/7764ac88b5059034c7f2213e2665c8b0.html" class="mw-redirect" title="Régénérez l'initramfs">régénérez l'initramfs</a>.
</p>
<div class="mw-heading mw-heading3"><h3 id="udevd_se_bloque_au_démarrage">
<span id="udevd_se_bloque_au_d.C3.A9marrage"></span>udevd se bloque au démarrage</h3></div>
<p>Après la migration vers LDAP ou la mise à jour d'un système basé sur LDAP, <i>udevd</i> peut se bloquer au démarrage avec le message "Starting UDev Daemon". Cela est généralement dû au fait que <i>udevd</i> essaie de rechercher un nom dans LDAP mais échoue, car le réseau n'est pas encore opérationnel. La solution est de s'assurer que tous les noms de groupes du système sont présents localement.
</p>
<p>Extrayez les noms de groupes référencés dans les règles de <i>udev</i> et les noms de groupes réellement présents sur le système :
</p>
<pre># grep -Fr GROUP /etc/udev/rules.d/ /usr/lib/udev/rules.d/ | sed 's :.*GROUP="\([-a-z_]\{1,\}\)".*:\1:' | sort -u &gt;udev_groups
# cut -d : -f1 /etc/gshadow /etc/group | sort -u &gt;present_groups
</pre>
<p>Pour consulter les différences, faites une comparaison côte à côte :
</p>
<pre># diff -y present_groups udev_groups
...
network &lt;
nobody &lt;
ntp &lt;
optique optique
puissance &lt; pcscd
rfkill &lt;
root root
scanner scanner
smmsp &lt;
stockage stockage
...
</pre>
<p>Dans ce cas, le groupe <code>pcscd</code> est pour une raison quelconque absent du système. <a href="../fr/Users_and_groups.html#Gestion_des_groupes" title="Users and groups (Français)">Ajouter les groupes manquants</a>. Assurez-vous également que les ressources locales sont recherchées avant de recourir à LDAP. <code>/etc/nsswitch.conf</code> devrait contenir la ligne suivante :
</p>
<pre>group : files ldap
</pre>
<div class="mw-heading mw-heading3"><h3 id="Certains_périphériques,_qui_devraient_être_traités_comme_amovibles,_ne_le_sont_pas">
<span id="Certains_p.C3.A9riph.C3.A9riques.2C_qui_devraient_.C3.AAtre_trait.C3.A9s_comme_amovibles.2C_ne_le_sont_pas"></span>Certains périphériques, qui devraient être traités comme amovibles, ne le sont pas</h3></div>
<p>Vous devez créer une règle <i>udev</i> personnalisée pour ce périphérique particulier. Pour obtenir des informations définitives sur le périphérique, vous pouvez utiliser soit <code>ID_SERIAL</code>, soit <code>ID_SERIAL_SHORT</code>. (n'oubliez pas de modifier <code>/dev/sdb</code> si nécessaire) :
</p>
<pre>$ udevadm info /dev/sdb | grep ID_SERIAL
</pre>
<p>Ensuite, définissez <code>UDISKS_AUTO="1"</code> pour marquer le périphérique pour le montage automatique et <code>UDISKS_SYSTEM="0"</code> pour marquer le périphérique comme "amovible". Consultez <span class="plainlinks archwiki-template-man" title="$ man 8 udisks"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/udisks.8">udisks(8)</a></span> pour plus de détails.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/99-removable.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ENV{ID_SERIAL_SHORT}== "<i>serial_number</i>", ENV{UDISKS_AUTO}="1", ENV{UDISKS_SYSTEM}="0"</pre>
<p>N'oubliez pas de recharger les règles <i>udev</i> avec <code>udevadm control --reload</code>. La prochaine fois que vous brancherez votre périphérique, il sera traité comme un disque externe.
</p>
<div class="mw-heading mw-heading3"><h3 id="Problèmes_de_son_avec_certains_modules_non_chargés_automatiquement">
<span id="Probl.C3.A8mes_de_son_avec_certains_modules_non_charg.C3.A9s_automatiquement"></span>Problèmes de son avec certains modules non chargés automatiquement</h3></div>
<p>Certains utilisateurs ont attribué ce problème à d'anciennes entrées dans <code>/etc/modprobe.d/sound.conf</code>. Essayez de nettoyer ce fichier et réessayez.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note</strong> Depuis <code>udev&gt;=171</code>, les modules d'émulation OSS (<code>snd_seq_oss</code>, <code>snd_pcm_oss</code>, <code>snd_mixer_oss</code>) ne sont pas chargés automatiquement par défaut.</div>
<div class="mw-heading mw-heading3"><h3 id="Prise_en_charge_des_lecteurs_de_CD/DVD_IDE">
<span id="Prise_en_charge_des_lecteurs_de_CD.2FDVD_IDE"></span>Prise en charge des lecteurs de CD/DVD IDE</h3></div>
<p>À partir de la version 170, <i>udev</i> ne prend pas en charge les lecteurs de CD-ROM/DVD-ROM qui sont chargés comme des lecteurs IDE traditionnels avec le module <code>ide_cd_mod</code> et qui apparaissent sous la forme <code>/dev/hd*</code>. Le lecteur reste utilisable pour les outils qui accèdent directement au matériel, comme <a href="../en/Optical_disc_drive.html#Ripping" title="Optical disc drive">cdparanoia</a>, mais est invisible pour les programmes supérieurs en espace utilisateur, comme KDE.
</p>
<p>Une cause pour le chargement du module ide_cd_mod avant les autres, comme sr_mod, pourrait être par exemple que vous avez pour une raison quelconque le module piix chargé avec votre <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">initramfs</a>. Dans ce cas, vous pouvez simplement le remplacer par ata_piix dans votre <code>/etc/mkinitcpio.conf</code>.
</p>
<div class="mw-heading mw-heading3"><h3 id="Les_lecteurs_optiques_ont_un_ID_de_groupe_défini_sur_&quot;disk&quot;">
<span id="Les_lecteurs_optiques_ont_un_ID_de_groupe_d.C3.A9fini_sur_.22disk.22"></span>Les lecteurs optiques ont un ID de groupe défini sur "disk"</h3></div>
<p>Si l'ID de groupe de votre lecteur optique est défini sur <code>disk</code> et que vous souhaitez qu'il soit défini sur <code>optical</code>, vous devez créer une règle <i>udev</i> personnalisée :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># Permissions pour les périphériques CD IDE
SUBSYSTEMS=="ide", KERNEL=="hd[a-z]", ATTR{removable}=="1", ATTRS{media}=="cdrom*", GROUP="optical"

# permissions pour les périphériques CD SCSI
SUBSYSTEMS=="scsi", KERNEL=="s[rg][0-9]*", ATTRS{type}=="5", GROUP="optical"</pre>
<div class="mw-heading mw-heading3"><h3 id="Les_programmes_graphiques_dans_les_règles_RUN_se_bloquent_lorsqu'aucun_serveur_X_n'est_présent">
<span id="Les_programmes_graphiques_dans_les_r.C3.A8gles_RUN_se_bloquent_lorsqu.27aucun_serveur_X_n.27est_pr.C3.A9sent"></span>Les programmes graphiques dans les règles RUN se bloquent lorsqu'aucun serveur X n'est présent</h3></div>
<p>Lorsque <i>xrandr</i> ou un autre programme basé sur X tente de se connecter à un serveur X, il se rabat sur une connexion TCP en cas d'échec. Cependant, à cause de <code>IPAddressDeny</code> dans la <a rel="nofollow" class="external text" href="https://github.com/systemd/systemd/blob/main/units/systemd-udevd.service.in#L43">systemd-udev service configuration</a>, cela se bloque. Finalement, le programme sera tué et le traitement des événements reprendra.
</p>
<p>Si la règle est destinée à un périphérique drm et que le blocage entraîne la fin du traitement des événements après le démarrage du serveur X, l'accélération 3D peut cesser de fonctionner avec une erreur <code>failed to authenticate magic</code>.
</p>
<div class="mw-heading mw-heading2"><h2 id="Voir_aussi">Voir aussi</h2></div>
<ul>
<li><span class="plainlinks archwiki-template-man" title="$ man 7 udev"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/udev.7">udev(7)</a></span></li>
<li><a rel="nofollow" class="external text" href="https://opensource.com/article/18/11/udev">Une introduction à udev</a></li>
<li><a rel="nofollow" class="external text" href="http://vger.kernel.org/vger-lists.html#linux-hotplug">Informations sur la liste de diffusion d'udev</a></li>
<li>
<a rel="nofollow" class="external text" href="http://jasonwryan.com/blog/2014/01/20/udev/">Scripting with udev</a> (en anglais)</li>
<li><a rel="nofollow" class="external text" href="https://www.reactivated.net/writing_udev_rules.html">Écriture de règles udev</a></li>
<li><a rel="nofollow" class="external text" href="https://www.linuxfromscratch.org/lfs/view/stable/chapter09/udev.html">Gestion des périphériques et modules sur un système LFS</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/Ventto/xpub">Exécution de l'interface graphique ou accès aux variables d'affichage à partir des règles udev</a></li>
</ul>
</div>
</div>
					<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../fr/Category:Hardware_detection_and_troubleshooting.html" title="Category:Hardware detection and troubleshooting (Français)">Hardware detection and troubleshooting (Français)</a></li></ul>
</div></div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" style="margin: 0">
	<ul id="footer-info">
	<li data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Udev_(Fran%C3%A7ais)&amp;oldid=852964">https://wiki.archlinux.org/index.php?title=Udev_(Français)&amp;oldid=852964</a>"</li>
<li id="footer-info-lastmod"> This page was last edited on 16 November 2025, at 11:40.</li>
	<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
<br>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://terms.archlinux.org/docs/privacy-policy/">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../en/ArchWiki:About.html">About ArchWiki</a></li>
	<li id="footer-places-disclaimers"><a href="../en/ArchWiki:General_disclaimer.html">Disclaimers</a></li>
	<li id="footer-places-archwiki-code-of-conduct"><a href="https://terms.archlinux.org/docs/code-of-conduct/" class="extiw" title="archlinux-service-agreements:code-of-conduct">Code of conduct</a></li>
	<li id="footer-places-archwiki-terms-of-service"><a href="https://terms.archlinux.org/docs/terms-of-service/" class="extiw" title="archlinux-service-agreements:terms-of-service">Terms of service</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://www.gnu.org/copyleft/fdl.html" class="cdx-button cdx-button--fake-button cdx-button--size-large cdx-button--fake-button--enabled"><img src="/resources/assets/licenses/gnu-fdl.png" alt="GNU Free Documentation License 1.3 or later" width="88" height="31" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><picture><source media="(min-width: 500px)" srcset="/resources/assets/poweredby_mediawiki.svg" width="88" height="31"><img src="/resources/assets/mediawiki_compact.svg" width="25" height="25" loading="lazy"></picture></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-header-container vector-sticky-header-container no-font-mode-scale">
	<div id="vector-sticky-header" class="vector-sticky-header">
		<div class="vector-sticky-header-start">
			<div class="vector-sticky-header-icon-start vector-button-flush-left vector-button-flush-right" aria-hidden="true">
				<button class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-sticky-header-search-toggle" tabindex="-1" data-event-name="ui.vector-sticky-search-form.icon"><span class="vector-icon mw-ui-icon-search mw-ui-icon-wikimedia-search"></span>

<span>Search</span>
			</button>
		</div>
			
		<div role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box">
			<div class="vector-typeahead-search-container">
				<div class="cdx-typeahead-search cdx-typeahead-search--show-thumbnail">
					<form action="/index.php" id="vector-sticky-search-form" class="cdx-search-input cdx-search-input--has-end-button">
						<div class="cdx-search-input__input-wrapper" data-search-loc="header-moved">
							<div class="cdx-text-input cdx-text-input--has-start-icon">
								<input class="cdx-text-input__input mw-searchInput" autocomplete="off" type="search" name="search" placeholder="Search ArchWiki">
								<span class="cdx-text-input__icon cdx-text-input__start-icon"></span>
							</div>
							<input type="hidden" name="title" value="Special:Search">
						</div>
						<button class="cdx-button cdx-search-input__end-button">Search</button>
					</form>
				</div>
			</div>
		</div>
		<div class="vector-sticky-header-context-bar">
				<nav aria-label="Contents" class="vector-toc-landmark">
						
					<div id="vector-sticky-header-toc" class="vector-dropdown mw-portlet mw-portlet-sticky-header-toc vector-sticky-header-toc vector-button-flush-left">
						<input type="checkbox" id="vector-sticky-header-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-sticky-header-toc" class="vector-dropdown-checkbox " aria-label="Toggle the table of contents">
						<label id="vector-sticky-header-toc-label" for="vector-sticky-header-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
						</label>
						<div class="vector-dropdown-content">
					
						<div id="vector-sticky-header-toc-unpinned-container" class="vector-unpinned-container">
						</div>
					
						</div>
					</div>
			</nav>
				<div class="vector-sticky-header-context-bar-primary" aria-hidden="true">udev (Français)</div>
			</div>
		</div>
		<div class="vector-sticky-header-end" aria-hidden="true">
			<div class="vector-sticky-header-icons">
				<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-talk-sticky-header" tabindex="-1" data-event-name="talk-sticky-header"><span class="vector-icon mw-ui-icon-speechBubbles mw-ui-icon-wikimedia-speechBubbles"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-subject-sticky-header" tabindex="-1" data-event-name="subject-sticky-header"><span class="vector-icon mw-ui-icon-article mw-ui-icon-wikimedia-article"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-history-sticky-header" tabindex="-1" data-event-name="history-sticky-header"><span class="vector-icon mw-ui-icon-wikimedia-history mw-ui-icon-wikimedia-wikimedia-history"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only mw-watchlink" id="ca-watchstar-sticky-header" tabindex="-1" data-event-name="watch-sticky-header"><span class="vector-icon mw-ui-icon-wikimedia-star mw-ui-icon-wikimedia-wikimedia-star"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only reading-lists-bookmark" id="ca-bookmark-sticky-header" tabindex="-1" data-event-name="watch-sticky-bookmark"><span class="vector-icon mw-ui-icon-wikimedia-bookmarkOutline mw-ui-icon-wikimedia-wikimedia-bookmarkOutline"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-edit-sticky-header" tabindex="-1" data-event-name="wikitext-edit-sticky-header"><span class="vector-icon mw-ui-icon-wikimedia-wikiText mw-ui-icon-wikimedia-wikimedia-wikiText"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-ve-edit-sticky-header" tabindex="-1" data-event-name="ve-edit-sticky-header"><span class="vector-icon mw-ui-icon-wikimedia-edit mw-ui-icon-wikimedia-wikimedia-edit"></span>

<span></span>
			</a>
			<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only" id="ca-viewsource-sticky-header" tabindex="-1" data-event-name="ve-edit-protected-sticky-header"><span class="vector-icon mw-ui-icon-wikimedia-editLock mw-ui-icon-wikimedia-wikimedia-editLock"></span>

<span></span>
			</a>
		</div>
			<div class="vector-sticky-header-buttons">
				<a href="#" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive" id="ca-addsection-sticky-header" tabindex="-1" data-event-name="addsection-sticky-header"><span class="vector-icon mw-ui-icon-speechBubbleAdd-progressive mw-ui-icon-wikimedia-speechBubbleAdd-progressive"></span>

<span>Add topic</span>
			</a>
		</div>
			<div class="vector-sticky-header-icon-end">
				<div class="vector-user-links">
				</div>
			</div>
		</div>
	</div>
</div>
<div class="mw-portlet mw-portlet-dock-bottom emptyPortlet" id="p-dock-bottom">
	<ul>
		
	</ul>
</div>
</body>
</html>
